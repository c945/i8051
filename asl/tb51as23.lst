 AS V1.42 Beta [Bld 32] - source file tb51as23.asm - page 1 - 1/7/2020 15:50:22
Tiny-Basic51 - Modified for Macro Assembler AS


       1/       0 :                     ;	$MOD51
       2/       0 :                     	CPU	8051
       3/       0 :                     	include	stddef51.inc
(1)    1/       0 :                                     save
(1)  375/       0 :                                     restore                 ; wieder erlauben
(1)  376/       0 :                     
(1)  377/       0 :                     
       4/       0 :                     ;       $NODEBUG
       5/       0 :                     ;	$PAGEWIDTH	(80)
       6/       0 :                     ;	$PAGELENGTH	(66)
       7/       0 :                     	page	0
       8/       0 :                     ;       $TITLE          (Tiny-Basic51 - Modified for Metalink ASM51)
       9/       0 :                     	title	"Tiny-Basic51 - Modified for Macro Assembler AS"
      10/       0 :                     
      11/       0 :                     #define	OR	|
      12/       0 :                     #define	AND	&
      13/       0 :                     
      14/       0 :                     LIT_    MACRO   K
      15/       0 :                     	CALL	LIT
      16/       0 :                     	DB	K
      17/       0 :                     	ENDM
      18/       0 :                     
      19/       0 :                     TSTV_   MACRO   LBL
      20/       0 :                             CALL    TSTV
      21/       0 :                             JNC     LBL
      22/       0 :                             ENDM
      23/       0 :                     
      24/       0 :                     TSTN_   MACRO   LBL
      25/       0 :                             CALL    TSTN
      26/       0 :                             JNC     LBL
      27/       0 :                             ENDM
      28/       0 :                     
      29/       0 :                     TSTL_   MACRO   LBL
      30/       0 :                             CALL    TSTN
      31/       0 :                             JNC     LBL
      32/       0 :                             ENDM
      33/       0 :                     
      34/       0 :                     TSTS_   MACRO   LBL
      35/       0 :                             CALL    TSTS
      36/       0 :                             JC      LBL
      37/       0 :                             ENDM
      38/       0 :                     
      39/       0 :                     IFDONE_ MACRO   LBL
      40/       0 :                             CALL    IFDONE
      41/       0 :                             JNC     LBL
      42/       0 :                             ENDM
      43/       0 :                     
      44/       0 :                     LINIT_  MACRO
      45/       0 :                             CALL   L_INIT
      46/       0 :                             JC      ERRENT
      47/       0 :                             ENDM
      48/       0 :                     
      49/       0 :                     COND_   MACRO   LBL
      50/       0 :                             CALL   COND
      51/       0 :                             JNC    LBL
      52/       0 :                             ENDM
      53/       0 :                     
      54/       0 :                     NEXT_LOOP_       MACRO   LBL
      55/       0 :                             CALL   LOOP
      56/       0 :                             JC     LBL
      57/       0 :                             ENDM
      58/       0 :                     
      59/       0 :                     IJMP_   MACRO   LBL
      60/       0 :                             JMP     LBL
      61/       0 :                             ENDM
      62/       0 :                     
      63/       0 :                     HOP_    MACRO   LBL
      64/       0 :                             SJMP    LBL
      65/       0 :                             ENDM
      66/       0 :                     
      67/       0 :                     ICALL_  MACRO   LBL
      68/       0 :                             CALL    LBL
      69/       0 :                             ENDM
      70/       0 :                     
      71/       0 :                     MLCALL_ MACRO
      72/       0 :                             CALL    MLCALL
      73/       0 :                             ANL     PSW,#11100111B
      74/       0 :                             ENDM
      75/       0 :                     
      76/       0 :                     
      77/       0 :                     ;$ERRORPRINT TITLE(MCS-51(TM) TINY BASIC INTERPRETER 8/26/80)
      78/       0 :                     ;
      79/       0 :                     ;	TINY BASIC INTERPRETER PROGRAM  (CREATED 3/10/80   JHW)
      80/       0 :                     ;	==============================
      81/       0 :                     ;
      82/       0 :                     ;	INSITE ORDER NO. BF10
      83/       0 :                     ;
      84/       0 : =23H                VERS    EQU     23H
      85/       0 :                     ;
      86/       0 :                     ; Known Update History:
      87/       0 :                     ; Modified from 2.1 to 2.2 by lss 4 jan 1983 to fix errors in the divide routine; and the random number generator.
      88/       0 :                     ; Updated: Jim Lum/CompTech Systems, Inc. 04/25/92  V2.3  Converted to Metalink ASM51
      89/       0 :                     ;
      90/       0 :                     ;
      91/       0 :                     ;	STATUS:
      92/       0 :                     ;	======
      93/       0 :                     ;
      94/       0 :                     ;
      95/       0 :                     ;	NEW FEATURES/GIMMICKS TO BE CONSIDERED:
      96/       0 :                     ;
      97/       0 :                     ;	On power-up, system should adapt itself to whatever RAM it can
      98/       0 :                     ;	find off-chip.
      99/       0 :                     ;	Should allow for and/or identify multiple baud rates for serial link.
     100/       0 :                     ;	Should allow other physical devices (software serial I/O, etc.).
     101/       0 :                     ;
     102/       0 :                     ;	Amount of RAM consumed by BASIC variables should be user-alterable.
     103/       0 :                     ;	16-bit variable array handling should be provided when external RAM
     104/       0 :                     ;	is available.
     105/       0 :                     ;	Program buffering in internal RAM and/or line buffering in external RAM
     106/       0 :                     ;	(when available/not available) might be nice.
     107/       0 :                     ;
     108/       0 :                     ;	INNUM could be changed to allow line editing and expression input.
     109/       0 :                     ;
     110/       0 :                     ;	Interrupt handlers should be provided for, and supported by strapping
     111/       0 :                     ;	options so that CRT is not required.
     112/       0 :                     ;
     113/       0 :                     ;	Symbolically-accessable 8-bit pseudo CPU-registers, ports,
     114/       0 :                     ;	etc. desired to support ML debug.
     115/       0 :                     ;	During CALL, pseudo-registers should be loaded/saved.
     116/       0 :                     ;
     117/       0 :                     ;	Capability to load and dump programs to MDS or twin system desired.
     118/       0 :                     ;	Download command desired compatible with ISIS hex file format.
     119/       0 :                     ;	Line buffering should ignore initial line-feed to be compatible
     120/       0 :                     ;	with down-load or cross-load, and terminate on <cntrl-Z>.
     121/       0 :                     ;
     122/       0 :                     ;	Expression evaluation algorithm should be changed to use less stack
     123/       0 :                     ;	and allow more precedence levels.
     124/       0 :                     ;	Since EXPR recursive, hardware stack can overflow (not checked).
     125/       0 :                     ;
     126/       0 :                     ;	NEXT command should verify that a valid loop record is on the AES 
     127/       0 :                     ;	as opposed to GOSUB return address, and vice-versa.
     128/       0 :                     ;	STEP values other than +1 should be considered.
     129/       0 :                     ;
     130/       0 :                     ;	Error reporting could re-type line and indicate error point.
     131/       0 :                     ;	Error numbers (if retained) should make some sense.
     132/       0 :                     ;	Might be indices for error message strings.
     133/       0 :                     ;
     134/       0 :                     ;	TRACE mode could aid BASIC debug by typing each source line # executed.
     135/       0 :                     ;
     136/       0 :                     ;	RND number seed should be easily alterable for games, etc.
     137/       0 :                     ;
     138/       0 :                     ;$EJECT
     139/       0 :                     ;
     140/       0 :                     ;	AESTHETIC IMPROVEMENTS DESIRED:
     141/       0 :                     ;
     142/       0 :                     ;	Disallow 0 and >7FFFH line numbers.
     143/       0 :                     ;
     144/       0 :                     ;	Source modules could be re-grouped to be more readable
     145/       0 :                     ;	and re-ordered to minimize use of LJMPs and LCALLs.
     146/       0 :                     ;	Linkage jumps might be created in second 2K page to provide efficient
     147/       0 :                     ;	access to first 2K.
     148/       0 :                     ;
     149/       0 :                     ;	PRN could insert zeros before leading Hex digits.
     150/       0 :                     ;
     151/       0 :                     ;	IDIV uses variable storage inefficiently (TMP0-TMP4).
     152/       0 :                     ;	Should be modified to make use of actual stack variables.
     153/       0 :                     ;
     154/       0 :                     ;	TST could use optimized algorithm for single character token tests.
     155/       0 :                     ;	String tests should skip over unsearched strings more efficiently.
     156/       0 :                     ;
     157/       0 :                     ;	Program buffer searching could be speeded by giving line length 
     158/       0 :                     ;	before text string and computing branch over undesired lines.
     159/       0 :                     ;
     160/       0 :                     ;	Math and AES operations might be optimized by dedicating R1 as AESP
     161/       0 :                     ;	to be loaded and saved only on entering/leaving execution mode.
     162/       0 :                     ;
     163/       0 :                     ;	Input radix should be determined by 'H' suffix presence.
     164/       0 :                     ;	Otherwise labels (GOTO destinations) should always be decimal.
     165/       0 :                     ;
     166/       0 :                     ;	Space between GO and TO might be forgiven.
     167/       0 :                     ;
     168/       0 :                     ;	Certain commands might be disallowed in each operating mode:
     169/       0 :                     ;	No LIST in execution, no INPUT in interactive, for instance.
     170/       0 :                     ;	Some commands (FOR, GOTO, RETURN, etc.) must be last command in line.
     171/       0 :                     ;
     172/       0 :                     ;	GETLN could be made somewhat more abstract, so that L_INIT and READ_C
     173/       0 :                     ;	return characters from edited line buffer in interactive mode and
     174/       0 :                     ;	code buffer in execution mode.  Dual execution loops in main IL program
     175/       0 :                     ;	can then be combined.  (Line insertion should default when no keyword
     176/       0 :                     ;	tokens would be detected during parsing.)
     177/       0 :                     ;
     178/       0 :                     ;	Get rid of LIST and FNDLBL kludge which falsely sets RUNFLG to fool
     179/       0 :                     ;	READ_C subroutine.
     180/       0 :                     ;
     181/       0 :                     ;	Sequential string testing (command parsing, operator recognition, etc.)
     182/       0 :                     ;	could be made table-driven, eliminating repeated "CALL TST"s.
     183/       0 :                     ;
     184/       0 :                     ;	All data structures need to be better defined in listing.
     185/       0 :                     ;	It would be a wise exercize to gather each 
     186/       0 :                     ;	data-structure definition/declaration/accessing-routine set
     187/       0 :                     ;	into isolated functional modules (like objects),
     188/       0 :                     ;	with communication only via global variables.
     189/       0 :                     
     190/       0 :                     ;
     191/       0 :                     ;$EJECT
     192/       0 :                     ;
     193/       0 :                     ;	GLOBAL VARIABLE AND DATA STRUCTURE DECLARATIONS:
     194/       0 :                     ;	====== ======== === ==== ========= ============
     195/       0 :                     ;
     196/       0 :                     ;	Intended System Configuration Constants:
     197/       0 :                     ;
     198/       0 : =2034H              EXTRAM	EQU	2034H		;External program buffer begins after 26 vars.
     199/       0 : =3000H              RAMLIM	EQU	3000H		;Allowance made for 4K RAM buffer.
     200/       0 : =1080H              EXTROM	EQU	1080H		;Start of external ROM space.
     201/       0 : =8H                 TABSIZ	EQU	8		;Formatted column spacing.
     202/       0 : =24H                AESLEN	EQU	36		;AES Length.
     203/       0 :                     ;
     204/       0 :                     ;	Working Register Definitions.
     205/       0 :                     ;
     206/       0 :                     #define	PNTR_L	R0
     207/       0 :                     		;Program buffer pointer.
     208/       0 :                     #define	DEST_L	R1
     209/       0 :                     		;Destination pointer for line insertion.
     210/       0 :                     #define	PNTR_H	R2
     211/       0 :                     		;High-order pointer byte (temp. cursor)
     212/       0 :                     #define	DEST_H	R3
     213/       0 :                     
     214/       0 :                     #define	CHAR	R4
     215/       0 :                     		;BASIC source string character being parsed.
     216/       0 :                     #define	LP_CNT	R5
     217/       0 :                     
     218/       0 :                     #define	TOS_L	R6
     219/       0 :                     #define	TOS_H	R7
     220/       0 :                     		;Variable popped from stack for math routines.
     221/       0 :                     ;
     222/      30 :                     	segment	DATA
     223/       8 :                     	ORG	08H
     224/       8 :                     ;
     225/       8 :                     ;	Temporary variables used by IDIV routine.
     226/       8 :                     ;
     227/       8 :                     TMP0:	DS	1
     228/       9 :                     TMP1:	DS	1
     229/       A :                     TMP2:	DS	1
     230/       B :                     TMP3:	DS	1
     231/       C :                     TMP4:	DS	1
     232/       D :                     ;
     233/       D :                     ;	Random number key.
     234/       D :                     ;
     235/       D :                     SEED_L:	DS	1
     236/       E :                     SEED_H:	DS	1
     237/       F :                     ;
     238/       F :                     ;
     239/       F :                     STRLEN:	DS	1		;Length of text string in L_BUF.
     240/      10 :                     ;
     241/      10 :                     ;US_VAR		User Variable (A,B,...) Array:
     242/      10 :                     ;
     243/      10 : =CH                 NO_VAR	EQU	12		;Allow 12 internal variables A - L.
     244/      10 :                     US_VAR:	DS	2*NO_VAR	;Allocate variable storage space.
     245/      28 :                     ;
     246/      28 : =28H                MODE:	SFR	$
     247/      28 :                     	DS	1		;Operating mode bits.
     248/      29 : =40                 EXTVAR	BIT	MODE.0		;Set when BASIC variables in external RAM.
     249/      29 : =41                 ROMMOD	BIT	MODE.1		;Set when BASIC programs executed from ROM.
     250/      29 : =42                 EXTMOD	BIT	MODE.2		;Set when BASIC programs fetched externally.
     251/      29 : =43                 RUNMOD	BIT	MODE.3		;Set when stored BASIC program is running.
     252/      29 : =44                 HEXMOD	BIT	MODE.4		;Set when operations should use HEX radix.
     253/      29 :                     ;
     254/      29 : =29H                FLAGS:	SFR	$
     255/      29 :                     	DS	1		;Interroutine communication flags.
     256/      2A : =48                 ZERSUP	BIT	FLAGS.0		;If set, suppress printing leading zeroes.
     257/      2A : =49                 CHAR_FLG	BIT	FLAGS.1		;Set when CHAR has not been processed.
     258/      2A : =4A                 SGN_FLG	BIT	FLAGS.2		;Keeps track of operand(s) sign during math.
     259/      2A : =4B                 SEQ_FLG	BIT	FLAGS.3		;
     260/      2A : =4C                 MOD_FLG	BIT	FLAGS.4		;Set if divide routine should return MOD value.
     261/      2A : =4D                 H_FLG	BIT	FLAGS.5		;Used to sense allow 'H' suffix in HEX mode.
     262/      2A :                     ;
     263/      2A :                     ;AES	Arithmetic Expression Stack.
     264/      2A :                     ;
     265/      2A :                     AESP:	DS	1		;AES Stack Pointer
     266/      2B :                     AES:	DS	AESLEN		;Buffer allocation.
     267/      4F :                     ;
     268/      4F :                     ;
     269/      4F :                     ;	Line Buffer Variables:
     270/      4F :                     L_CURS:	DS	1		;Cursor for line buffer.
     271/      50 :                     ;
     272/      50 :                     TABCNT:	DS	1		;Column formatting count.
     273/      51 :                     ;
     274/      51 :                     ;CURSOR	Source line cursor.
     275/      51 :                     CURS_L:	DS	1
     276/      52 :                     CURS_H:	DS	1
     277/      53 :                     C_SAVE:	DS	1		;CHAR saved during SAVE_PNTR.
     278/      54 :                     ;
     279/      54 :                     LABL_L:	DS	1		;BASIC program source line counter.
     280/      55 :                     LABL_H:	DS	1		;  "       "       "     high byte.
     281/      56 :                     ;
     282/      56 : =55H                SP_BASE	EQU	$-1		;Initialization value for hardware SP.
     283/      56 :                     ;
     284/      56 : =DH                 CR	EQU	0DH		;ASCII CODE FOR <CARRIAGE RETURN>.
     285/      56 : =AH                 LF	EQU	0AH		;  "    "    "  <LINE FEED>.
     286/      56 : =7H                 BEL	EQU	07H		;  "    "    "  <BELL>.
     287/      56 :                     ;
     288/      56 :                     ;$EJECT
     289/      56 :                     ;$SAVE NOGEN
     290/      56 :                     ;
     291/       0 :                     	segment	CODE
     292/       0 :                     	ORG	0
     293/       0 : 80 24               	JMP	S_INIT		;Jump to system initialization routine.
     294/       2 :                     ;
     295/       2 :                     ;	Interrupt routine expansion hooks:
     296/       2 :                     ;
     297/       3 :                             ORG     0003H
     298/       3 : 02 10 03            DD012:  JMP     1003H           ;External interrupt 0 service routine.
     299/       6 :                     ;
     300/       6 : 00 00 00 00 00              DB      0,0,0,0,0
     301/       B :                             ORG     000BH
     302/       B : 02 10 0B            DD014:  JMP     100BH           ;Timer 0 service routine.
     303/       E :                     ;
     304/       E : 00 00 00 00 00              DB      0,0,0,0,0
     305/      13 :                             ORG     0013H
     306/      13 : 02 10 13            DD016:  JMP     1013H           ;External interrupt 1 service routine.
     307/      16 :                     ;
     308/      16 : 00 00 00 00 00              DB      0,0,0,0,0
     309/      1B :                             ORG     001BH
     310/      1B : 02 10 1B            DD018:  JMP     101BH           ;Timer 1 service routine.
     311/      1E :                     ;
     312/      1E : 00 00 00 00 00              DB      0,0,0,0,0
     313/      23 :                             ORG     0023H
     314/      23 : 02 10 23            DD020:  JMP     1023H           ;Serial port interrupt service routine.
     315/      26 :                     ;
     316/      26 :                     ;$EJECT
     317/      26 :                     ;
     318/      26 :                     ;	CONSOLE I/O ROUTINES AND DRIVERS:
     319/      26 :                     ;	======= === ======== === =======
     320/      26 :                     ;
     321/      26 : E4                  S_INIT:	CLR	A
     322/      27 : F5 D0               	MOV	PSW,A
     323/      29 : F5 0E               	MOV	SEED_H,A
     324/      2B : F5 0D               	MOV	SEED_L,A
     325/      2D : 75 81 55            	MOV	SP,#SP_BASE	;Re-initialize hardware stack.
     326/      30 : F1 2C               	CALL	RAM_INIT	;Clear-out variable RAM.
     327/      32 : 30 B0 59            SP_INI:	JNB	RXD,RUNROM
     328/      35 : C2 8E               	CLR	TR1
     329/      37 : 75 98 5A            	MOV	SCON,#01011010B	;TI set indicates transmitter ready.
     330/      3A : 75 89 21            	MOV	TMOD,#00100001B	;Timer 1 is set to auto-reload timer mode.
     331/      3D : 75 8D 00            	MOV	TH1,#0		;Assume fastest rate.
     332/      40 : 78 90               	MOV	R0,#144
     333/      42 : 20 B0 FD            	JB	RXD,$
     334/      45 : D8 FE               BAUDID:	DJNZ	R0,$
     335/      47 : 15 8D               	DEC	TH1
     336/      49 : 78 5E               	MOV	R0,#94
     337/      4B : 30 B0 F7            	JNB	RXD,BAUDID
     338/      4E : 20 B0 FD            	JB	RXD,$		;Hang-up here until space char. over.
     339/      51 : 30 B0 FD            	JNB	RXD,$
     340/      54 : D2 8E               	SETB	TR1
     341/      56 : 31 03               	CALL	STROUT
     342/      58 : 0D 4D 43 53 2D 35           DB      CR,"MCS-51 TINY BASIC/Metalink-Compatible Source V"
                    31 20 54 49 4E 59 
                    20 42 41 53 49 43 
                    2F 4D 65 74 61 6C 
                    69 6E 6B 2D 43 6F 
                    6D 70 61 74 69 62 
                    6C 65 20 53 6F 75 
                    72 63 65 20 56 
     343/      87 : 32 2E 33 8D                 DB      ('0'+VERS/10H),".",('0'+(VERS AND 0FH)),(CR OR  80H)
     344/      8B : 02 08 79            	JMP	START
     345/      8E :                     ;
     346/      8E : D2 42               RUNROM:	SETB	EXTMOD
     347/      90 : D2 41               	SETB	ROMMOD
     348/      92 : 02 08 9A            	JMP	XEC
     349/      95 :                     ;
     350/      95 :                     ;=======
     351/      95 :                     ;
     352/      95 :                     C_IN:
     353/      95 :                     ;	Console character input routine.
     354/      95 :                     ;	Waits for next input from console device and returns with character
     355/      95 :                     ;	code in accumulator.
     356/      95 :                     ;	If character is <CNTRL-C> process syntax error.
     357/      95 :                     ;	Adjust lower-case alphabetics to upper case.
     358/      95 :                     ;
     359/      95 : 30 98 FD            DD005:  JNB     RI,$            ;Wait until character received.
     360/      98 : E5 99                       MOV     A,SBUF          ;Read input character.
     361/      9A : C2 98               	CLR	RI		;Clear reception flag.
     362/      9C : 54 7F               	ANL	A,#7FH		;Mask off data bits.
     363/      9E : B4 03 02            	CJNE	A,#03H,C_IN_2	;Test for CNTRL-C code.
     364/      A1 : 21 2C               	JMP	SYN_ER		;Abort if detected.
     365/      A3 :                     ;
     366/      A3 : B4 61 00            C_IN_2:	CJNE	A,#'a',$+3	;Check for lower-case alphabetics.
     367/      A6 : 40 07               	JC	C_IN_1
     368/      A8 : B4 7B 00            	CJNE	A,#'z'+1,$+3
     369/      AB : 50 02               	JNC	C_IN_1
     370/      AD : 54 DF               	ANL	A,#11011111B	;Force upper-case code.
     371/      AF : 22                  C_IN_1:	RET			;Return to calling routine.
     372/      B0 :                     ;
     373/      B0 :                     ;=======
     374/      B0 :                     ;
     375/      B0 :                     ;
     376/      B0 :                     NLINE:
     377/      B0 :                     ;	Transmit <CR><LF> sequence to console device.
     378/      B0 :                     ;
     379/      B0 : 74 0D               	MOV	A,#CR
     380/      B2 :                     C_OUT:
     381/      B2 :                     ;	Console character output routine.
     382/      B2 :                     ;	Outputs character received in accumulator to console output device.
     383/      B2 :                     ;
     384/      B2 : 30 99 FD            DD006:  JNB     TI,$            ;Wait until transmission completed.
     385/      B5 : C2 99               DD007:  CLR     TI              ;Clear interrupt flag.
     386/      B7 : F5 99               	MOV	SBUF,A		;Write out character.
     387/      B9 : B4 0D 0A            	CJNE	A,#CR,COUT_2
     388/      BC : 30 99 FD            DD008:  JNB     TI,$
     389/      BF : C2 99               DD009:  CLR     TI
     390/      C1 : 75 99 0A            	MOV	SBUF,#LF	;Output linefeed.
     391/      C4 : 80 04               	SJMP	COUT_3
     392/      C6 :                     ;
     393/      C6 : C3                  COUT_2:	CLR	C
     394/      C7 : D5 50 04            	DJNZ	TABCNT,COUT_1	;Monitor output field position.
     395/      CA : 75 50 08            COUT_3:	MOV	TABCNT,#TABSIZ	;Reload field counter.
     396/      CD : D3                  	SETB	C
     397/      CE : 22                  COUT_1:	RET
     398/      CF :                     ;
     399/      CF :                     ;=======
     400/      CF :                     ;
     401/      CF :                     ;
     402/      CF : 30 98 0A            CNTRL:	JNB	RI,CNTRET	;Poll whether character has been typed.
     403/      D2 : 11 95               	CALL	C_IN
     404/      D4 : B4 13 05            	CJNE	A,#13H,CNTRET	;Check if char. is <CNTRL-S>.
     405/      D7 : 11 95               CNTR_2:	CALL	C_IN		;If so, hang up...
     406/      D9 : B4 11 FB            	CJNE	A,#11H,CNTR_2	;    ...until <CNTRL-Q> received.
     407/      DC : 22                  CNTRET:	RET
     408/      DD :                     ;
     409/      DD :                     ;=======
     410/      DD :                     ;
     411/      DD :                     ;
     412/      DD :                     SPC:
     413/      DD :                     ;	Transmit one or more space characters to console to move console
     414/      DD :                     ;	cursor to start of next field.
     415/      DD :                     ;
     416/      DD : 74 20               	MOV	A,#' '	;Load ASCII code for space character.
     417/      DF : 11 B2               	CALL	C_OUT
     418/      E1 : 50 FA               	JNC	SPC		;Repeat until at TAB boundary.
     419/      E3 : 22                  	RET
     420/      E4 :                     ;
     421/      E4 :                     ;===============
     422/      E4 :                     ;
     423/      E4 :                     ;NIBOUT
     424/      E4 :                     ;	If low-order nibble in Acc. is non-zero or ZERSUP flag is cleared,
     425/      E4 :                     ;	output the corresponding ASCII value and clear ZERSUP flag.
     426/      E4 :                     ;	Otherwise return without affecting output or ZERSUP.
     427/      E4 :                     ;
     428/      E4 : 54 0F               NIBOUT:	ANL	A,#0FH		;Mask out low-order bits.
     429/      E6 : 70 03               	JNZ	NIBO_2		;Output ASCII code for Acc contents.
     430/      E8 : 20 48 07            	JB	ZERSUP,NIBO_3
     431/      EB : C2 48               NIBO_2:	CLR	ZERSUP		;Mark that non-zero character encountered.
     432/      ED : 24 03               	ADD	A,#(ASCTBL-(NIBO_1+1))	;Offset to start of table.
     433/      EF : 83                  NIBO_1:	MOVC	A,@A+PC		;Look up corresponding code.
     434/      F0 : 11 B2               	CALL	C_OUT		;Output character.
     435/      F2 : 22                  NIBO_3:	RET
     436/      F3 :                     ;
     437/      F3 : 30 31 32 33 34 35   ASCTBL:	DB	"0123456789ABCDEF"
                    36 37 38 39 41 42 
                    43 44 45 46 
     438/     103 :                     ;
     439/     103 :                     ;=======
     440/     103 :                     ;
     441/     103 :                     ;STROUT
     442/     103 :                     ;	Copy in-line character string to console output device.
     443/     103 :                     ;
     444/     103 : D0 83               STROUT:	POP	DPH		;Access in-line string.
     445/     105 : D0 82               	POP	DPL
     446/     107 : E4                  STRO_1:	CLR	A
     447/     108 : 93                  	MOVC	A,@A+DPTR	;Read next byte.
     448/     109 : A3                  	INC	DPTR		;Bump pointer.
     449/     10A : 10 E7 04            	JBC	ACC.7,STRO_2	;Escape after last character.
     450/     10D : 11 B2               	CALL	C_OUT		;Output character.
     451/     10F : 80 F6               	SJMP	STRO_1		;Loop until done.
     452/     111 :                     ;
     453/     111 : 11 B2               STRO_2:	CALL	C_OUT		;Output character.
     454/     113 : E4                  	CLR	A
     455/     114 : 73                  	JMP	@A+DPTR		;Return to program.
     456/     115 :                     ;
     457/     115 :                     ;=======
     458/     115 :                     ;$EJECT
     459/     115 :                     ERROUT:
     460/     115 :                     ;	Error handling routine common entry point. 
     461/     115 :                     ;	(Could retype bad line, etc.)
     462/     115 :                     ;
     463/     115 : 02 08 7C            	JMP	ERRENT		;Return to executive.
     464/     118 :                     ;
     465/     118 :                     ;=======
     466/     118 :                     ;
     467/     118 :                     ;EXP_ER	Expression evaluation error.
     468/     118 : 31 03               EXP_ER:	CALL	STROUT		;Output error message.
     469/     11A : 48 4F 57 3F 8D              DB      "HOW?",(CR OR 80H)
     470/     11F : 80 F4               	JMP	ERROUT		;Return to executive.
     471/     121 :                     ;
     472/     121 :                     ;=======
     473/     121 :                     ;
     474/     121 :                     ;AES_ER	Arithmetic expression stack error handling routine.
     475/     121 : 31 03               AES_ER:	CALL	STROUT		;Output error message.
     476/     123 : 53 4F 52 52 59 21           DB      "SORRY!",(CR OR 80H)
                    8D 
     477/     12A : 80 E9               	JMP	ERROUT		;Return to executive.
     478/     12C :                     ;
     479/     12C :                     ;
     480/     12C :                     ;=======
     481/     12C :                     ;
     482/     12C :                     ;SYN_ER	Syntax error handling routine.
     483/     12C : 31 03               SYN_ER:	CALL	STROUT		;Output error message.
     484/     12E : 0D 57 48 41 54 3F           DB      CR,"WHAT?",(CR OR 80H)
                    8D 
     485/     135 : 80 DE               	JMP	ERROUT		;Process error.
     486/     137 :                     ;
     487/     137 :                     ;=======
     488/     137 :                     ;$EJECT
     489/     137 :                     
     490/     137 :                     ;
     491/     137 :                     ;	ARITHMETIC SUBROUTINE PACKAGE  (8/12/80)
     492/     137 :                     ;
     493/     137 :                     ;=======
     494/     137 :                     ;
     495/     137 :                     POP_TOS:
     496/     137 :                     ;	Verify that stack holds at least on (16-bit) entry.
     497/     137 :                     ;	(Call AES_ER otherwise.)
     498/     137 :                     ;	Pop TOS into registers TOS_H and TOS_L,
     499/     137 :                     ;	update AESP,
     500/     137 :                     ;	and return with R1 pointing to low-order byte of previous NOS.
     501/     137 :                     ;	Do not affect accumulator contents.
     502/     137 :                     ;
     503/     137 : A9 2A               	MOV	R1,AESP
     504/     139 : B9 2C 00            	CJNE	R1,#AES+1,$+3	;Compare pointer with min. legal level.
     505/     13C : 40 21               	JC	STK_ER
     506/     13E : FE                  	MOV	TOS_L,A
     507/     13F : E7                  	MOV	A,@R1
     508/     140 : FF                  	MOV	TOS_H,A
     509/     141 : 19                  	DEC	R1
     510/     142 : E7                  	MOV	A,@R1
     511/     143 : CE                  	XCH	A,TOS_L		;Store byte and reload ACC.
     512/     144 : 19                  	DEC	R1
     513/     145 : 89 2A               	MOV	AESP,R1
     514/     147 : 19                  	DEC	R1
     515/     148 : 22                  	RET
     516/     149 :                     ;
     517/     149 :                     ;=======
     518/     149 :                     ;
     519/     149 :                     POP_ACC:
     520/     149 :                     ;	Pop TOS into accumulator and update AESP.
     521/     149 :                     ;
     522/     149 : A9 2A               	MOV	R1,AESP
     523/     14B : E7                  	MOV	A,@R1
     524/     14C : 15 2A               	DEC	AESP
     525/     14E : 22                  	RET
     526/     14F :                     ;
     527/     14F :                     ;=======
     528/     14F :                     ;
     529/     14F :                     PUSH_TOS:
     530/     14F :                     ;	Verify that the AES is not full,
     531/     14F :                     ;	push registers TOS_H and TOS_L onto AES,
     532/     14F :                     ;	and update AESP.
     533/     14F :                     ;
     534/     14F : A9 2A               	MOV	R1,AESP
     535/     151 : B9 4D 00            	CJNE	R1,#AES+AESLEN-2,$+3	;Compare pointer with max. legal level.
     536/     154 : 50 09               	JNC	STK_ER
     537/     156 : 09                  	INC	R1
     538/     157 : EE                  	MOV	A,TOS_L		;Push low-order byte.
     539/     158 : F7                  	MOV	@R1,A
     540/     159 : 09                  	INC	R1
     541/     15A : EF                  	MOV	A,TOS_H		;Push high-order byte.
     542/     15B : F7                  	MOV	@R1,A
     543/     15C : 89 2A               	MOV	AESP,R1
     544/     15E : 22                  	RET
     545/     15F :                     ;
     546/     15F : 31 21               STK_ER:	CALL	AES_ER
     547/     161 : 0F                  	DB	0FH
     548/     162 :                     ;
     549/     162 :                     ;=======
     550/     162 :                     ;
     551/     162 :                     ;
     552/     162 :                     DUPL:
     553/     162 :                     ;	Verify that the AES is not full,
     554/     162 :                     ;	then duplicate the top element and update AESP.
     555/     162 :                     ;
     556/     162 : A9 2A               	MOV	R1,AESP
     557/     164 : B9 4D 00            	CJNE	R1,#AES+AESLEN-2,$+3	;Compare pointer with max. legal level.
     558/     167 : 50 F6               	JNC	STK_ER
     559/     169 : 19                  	DEC	R1
     560/     16A : E7                  	MOV	A,@R1
     561/     16B : 09                  	INC	R1
     562/     16C : 87 F0               	MOV	B,@R1
     563/     16E : 09                  	INC	R1
     564/     16F : F7                  	MOV	@R1,A			;Push low-order byte.
     565/     170 : 09                  	INC	R1
     566/     171 : A7 F0               	MOV	@R1,B
     567/     173 : 89 2A               	MOV	AESP,R1
     568/     175 : 22                  	RET
     569/     176 :                     ;
     570/     176 :                     ;=======
     571/     176 :                     ;
     572/     176 :                     ;LIT	(K)
     573/     176 :                     ;	Report error if arithmetic expression stack is full.
     574/     176 :                     ;	Otherwise push the one-byte constant K onto AES.
     575/     176 :                     ;	Return with carry=1, since LIT marks a successful match.
     576/     176 :                     ;
     577/     176 : D0 83               LIT:	POP	DPH		;Get parameter address.
     578/     178 : D0 82               	POP	DPL
     579/     17A : E4                  	CLR	A
     580/     17B : 93                  	MOVC	A,@A+DPTR	;Read literal value.
     581/     17C : 05 2A               	INC	AESP		;Reserve storage on top of AES.
     582/     17E : A9 2A               	MOV	R1,AESP		;Point to free entry on stack.
     583/     180 : B9 4F 02            	CJNE	R1,#AES+AESLEN,LIT_1
     584/     183 : 80 9C               	JMP	AES_ER
     585/     185 :                     ;
     586/     185 : F7                  LIT_1:	MOV	@R1,A		;Store literal.
     587/     186 : 74 01               	MOV	A,#1		;Branch over constant on return.
     588/     188 : D3                  	SETB	C
     589/     189 : 73                  	JMP	@A+DPTR		;Return to IL program.
     590/     18A :                     ;
     591/     18A :                     ;=======
     592/     18A :                     ;$EJECT
     593/     18A :                     ;
     594/     18A :                     ;	BASIC VARIABLE ACCESSING OPERATIONS  (8/20/80)
     595/     18A :                     ;	===== ======== ========= ==========
     596/     18A :                     ;
     597/     18A :                     ;
     598/     18A :                     ;	Direct address mode emulation tables:
     599/     18A :                     ;
     600/     18A : 80                  SFRTBL:	DB	80H
     601/     18B : 90                  	DB	90H
     602/     18C : A0                  	DB	0A0H
     603/     18D : B0                  	DB	0B0H
     604/     18E : 88                  	DB	88H
     605/     18F : 98                  	DB	98H
     606/     190 : A8                  	DB	0A8H
     607/     191 : B8                  	DB	0B8H
     608/     192 : 89                  	DB	89H
     609/     193 : 8A                  	DB	8AH
     610/     194 : 8B                  	DB	8BH
     611/     195 : 8C                  	DB	8CH
     612/     196 : 8D                  	DB	8DH
     613/     197 : 99                  	DB	99H
     614/     198 : =EH                 NO_SFR	EQU	$-SFRTBL
     615/     198 :                     ;
     616/     198 :                     ;===
     617/     198 :                     ;
     618/     198 : 8E 80               STRTBL:	MOV	80H,TOS_L
     619/     19A : 22                  	RET
     620/     19B : 8E 90               	MOV	90H,TOS_L
     621/     19D : 22                  	RET
     622/     19E : 8E A0               	MOV	0A0H,TOS_L
     623/     1A0 : 22                  	RET
     624/     1A1 : 8E B0               	MOV	0B0H,TOS_L
     625/     1A3 : 22                  	RET
     626/     1A4 : 8E 88               	MOV	88H,TOS_L
     627/     1A6 : 22                  	RET
     628/     1A7 : 8E 98               	MOV	98H,TOS_L
     629/     1A9 : 22                  	RET
     630/     1AA : 8E A8               	MOV	0A8H,TOS_L
     631/     1AC : 22                  	RET
     632/     1AD : 8E B8               	MOV	0B8H,TOS_L
     633/     1AF : 22                  	RET
     634/     1B0 : 8E 89               	MOV	89H,TOS_L
     635/     1B2 : 22                  	RET
     636/     1B3 : 8E 8A               	MOV	8AH,TOS_L
     637/     1B5 : 22                  	RET
     638/     1B6 : 8E 8B               	MOV	8BH,TOS_L
     639/     1B8 : 22                  	RET
     640/     1B9 : 8E 8C               	MOV	8CH,TOS_L
     641/     1BB : 22                  	RET
     642/     1BC : 8E 8D               	MOV	8DH,TOS_L
     643/     1BE : 22                  	RET
     644/     1BF : 8E 99               	MOV	99H,TOS_L
     645/     1C1 : 22                  	RET
     646/     1C2 :                     ;
     647/     1C2 :                     ;===
     648/     1C2 :                     ;
     649/     1C2 : E5 80               INDTBL:	MOV	A,80H
     650/     1C4 : 22                  	RET
     651/     1C5 : E5 90               	MOV	A,90H
     652/     1C7 : 22                  	RET
     653/     1C8 : E5 A0               	MOV	A,0A0H
     654/     1CA : 22                  	RET
     655/     1CB : E5 B0               	MOV	A,0B0H
     656/     1CD : 22                  	RET
     657/     1CE : E5 88               	MOV	A,88H
     658/     1D0 : 22                  	RET
     659/     1D1 : E5 98               	MOV	A,98H
     660/     1D3 : 22                  	RET
     661/     1D4 : E5 A8               	MOV	A,0A8H
     662/     1D6 : 22                  	RET
     663/     1D7 : E5 B8               	MOV	A,0B8H
     664/     1D9 : 22                  	RET
     665/     1DA : E5 89               	MOV	A,89H
     666/     1DC : 22                  	RET
     667/     1DD : E5 8A               	MOV	A,8AH
     668/     1DF : 22                  	RET
     669/     1E0 : E5 8B               	MOV	A,8BH
     670/     1E2 : 22                  	RET
     671/     1E3 : E5 8C               	MOV	A,8CH
     672/     1E5 : 22                  	RET
     673/     1E6 : E5 8D               	MOV	A,8DH
     674/     1E8 : 22                  	RET
     675/     1E9 : E5 99               	MOV	A,99H
     676/     1EB : 22                  	RET
     677/     1EC :                     ;
     678/     1EC :                     ;$EJECT
     679/     1EC :                     SFR_ID:
     680/     1EC :                     ;	Identify which SFR is indicated by the contents of R1.
     681/     1EC :                     ;	Return with acc holding (Index of said register)*3.
     682/     1EC :                     ;	Call error routine if register number not found.
     683/     1EC :                     ;
     684/     1EC : 90 01 8A            	MOV	DPTR,#SFRTBL
     685/     1EF : E4                  	CLR	A
     686/     1F0 : FD                  	MOV	LP_CNT,A
     687/     1F1 : ED                  SFID_1:	MOV	A,LP_CNT
     688/     1F2 : 93                  	MOVC	A,@A+DPTR
     689/     1F3 : 69                  	XRL	A,R1
     690/     1F4 : 70 04               	JNZ	SFID_2
     691/     1F6 : ED                  	MOV	A,LP_CNT
     692/     1F7 : 23                  	RL	A
     693/     1F8 : 2D                  	ADD	A,LP_CNT
     694/     1F9 : 22                  	RET
     695/     1FA :                     ;
     696/     1FA : 0D                  SFID_2:	INC	LP_CNT
     697/     1FB : ED                  	MOV	A,LP_CNT
     698/     1FC : B4 0E F2            	CJNE	A,#NO_SFR,SFID_1
     699/     1FF : 21 18               ADR_ER:	JMP	EXP_ER
     700/     201 :                     ;
     701/     201 :                     ;=======
     702/     201 :                     ;
     703/     201 :                     STRDIR:
     704/     201 :                     ;	Store data byte in ACC into direct on-chip RAM address held in R1.
     705/     201 :                     ;
     706/     201 : FE                  	MOV	TOS_L,A
     707/     202 : E9                  	MOV	A,R1
     708/     203 : 20 E7 03            	JB	ACC.7,STRSFR	;Direct addresses above 7FH are SFRs.
     709/     206 : EE                  	MOV	A,TOS_L
     710/     207 : F7                  	MOV	@R1,A		;Store low-order byte in RAM.
     711/     208 : 22                  	RET
     712/     209 :                     ;
     713/     209 : 31 EC               STRSFR:	CALL	SFR_ID
     714/     20B : 90 01 98            	MOV	DPTR,#STRTBL
     715/     20E : 73                  	JMP	@A+DPTR		;Jump into store sequence.
     716/     20F :                     ;
     717/     20F :                     ;=======
     718/     20F :                     ;
     719/     20F :                     FETDIR:
     720/     20F :                     ;	Fetch on-chip directly addressed byte indicated by R1 into Acc. 
     721/     20F :                     ;	and return.
     722/     20F :                     ;
     723/     20F : E9                  	MOV	A,R1
     724/     210 : 20 E7 02            	JB	ACC.7,FETSFR
     725/     213 : E7                  	MOV	A,@R1
     726/     214 : 22                  	RET
     727/     215 :                     ;
     728/     215 : 31 EC               FETSFR:	CALL	SFR_ID
     729/     217 : 90 01 C2            	MOV	DPTR,#INDTBL
     730/     21A : 73                  	JMP	@A+DPTR
     731/     21B :                     ;
     732/     21B :                     ;=======
     733/     21B :                     ;
     734/     21B :                     SPLIT_DBA:
     735/     21B :                     ;	Called with TOS_L containing a direct on-chip bit address.
     736/     21B :                     ;	Return the direct &byte& address of encompassing 
     737/     21B :                     ;	register in R1, and load B with a mask containing a single 1 
     738/     21B :                     ;	corresponding to the bit's position in a field of zeroes.
     739/     21B :                     ;
     740/     21B : EE                  	MOV	A,TOS_L
     741/     21C : 54 F8               	ANL	A,#11111000B
     742/     21E : 20 E7 04            	JB	ACC.7,SPLSFR
     743/     221 : 23                  	RL	A
     744/     222 : C4                  	SWAP	A
     745/     223 : 24 20               	ADD	A,#20H		;Address of bit-address space.
     746/     225 : F9                  SPLSFR:	MOV	R1,A
     747/     226 : EE                  	MOV	A,TOS_L
     748/     227 : 54 07               	ANL	A,#07H		;Mask off bit-displacement field.
     749/     229 : 24 03               	ADD	A,#MSKTBL-MSK_PC
     750/     22B : 83                  	MOVC	A,@A+PC		;Read mask byte.
     751/     22C :                     MSK_PC:
     752/     22C : F5 F0               	MOV	B,A
     753/     22E : 22                  	RET
     754/     22F :                     ;
     755/     22F : 01                  MSKTBL:	DB	00000001B
     756/     230 : 02                  	DB	00000010B
     757/     231 : 04                  	DB	00000100B
     758/     232 : 08                  	DB	00001000B
     759/     233 : 10                  	DB	00010000B
     760/     234 : 20                  	DB	00100000B
     761/     235 : 40                  	DB	01000000B
     762/     236 : 80                  	DB	10000000B
     763/     237 :                     ;
     764/     237 :                     ;=======
     765/     237 :                     ;
     766/     237 :                     ;
     767/     237 :                     SEQ_STORE:
     768/     237 :                     ;	Same as STORE, below, except that index is retained
     769/     237 :                     ;	rather than being popped.
     770/     237 : D2 4B               	SETB	SEQ_FLG
     771/     239 : 80 02               	SJMP	STOR_0
     772/     23B :                     ;
     773/     23B :                     ;
     774/     23B :                     STORE:
     775/     23B :                     ;	When STORE is called, AES contains
     776/     23B :                     ;	(TOS:)	2 byte VALUE to be stored,
     777/     23B :                     ;		2 byte INDEX of destination variable,
     778/     23B :                     ;		1 byte TYPE code for variable space.
     779/     23B :                     ;			(0=BASIC variable,
     780/     23B :                     ;			 1=DBYTE,
     781/     23B :                     ;			 2=RBIT,
     782/     23B :                     ;			 3=XBYTE,
     783/     23B :                     ;			 4=CBYTE.)
     784/     23B :                     ;	Store (VAR_1) into appropriate variable memory at location of (INDEX).
     785/     23B :                     ;
     786/     23B : C2 4B               	CLR	SEQ_FLG
     787/     23D : 31 37               STOR_0:	CALL	POP_TOS
     788/     23F : 8E 08               	MOV	TMP0,TOS_L
     789/     241 : 8F 09               	MOV	TMP1,TOS_H
     790/     243 : 31 37               	CALL	POP_TOS
     791/     245 : 31 49               	CALL	POP_ACC		;Load TYPE code.
     792/     247 : 30 4B 06            	JNB	SEQ_FLG,STOR_1	;Jump forward if simple store.
     793/     24A : 05 2A               	INC	AESP
     794/     24C : 05 2A               	INC	AESP
     795/     24E : 05 2A               	INC	AESP
     796/     250 : 90 02 55            STOR_1:	MOV	DPTR,#STRJTB
     797/     253 : 93                  	MOVC	A,@A+DPTR
     798/     254 : 73                  	JMP	@A+DPTR
     799/     255 :                     ;
     800/     255 : 05                  STRJTB:	DB	STRVAR-STRJTB
     801/     256 : 23                  	DB	STRDBY-STRJTB
     802/     257 : 29                  	DB	STRRBI-STRJTB
     803/     258 : 3E                  	DB	STRXBY-STRJTB
     804/     259 : 3E                  	DB	STRCBY-STRJTB
     805/     25A :                     ;
     806/     25A :                     ;=======
     807/     25A :                     ;
     808/     25A :                     ;	All of the following routines are called with 
     809/     25A :                     ;	TOS_L holding the low-order address of the destination,
     810/     25A :                     ;	TOS_H holding the high-order address (if necessary),
     811/     25A :                     ;	and <TMP1><TMP0> holding the 8- or 16-bit data to be stored.
     812/     25A :                     ;
     813/     25A : EE                  STRVAR:	MOV	A,TOS_L
     814/     25B : 23                  	RL	A		;Multiply by two for 2 byte variables.
     815/     25C : 20 40 0D            	JB	EXTVAR,STREXT	;Branch if vars in external RAM.
     816/     25F : 24 10               	ADD	A,#US_VAR	;Offset for variable array.
     817/     261 : F9                  	MOV	R1,A
     818/     262 : 24 D9               	ADD	A,#-(US_VAR+2*NO_VAR-1)	;Compare with maximum legal address.
     819/     264 : 40 99               	JC	ADR_ER
     820/     266 : A7 08               	MOV	@R1,TMP0
     821/     268 : 09                  	INC	R1
     822/     269 : A7 09               	MOV	@R1,TMP1
     823/     26B : 22                  	RET
     824/     26C :                     ;
     825/     26C : F9                  STREXT:	MOV	R1,A
     826/     26D : 75 A0 20            DD001:  MOV     P2,#(EXTRAM >> 8)
     827/     270 : E5 08                       MOV     A,TMP0
     828/     272 : F3                  	MOVX	@R1,A
     829/     273 : 09                  	INC	R1		;Bump pointers.
     830/     274 : E5 09               	MOV	A,TMP1		;Move high-order byte into variable array.
     831/     276 : F3                  	MOVX	@R1,A
     832/     277 : 22                  	RET
     833/     278 :                     ;
     834/     278 :                     ;===
     835/     278 :                     ;
     836/     278 : EE                  STRDBY:	MOV	A,TOS_L		;Load acc. with low-order dest. addr.
     837/     279 : F9                  	MOV	R1,A
     838/     27A : E5 08               	MOV	A,TMP0
     839/     27C : 80 83               	JMP	STRDIR
     840/     27E :                     ;
     841/     27E :                     ;===
     842/     27E :                     ;
     843/     27E : 51 1B               STRRBI:	CALL	SPLIT_DBA
     844/     280 : 51 0F               	CALL	FETDIR
     845/     282 : FE                  	MOV	TOS_L,A
     846/     283 : E5 08               	MOV	A,TMP0
     847/     285 : 20 E0 06            	JB	ACC.0,SETRBI
     848/     288 :                     ;
     849/     288 :                     ;	Clear RBIT.
     850/     288 :                     ;
     851/     288 : E5 F0               	MOV	A,B
     852/     28A : F4                  	CPL	A
     853/     28B : 5E                  	ANL	A,TOS_L
     854/     28C : 41 01               	JMP	STRDIR
     855/     28E :                     ;
     856/     28E : E5 F0               SETRBI:	MOV	A,B
     857/     290 : 4E                  	ORL	A,TOS_L
     858/     291 : 41 01               	JMP	STRDIR
     859/     293 :                     ;
     860/     293 :                     ;===
     861/     293 :                     ;
     862/     293 :                     STRXBY:
     863/     293 : 8F A0               STRCBY:	MOV	P2,TOS_H
     864/     295 : EE                  	MOV	A,TOS_L
     865/     296 : F9                  	MOV	R1,A
     866/     297 : E5 08               	MOV	A,TMP0
     867/     299 : F3                  	MOVX	@R1,A
     868/     29A : 22                  	RET
     869/     29B :                     ;
     870/     29B :                     ;===============
     871/     29B :                     ;
     872/     29B :                     ;
     873/     29B :                     SEQ_FETCH:
     874/     29B :                     ;	Same as FETCH, below, except that index is retained
     875/     29B :                     ;	rather than being popped.
     876/     29B : D2 4B               	SETB	SEQ_FLG
     877/     29D : 80 02               	SJMP	FET_0
     878/     29F :                     ;
     879/     29F :                     ;
     880/     29F :                     FETCH:
     881/     29F :                     ;	When FETCH is called, AES contains
     882/     29F :                     ;	(TOS:)	2 byte INDEX of source variable,
     883/     29F :                     ;		1 byte TYPE code for variable space.
     884/     29F :                     ;			(0=BASIC variable,
     885/     29F :                     ;			 1=DBYTE,
     886/     29F :                     ;			 2=RBIT,
     887/     29F :                     ;			 3=XBYTE,
     888/     29F :                     ;			 4=CBYTE.)
     889/     29F :                     ;	Read 8- or 16-bit variable from the appropriate variable 
     890/     29F :                     ;	memory at location of (INDEX) and return on AES.
     891/     29F :                     ;
     892/     29F : C2 4B               	CLR	SEQ_FLG
     893/     2A1 : 31 37               FET_0:	CALL	POP_TOS
     894/     2A3 : 31 49               	CALL	POP_ACC
     895/     2A5 : 30 4B 06            	JNB	SEQ_FLG,FET_1	;Jump forward if simple store.
     896/     2A8 : 05 2A               	INC	AESP
     897/     2AA : 05 2A               	INC	AESP
     898/     2AC : 05 2A               	INC	AESP
     899/     2AE : 90 02 B3            FET_1:	MOV	DPTR,#FETJTB
     900/     2B1 : 93                  	MOVC	A,@A+DPTR
     901/     2B2 : 73                  	JMP	@A+DPTR
     902/     2B3 :                     ;
     903/     2B3 : 05                  FETJTB:	DB	FETVAR-FETJTB
     904/     2B4 : 25                  	DB	FETDBY-FETJTB
     905/     2B5 : 2B                  	DB	FETRBI-FETJTB
     906/     2B6 : 37                  	DB	FETXBY-FETJTB
     907/     2B7 : 3E                  	DB	FETCBY-FETJTB
     908/     2B8 :                     ;
     909/     2B8 :                     ;=======
     910/     2B8 :                     ;
     911/     2B8 :                     ;	All of the following routines are called with 
     912/     2B8 :                     ;	TOS_L holding the low-order index of the desired variable,
     913/     2B8 :                     ;	and TOS_H holding the high-order index (if necessary).
     914/     2B8 :                     ;
     915/     2B8 : EE                  FETVAR:	MOV	A,TOS_L
     916/     2B9 : 23                  	RL	A		;Correct for double-byte entries.
     917/     2BA : 20 40 0E            	JB	EXTVAR,FETEXT
     918/     2BD : 24 10               	ADD	A,#US_VAR	;Offset for variable array.
     919/     2BF : F9                  	MOV	R1,A		;Index to variable storage array.
     920/     2C0 : 24 D9               	ADD	A,#-(US_VAR+2*NO_VAR-1)
     921/     2C2 : 40 12               	JC	FETERR
     922/     2C4 : E7                  	MOV	A,@R1		;Load low-order byte of variable.
     923/     2C5 : FE                  	MOV	TOS_L,A		;And store on AES.
     924/     2C6 : 09                  	INC	R1		;Bump pointer.
     925/     2C7 : E7                  	MOV	A,@R1		;Transfer high-order byte of variable.
     926/     2C8 : FF                  	MOV	TOS_H,A
     927/     2C9 : 21 4F               	JMP	PUSH_TOS
     928/     2CB :                     ;
     929/     2CB :                     ;===
     930/     2CB :                     ;
     931/     2CB : F9                  FETEXT:	MOV	R1,A		;Index to variable storage array.
     932/     2CC : 75 A0 20            DD002:  MOV     P2,#(EXTRAM >> 8)
     933/     2CF : E3                          MOVX    A,@R1           ;Load low-order byte of variable.
     934/     2D0 : FE                  	MOV	TOS_L,A		;And store on AES.
     935/     2D1 : 09                  	INC	R1		;Bump pointers.
     936/     2D2 : E3                  	MOVX	A,@R1		;Transfer high-order byte of variable.
     937/     2D3 : FF                  	MOV	TOS_H,A
     938/     2D4 : 21 4F               	JMP	PUSH_TOS
     939/     2D6 :                     ;
     940/     2D6 : 21 FF               FETERR:	JMP	ADR_ER
     941/     2D8 :                     ;
     942/     2D8 :                     ;===
     943/     2D8 :                     ;
     944/     2D8 : EE                  FETDBY:	MOV	A,TOS_L
     945/     2D9 : F9                  	MOV	R1,A
     946/     2DA : 51 0F               	CALL	FETDIR
     947/     2DC : 80 19               	SJMP	FETBDN		;Byte fetch done.
     948/     2DE :                     ;
     949/     2DE :                     ;===
     950/     2DE :                     ;
     951/     2DE : 51 1B               FETRBI:	CALL	SPLIT_DBA
     952/     2E0 : 51 0F               	CALL	FETDIR
     953/     2E2 : 55 F0               	ANL	A,B
     954/     2E4 : 24 FF               	ADD	A,#0FFH
     955/     2E6 : E4                  	CLR	A
     956/     2E7 : 33                  	RLC	A
     957/     2E8 : 80 0D               	SJMP	FETBDN
     958/     2EA :                     ;
     959/     2EA :                     ;===
     960/     2EA :                     ;
     961/     2EA : 8F A0               FETXBY:	MOV	P2,TOS_H
     962/     2EC : EE                  	MOV	A,TOS_L
     963/     2ED : F9                  	MOV	R1,A
     964/     2EE : E3                  	MOVX	A,@R1
     965/     2EF : 80 06               	SJMP	FETBDN
     966/     2F1 :                     ;
     967/     2F1 :                     ;===
     968/     2F1 :                     ;
     969/     2F1 : 8F 83               FETCBY:	MOV	DPH,TOS_H
     970/     2F3 : 8E 82               	MOV	DPL,TOS_L
     971/     2F5 : E4                  	CLR	A
     972/     2F6 : 93                  	MOVC	A,@A+DPTR
     973/     2F7 : 7F 00               FETBDN:	MOV	TOS_H,#00H	;FETCH sequence for Bytes Done.
     974/     2F9 : FE                  	MOV	TOS_L,A		;FETCH sequence for words done.
     975/     2FA : 21 4F               	JMP	PUSH_TOS
     976/     2FC :                     ;
     977/     2FC :                     ;=======
     978/     2FC :                     ;$EJECT
     979/     2FC :                     ;
     980/     2FC :                     ;CREATE
     981/     2FC :                     ;	Test the contents of Acc.
     982/     2FC :                     ;	If CHAR holds the ASCII code for a legitimate decimal digit,
     983/     2FC :                     ;	create a two-byte entry in <TOS_H><TOS_L> holding low-order ACC nibble
     984/     2FC :                     ;	and return with CY set.
     985/     2FC :                     ;	Otherwise, return with CY cleared.
     986/     2FC :                     ;
     987/     2FC : 24 D0               CREATE:	ADD	A,#-'0'		;Correct for ASCII digit offset.
     988/     2FE : B4 0A 00            	CJNE	A,#10,$+3	;Compare to maximum legal digit.
     989/     301 : 50 05               	JNC	CREA_1		;Abort if first char is not decimal digit.
     990/     303 : FE                  	MOV	TOS_L,A		;Save initial digit read.
     991/     304 : 7F 00               	MOV	TOS_H,#0	;Clear high-order bits.
     992/     306 : C2 4D               	CLR	H_FLG
     993/     308 : 22                  CREA_1:	RET
     994/     309 :                     ;
     995/     309 :                     ;===============
     996/     309 :                     ;
     997/     309 :                     ;APPEND
     998/     309 :                     ;	Test ASCII code in Acc.
     999/     309 :                     ;	If it is a legal digit in the current radix,
    1000/     309 :                     ;	modify <TOS_H><TOS_L> to include this digit and return with CY set.
    1001/     309 :                     ;	Otherwise leave AES and CHAR unchanged and return with CY cleared.
    1002/     309 :                     ;	Operating mode determined by HEXMOD flag (1=Hex).
    1003/     309 :                     ;
    1004/     309 : 20 4D 3E            APPEND:	JB	H_FLG,APND_2	;Nothing allowed after trailing 'H' received.
    1005/     30C : 24 D0               	ADD	A,#-'0'		;Correct for ASCII offset.
    1006/     30E : B4 0A 00            	CJNE	A,#10,$+3	;Verify whether legal digit.
    1007/     311 : 40 13               	JC	APND_1		;Insert decimal digit as is.
    1008/     313 : 30 44 34            	JNB	HEXMOD,APND_2	;If in decimal mode, character isn't legal.
    1009/     316 : 24 EF               	ADD	A,#'0'-'A'	;Acc now equals 0 if 'A' received.
    1010/     318 : B4 06 00            	CJNE	A,#6,$+3
    1011/     31B : 40 07               	JC	APND_4		;Process Hex digit.
    1012/     31D :                     ;
    1013/     31D :                     ;	Char was not hexidecimal digit, but if it was the first 'H', that's OK.
    1014/     31D :                     ;
    1015/     31D : B4 07 2A            	CJNE	A,#'H'-'A',APND_2	;Compare original input with 'H'.
    1016/     320 : D2 4D               	SETB	H_FLG		;Mark that 'H' was detected but don't process.
    1017/     322 : D3                  	SETB	C
    1018/     323 : 22                  	RET
    1019/     324 :                     ;
    1020/     324 : 24 0A               APND_4:	ADD	A,#10		;Value of lowest hex digit.
    1021/     326 : CE                  APND_1:	XCH	A,TOS_L		;Save nibble to be appended.
    1022/     327 : 75 F0 0A            	MOV	B,#10		;(Assuming radix=decimal.)
    1023/     32A : 30 44 03            	JNB	HEXMOD,XRAD_1	;Skip ahead if assumption correct.
    1024/     32D : 75 F0 10            	MOV	B,#16		;If mode is actually hex.
    1025/     330 : C0 F0               XRAD_1:	PUSH	B		;Save for re-use.
    1026/     332 : A4                  	MUL	AB		;Multiply by radix.
    1027/     333 : 2E                  	ADD	A,TOS_L		;Append new digit.
    1028/     334 : FE                  	MOV	TOS_L,A		;Save low-order shifted value.
    1029/     335 : E4                  	CLR	A
    1030/     336 : 35 F0               	ADDC	A,B		;Incremented high-order product if carry.
    1031/     338 : CF                  	XCH	A,TOS_H
    1032/     339 : D0 F0               	POP	B
    1033/     33B : A4                  	MUL	AB
    1034/     33C : 2F                  	ADD	A,TOS_H
    1035/     33D : FF                  	MOV	TOS_H,A
    1036/     33E : 72 E7               	ORL	C,ACC.7		;Detect if most significant bit set.
    1037/     340 : E5 F0               	MOV	A,B
    1038/     342 : 34 FF               	ADDC	A,#0FFH		;Simulate "ORL	C,NZ" instruction.
    1039/     344 : B0 44               	ANL	C,/HEXMOD	;Overflow only relevent in decimal mode.
    1040/     346 : 40 04               	JC	APN_ER		;Error if bit 7 overflow occurred.
    1041/     348 : D3                  	SETB	C		;CHAR processed as legal character.
    1042/     349 : 22                  	RET
    1043/     34A :                     ;
    1044/     34A : C3                  APND_2:	CLR	C
    1045/     34B : 22                  	RET
    1046/     34C :                     ;
    1047/     34C :                     ;
    1048/     34C : 31 18               APN_ER:	CALL	EXP_ER		;Indicate illegal entry.
    1049/     34E : 02                  	DB	2
    1050/     34F :                     ;
    1051/     34F :                     ;$EJECT
    1052/     34F :                     ;
    1053/     34F :                     OV_TST:
    1054/     34F :                     ;	If OV is set and operation is BCD mode then call EXP_ER routine.
    1055/     34F :                     ;
    1056/     34F : A2 D2               	MOV	C,OV
    1057/     351 : B0 44               	ANL	C,/HEXMOD
    1058/     353 : 40 01               	JC	EXP_OV
    1059/     355 : 22                  	RET
    1060/     356 :                     ;
    1061/     356 : 31 18               EXP_OV:	CALL	EXP_ER
    1062/     358 : 06                  	DB	6
    1063/     359 :                     ;
    1064/     359 :                     ;=======
    1065/     359 :                     ;
    1066/     359 : E7                  ADD_16:	MOV	A,@R1		;Add low-order bytes.
    1067/     35A : 2E                  	ADD	A,TOS_L
    1068/     35B : F7                  	MOV	@R1,A		;Save sum.
    1069/     35C : 09                  	INC	R1
    1070/     35D : E7                  	MOV	A,@R1		;Add high-order bytes.
    1071/     35E : 3F                  	ADDC	A,TOS_H
    1072/     35F : F7                  	MOV	@R1,A		;Save sum.
    1073/     360 : 22                  	RET
    1074/     361 :                     ;
    1075/     361 :                     ;=======
    1076/     361 :                     ;
    1077/     361 :                     ;
    1078/     361 :                     IADD:
    1079/     361 :                     ;	Pop VAR from AES (two bytes).
    1080/     361 :                     ;	TOS <= TOS + VAR
    1081/     361 :                     ;
    1082/     361 : 31 37               	CALL	POP_TOS
    1083/     363 : 71 59               	CALL	ADD_16
    1084/     365 : 80 E8               	JMP	OV_TST
    1085/     367 :                     ;
    1086/     367 :                     ;===============
    1087/     367 :                     ;
    1088/     367 :                     ;ISUB
    1089/     367 :                     ;	Pop VAR from AES (two bytes).
    1090/     367 :                     ;	TOS <= TOS - VAR
    1091/     367 :                     ;
    1092/     367 :                     ;
    1093/     367 : 31 37               ISUB:	ACALL	POP_TOS
    1094/     369 : C3                  	CLR	C		;Set up for subtraction with borrow.
    1095/     36A : E7                  	MOV	A,@R1		;Subtract low-order bytes.
    1096/     36B : 9E                  	SUBB	A,TOS_L
    1097/     36C : F7                  	MOV	@R1,A		;Save difference.
    1098/     36D : 09                  	INC	R1		;Bump pointers.
    1099/     36E : E7                  	MOV	A,@R1		;Subtract high-order bytes.
    1100/     36F : 9F                  	SUBB	A,TOS_H
    1101/     370 : F7                  	MOV	@R1,A		;Save difference.
    1102/     371 : 80 DC               	JMP	OV_TST
    1103/     373 :                     ;
    1104/     373 :                     ;=======
    1105/     373 :                     ;
    1106/     373 :                     ;
    1107/     373 :                     IAND:
    1108/     373 :                     ;	Pop VAR from AES (two bytes).
    1109/     373 :                     ;	TOS <= TOS AND VAR
    1110/     373 :                     ;
    1111/     373 : 31 37               	CALL	POP_TOS
    1112/     375 : E7                  	MOV	A,@R1		;AND low-order bytes.
    1113/     376 : 5E                  	ANL	A,TOS_L
    1114/     377 : F7                  	MOV	@R1,A		;Save result.
    1115/     378 : 09                  	INC	R1
    1116/     379 : E7                  	MOV	A,@R1		;AND high-order bytes.
    1117/     37A : 5F                  	ANL	A,TOS_H
    1118/     37B : F7                  	MOV	@R1,A		;Save result.
    1119/     37C : 22                  	RET
    1120/     37D :                     ;
    1121/     37D :                     ;=======
    1122/     37D :                     ;
    1123/     37D :                     ;
    1124/     37D :                     IOR:
    1125/     37D :                     ;	Pop VAR from AES (two bytes).
    1126/     37D :                     ;	TOS <= TOS OR VAR
    1127/     37D :                     ;
    1128/     37D : 31 37               	CALL	POP_TOS
    1129/     37F : E7                  	MOV	A,@R1		;OR low-order bytes.
    1130/     380 : 4E                  	ORL	A,TOS_L
    1131/     381 : F7                  	MOV	@R1,A		;Save result.
    1132/     382 : 09                  	INC	R1
    1133/     383 : E7                  	MOV	A,@R1		;OR high-order bytes.
    1134/     384 : 4F                  	ORL	A,TOS_H
    1135/     385 : F7                  	MOV	@R1,A		;Save result.
    1136/     386 : 22                  	RET
    1137/     387 :                     ;
    1138/     387 :                     ;=======
    1139/     387 :                     ;
    1140/     387 :                     ;
    1141/     387 :                     IXOR:
    1142/     387 :                     ;	Pop VAR from AES (two bytes).
    1143/     387 :                     ;	TOS <= TOS XOR VAR
    1144/     387 :                     ;
    1145/     387 : 31 37               	CALL	POP_TOS
    1146/     389 : E7                  	MOV	A,@R1		;XOR low-order bytes.
    1147/     38A : 6E                  	XRL	A,TOS_L
    1148/     38B : F7                  	MOV	@R1,A		;Save result.
    1149/     38C : 09                  	INC	R1
    1150/     38D : E7                  	MOV	A,@R1		;XOR high-order bytes.
    1151/     38E : 6F                  	XRL	A,TOS_H
    1152/     38F : F7                  	MOV	@R1,A		;Save result.
    1153/     390 : 22                  	RET
    1154/     391 :                     ;
    1155/     391 :                     ;===============
    1156/     391 :                     ;
    1157/     391 :                     ;
    1158/     391 :                     NEG:
    1159/     391 :                     ;	TOS <= -TOS
    1160/     391 :                     ;
    1161/     391 : C3                  	CLR	C
    1162/     392 : B2 4A               	CPL	SGN_FLG
    1163/     394 : A9 2A               NEG_0:	MOV	R1,AESP		;Compute variable address.
    1164/     396 : 19                  	DEC	R1		;Index for low-order byte of VAR_1.
    1165/     397 : E4                  	CLR	A		;Subtract VAR_1 from 0000H.
    1166/     398 : 97                  	SUBB	A,@R1
    1167/     399 : F7                  	MOV	@R1,A		;Save difference.
    1168/     39A : 09                  	INC	R1		;Bump pointer.
    1169/     39B : E4                  	CLR	A
    1170/     39C : 97                  	SUBB	A,@R1		;Subtract high-order byte.
    1171/     39D : F7                  	MOV	@R1,A		;Save difference.
    1172/     39E : 80 AF               	JMP	OV_TST
    1173/     3A0 :                     ;
    1174/     3A0 :                     ;=======
    1175/     3A0 :                     ;
    1176/     3A0 :                     ;
    1177/     3A0 :                     ICPL:
    1178/     3A0 :                     ;	TOS <= /TOS  (ones complement)
    1179/     3A0 : D3                  	SETB	C
    1180/     3A1 : 80 F1               	SJMP	NEG_0
    1181/     3A3 :                     ;
    1182/     3A3 :                     ;===============
    1183/     3A3 :                     ;
    1184/     3A3 :                     ;
    1185/     3A3 :                     IABS:
    1186/     3A3 :                     ;	If in decimal mode and TOS < 0 
    1187/     3A3 :                     ;	then complement SGN_FLG and negate TOS.
    1188/     3A3 :                     ;
    1189/     3A3 : A9 2A               	MOV	R1,AESP
    1190/     3A5 : E7                  	MOV	A,@R1
    1191/     3A6 : A2 E7               	MOV	C,ACC.7
    1192/     3A8 : B0 44               	ANL	C,/HEXMOD
    1193/     3AA : 40 E5               	JC	NEG
    1194/     3AC : 22                  	RET
    1195/     3AD :                     ;
    1196/     3AD :                     ;=======
    1197/     3AD :                     ;
    1198/     3AD :                     NEG_IF_NEG:
    1199/     3AD :                     ;	If SGN_FLG is set then negate TOS and complement SGN_FLG,
    1200/     3AD :                     ;	else return with TOS unchanged.
    1201/     3AD : 20 4A E1            	JB	SGN_FLG,NEG
    1202/     3B0 : 22                  	RET
    1203/     3B1 :                     ;
    1204/     3B1 :                     ;=======
    1205/     3B1 :                     ;
    1206/     3B1 :                     ;
    1207/     3B1 :                     IINC:
    1208/     3B1 :                     ;	TOS <= TOS+1
    1209/     3B1 :                     ;
    1210/     3B1 : A9 2A               	MOV	R1,AESP		;Compute variable address.
    1211/     3B3 : 19                  	DEC	R1		;Index for low-order byte of VAR_1.
    1212/     3B4 : 07                  	INC	@R1
    1213/     3B5 : B7 00 02            	CJNE	@R1,#00,IINC_1
    1214/     3B8 : 09                  	INC	R1		;Bump pointer.
    1215/     3B9 : 07                  	INC	@R1
    1216/     3BA : 22                  IINC_1:	RET
    1217/     3BB :                     ;
    1218/     3BB :                     ;=======
    1219/     3BB :                     ;
    1220/     3BB :                     MUL_16:
    1221/     3BB :                     ;	Multiply unsigned 16-bit quantity in <TOS_H><TOS_L> by entry
    1222/     3BB :                     ;	on top of stack, and return with product on stack.
    1223/     3BB :                     ;	If product exceeds 16-bits, set OV flag.
    1224/     3BB :                     ;
    1225/     3BB : C2 D5               	CLR	F0		;Initialize overflow flag.
    1226/     3BD : A9 2A               	MOV	R1,AESP		;Point to MSB of NOS.
    1227/     3BF : E7                  	MOV	A,@R1
    1228/     3C0 : 60 05               	JZ	IMUL_1		;High-order byte of either param. must be 0.
    1229/     3C2 : EF                  	MOV	A,TOS_H
    1230/     3C3 : 60 02               	JZ	IMUL_1
    1231/     3C5 : D2 D5               	SETB	F0		;Mark that both parameters exceed 255.
    1232/     3C7 : 19                  IMUL_1:	DEC	R1		;Index low-order NOS.
    1233/     3C8 : E7                  	MOV	A,@R1
    1234/     3C9 : 8F F0               	MOV	B,TOS_H
    1235/     3CB : A4                  	MUL	AB		;Low-order product.
    1236/     3CC : 30 D2 02            	JNB	OV,IMUL_2
    1237/     3CF : D2 D5               	SETB	F0
    1238/     3D1 : 09                  IMUL_2:	INC	R1
    1239/     3D2 : C7                  	XCH	A,@R1		;Save low-order prod. and load high-order NOS.
    1240/     3D3 : 8E F0               	MOV	B,TOS_L
    1241/     3D5 : A4                  	MUL	AB
    1242/     3D6 : 30 D2 02            	JNB	OV,IMUL_3	;Mark if overflow.
    1243/     3D9 : D2 D5               	SETB	F0
    1244/     3DB : 27                  IMUL_3:	ADD	A,@R1
    1245/     3DC : F7                  	MOV	@R1,A		;Save high-order sum.
    1246/     3DD : 72 D5               	ORL	C,F0
    1247/     3DF : 92 D5               	MOV	F0,C
    1248/     3E1 : 19                  	DEC	R1		;Address low-order NOS.
    1249/     3E2 : E7                  	MOV	A,@R1
    1250/     3E3 : 8E F0               	MOV	B,TOS_L
    1251/     3E5 : A4                  	MUL	AB
    1252/     3E6 : F7                  	MOV	@R1,A
    1253/     3E7 : E5 F0               	MOV	A,B
    1254/     3E9 : 09                  	INC	R1
    1255/     3EA : 27                  	ADD	A,@R1
    1256/     3EB : F7                  	MOV	@R1,A		;Save high-order product.
    1257/     3EC : 72 D5               	ORL	C,F0		;Check if carry or sign-bit set.
    1258/     3EE : 72 E7               	ORL	C,ACC.7		;Check if sign-bit set.
    1259/     3F0 : 92 D2               	MOV	OV,C
    1260/     3F2 : 22                  	RET
    1261/     3F3 :                     ;
    1262/     3F3 :                     ;=======
    1263/     3F3 :                     ;
    1264/     3F3 :                     ;
    1265/     3F3 :                     IMUL:
    1266/     3F3 :                     ;	Pop VAR from AES (two bytes).
    1267/     3F3 :                     ;	TOS <= TOS * VAR
    1268/     3F3 :                     ;
    1269/     3F3 : C2 4A               	CLR	SGN_FLG		;Initialize sign monitor flag.
    1270/     3F5 : 71 A3               	CALL	IABS		;Take absolute value of TOS.
    1271/     3F7 : 31 37               	CALL	POP_TOS		;Pop top entry.
    1272/     3F9 : 71 A3               	CALL	IABS		;Take absolute value of NOS.
    1273/     3FB : 71 BB               	CALL	MUL_16
    1274/     3FD : 71 4F               	CALL	OV_TST		;Check if OV relevent.
    1275/     3FF : 71 AD               	CALL	NEG_IF_NEG
    1276/     401 : 22                  	RET
    1277/     402 :                     ;
    1278/     402 :                     ;===============
    1279/     402 :                     ;
    1280/     402 :                     ;
    1281/     402 : D2 4C               IMOD:	SETB	MOD_FLG		;Indicate modulo entry point.
    1282/     404 : 80 02               	SJMP	IDIV_0
    1283/     406 :                     ;
    1284/     406 :                     ;=======
    1285/     406 :                     ;
    1286/     406 :                     ;
    1287/     406 :                     IDIV:
    1288/     406 :                     ;	Pop VAR from AES (two bytes).
    1289/     406 :                     ;	TOS <= TOS / VAR
    1290/     406 :                     ;	If divide-by-zero attempted report error.
    1291/     406 :                     ;
    1292/     406 : C2 4C               	CLR	MOD_FLG		;Indicate division entry point.
    1293/     408 : D2 4A               IDIV_0:	SETB	SGN_FLG		;Initialize sign monitor flag.
    1294/     40A : 71 A3               	CALL	IABS
    1295/     40C : 71 91               	CALL	NEG
    1296/     40E : 31 37               	CALL	POP_TOS
    1297/     410 :                     ;???
    1298/     410 :                     ; The next line of code added by lss 21-dec-1982
    1299/     410 :                     ;???
    1300/     410 : EE                  	mov	a,tos_l
    1301/     411 : 4F                  	ORL	A,TOS_H
    1302/     412 : 60 4D               	JZ	DIV_NG
    1303/     414 : A2 4A               	MOV	C,SGN_FLG
    1304/     416 : B0 4C               	ANL	C,/MOD_FLG	;Clear SGN_FLG if MOD funtion being done.
    1305/     418 : 92 4A               	MOV	SGN_FLG,C
    1306/     41A : 71 A3               	CALL	IABS
    1307/     41C : F5 09               	MOV	TMP1,A
    1308/     41E : 19                  	DEC	R1
    1309/     41F : E7                  	MOV	A,@R1
    1310/     420 : F5 08               	MOV	TMP0,A
    1311/     422 : E4                  	CLR	A
    1312/     423 : F5 0B               	MOV	TMP3,A
    1313/     425 : F5 0A               	MOV	TMP2,A
    1314/     427 : 7D 11               	MOV	LP_CNT,#17
    1315/     429 : C3                  	CLR	C
    1316/     42A : 80 17               	SJMP	DIV_RP
    1317/     42C :                     ;
    1318/     42C : E5 0A               DIV_LP:	MOV	A,TMP2
    1319/     42E : 33                  	RLC	A
    1320/     42F : F5 0A               	MOV	TMP2,A
    1321/     431 : C5 0B               	XCH	A,TMP3
    1322/     433 : 33                  	RLC	A
    1323/     434 : C5 0B               	XCH	A,TMP3
    1324/     436 : 2E                  	ADD	A,TOS_L
    1325/     437 : F5 0C               	MOV	TMP4,A
    1326/     439 : E5 0B               	MOV	A,TMP3
    1327/     43B : 3F                  	ADDC	A,TOS_H
    1328/     43C : 50 05               	JNC	DIV_RP
    1329/     43E : 85 0C 0A            	MOV	TMP2,TMP4
    1330/     441 : F5 0B               	MOV	TMP3,A
    1331/     443 : E5 08               DIV_RP:	MOV	A,TMP0
    1332/     445 : 33                  	RLC	A
    1333/     446 : F5 08               	MOV	TMP0,A
    1334/     448 : E5 09               	MOV	A,TMP1
    1335/     44A : 33                  	RLC	A
    1336/     44B : F5 09               	MOV	TMP1,A
    1337/     44D : DD DD               	DJNZ	LP_CNT,DIV_LP
    1338/     44F : 20 4C 07            	JB	MOD_FLG,DIV_1
    1339/     452 : A7 08               	MOV	@R1,TMP0
    1340/     454 : 09                  	INC	R1
    1341/     455 : A7 09               	MOV	@R1,TMP1
    1342/     457 : 80 05               	SJMP	DIV_2
    1343/     459 :                     ;
    1344/     459 : A7 0A               DIV_1:	MOV	@R1,TMP2
    1345/     45B : 09                  	INC	R1
    1346/     45C : A7 0B               	MOV	@R1,TMP3
    1347/     45E : 71 AD               DIV_2:	CALL	NEG_IF_NEG
    1348/     460 : 22                  	RET
    1349/     461 :                     ;
    1350/     461 : 61 56               DIV_NG:	AJMP	EXP_OV		;Report expression overflow.
    1351/     463 :                     ;
    1352/     463 :                     ;===============
    1353/     463 :                     ;
    1354/     463 :                     ;$EJECT
    1355/     463 :                     ;
    1356/     463 :                     ;
    1357/     463 :                     RND:
    1358/     463 :                     ;	Generate a new 16-bit random number from RND_KEY,
    1359/     463 :                     ;	and push onto the AES.
    1360/     463 : AE 0D               	MOV	TOS_L,SEED_L
    1361/     465 : AF 0E               	MOV	TOS_H,SEED_H
    1362/     467 : 31 4F               	CALL	PUSH_TOS
    1363/     469 : 7E 55                       MOV     TOS_L,#(25173 & 0ffh)
    1364/     46B : 7F 62                       MOV     TOS_H,#(25173 >> 8)
    1365/     46D : 71 BB               	CALL	MUL_16
    1366/     46F : 7E 19                       MOV     TOS_L,#(13849 & 0ffh)
    1367/     471 : 7F 36                       MOV     TOS_H,#(13849 >> 8)
    1368/     473 : A9 2A               	MOV	R1,AESP
    1369/     475 : 19                  	DEC	R1
    1370/     476 : 71 59               	CALL	ADD_16
    1371/     478 : 31 37               	CALL	POP_TOS
    1372/     47A :                     ;
    1373/     47A :                     ;???
    1374/     47A :                     ; The code from here to label no_problem added by lss 21 dec 1982
    1375/     47A :                     ; to cure a extraneous overflow if seed=8000h.
    1376/     47A :                     ;???
    1377/     47A :                     ;
    1378/     47A : BE 00 07            	cjne	tos_l,#0,no_problem
    1379/     47D : BF 80 04            	cjne	tos_h,#80h,no_problem
    1380/     480 :                     big_problem:				   ; tos=8000h will generate an overflow
    1381/     480 : 7E 2A               	mov	tos_l,#(12586 & 0ffh)      ; when control gets to iabs.
    1382/     482 : 7F 31               	mov	tos_h,#(12586 >> 8)        ; Load the precalculated seed.
    1383/     484 :                     no_problem:
    1384/     484 : 8E 0D               	MOV	SEED_L,TOS_L
    1385/     486 : 8F 0E               	MOV	SEED_H,TOS_H
    1386/     488 : 31 4F               	CALL	PUSH_TOS
    1387/     48A : 22                  	RET
    1388/     48B :                     ;
    1389/     48B :                     ;===============
    1390/     48B :                     ;
    1391/     48B :                     ;
    1392/     48B :                     CMPR:
    1393/     48B :                     ;	When CMPR is called, AES contains:
    1394/     48B :                     ;	(TOS:)	VAR_2 (two bytes),
    1395/     48B :                     ;		C_CODE (one byte),
    1396/     48B :                     ;		VAR_1 (two bytes).
    1397/     48B :                     ;	Pop all 5 bytes from stack and test relation between VAR_1 and VAR_2.
    1398/     48B :                     ;	    If C_CODE=010 then test whether (VAR_1) =  (VAR_2)
    1399/     48B :                     ;	    If C_CODE=100 then test whether (VAR_1) <  (VAR_2)
    1400/     48B :                     ;	    If C_CODE=110 then test whether (VAR_1) <= (VAR_2)
    1401/     48B :                     ;	    If C_CODE=101 then test whether (VAR_1) <> (VAR_2)
    1402/     48B :                     ;	    If C_CODE=001 then test whether (VAR_1) >  (VAR_2)
    1403/     48B :                     ;	    If C_CODE=011 then test whether (VAR_1) >= (VAR_2)
    1404/     48B :                     ;	If true then return 0001H on AES;
    1405/     48B :                     ;	otherwise return 0000H.
    1406/     48B :                     ;
    1407/     48B : 31 37               	CALL	POP_TOS
    1408/     48D : 31 49               	CALL	POP_ACC
    1409/     48F : F5 F0               	MOV	B,A
    1410/     491 : A9 2A               	MOV	R1,AESP
    1411/     493 : 19                  	DEC	R1
    1412/     494 : C3                  	CLR	C		;...in preparation for string subtract.
    1413/     495 : E7                  	MOV	A,@R1		;Compare low-order parameter bytes.
    1414/     496 : 9E                  	SUBB	A,TOS_L
    1415/     497 : 09                  	INC	R1		;Bump pointer.
    1416/     498 : C7                  	XCH	A,@R1		;Save difference.
    1417/     499 : 20 44 06            	JB	HEXMOD,CMPR_4
    1418/     49C : 64 80               	XRL	A,#80H		;Offset variable by 80H for unsigned compare.
    1419/     49E : CF                  	XCH	A,TOS_H
    1420/     49F : 64 80               	XRL	A,#80H
    1421/     4A1 : CF                  	XCH	A,TOS_H
    1422/     4A2 : 9F                  CMPR_4:	SUBB	A,TOS_H
    1423/     4A3 : 47                  	ORL	A,@R1		;Add any non-zero high-order bits to acc.
    1424/     4A4 : 70 04               	JNZ	CMPR_1		;Jump ahead VAR_1 <> VAR_2.
    1425/     4A6 :                     ;
    1426/     4A6 :                     ;	VAR_1 = VAR_2:
    1427/     4A6 :                     ;
    1428/     4A6 : A2 F1               	MOV	C,B.1		;Load VAR_1 = VAR_2 test flag.
    1429/     4A8 : 80 08               	SJMP	PUSH_C
    1430/     4AA :                     ;
    1431/     4AA : 40 04               CMPR_1:	JC	CMPR_2		;Jump ahead if VAR_1 < VAR_2.
    1432/     4AC :                     ;
    1433/     4AC :                     ;	VAR_1 > VAR_2:
    1434/     4AC :                     ;
    1435/     4AC : A2 F0               	MOV	C,B.0		;Load VAR_1 > VAR_2 test flag.
    1436/     4AE : 80 02               	SJMP	PUSH_C
    1437/     4B0 :                     ;
    1438/     4B0 :                     ;	VAR_1 < VAR_2:
    1439/     4B0 :                     ;
    1440/     4B0 : A2 F2               CMPR_2:	MOV	C,B.2		;Load VAR_1 < VAR_2 test flag.
    1441/     4B2 : E4                  PUSH_C:	CLR	A
    1442/     4B3 : F7                  	MOV	@R1,A
    1443/     4B4 : 33                  	RLC	A
    1444/     4B5 : 19                  	DEC	R1
    1445/     4B6 : F7                  	MOV	@R1,A
    1446/     4B7 : 22                  	RET
    1447/     4B8 :                     ;
    1448/     4B8 :                     ;$EJECT
    1449/     4B8 :                     
    1450/     4B8 :                     ;	BASIC SOURCE PROGRAM LINE ACCESSING ROUTINES:
    1451/     4B8 :                     ;	===== ====== ======= ==== ======= ==========
    1452/     4B8 :                     ;
    1453/     4B8 :                     ;	The general methodology of the various parsing routines is as follows:
    1454/     4B8 :                     ;	The POINTER (PNTR_L, PNTR_H) is used to indicate the next BASIC
    1455/     4B8 :                     ;	source character or string to be parsed
    1456/     4B8 :                     ;	by routines TST, TSTV, TSTN, TSTL, and TSTS.
    1457/     4B8 :                     ;	GET_C reads the indicated character from the appropriate
    1458/     4B8 :                     ;	program buffer space into acc. and returns.
    1459/     4B8 :                     ;	READ_CHAR reads the character into CHAR as well as acc. and 
    1460/     4B8 :                     ;	increments the 16-bit pointer.
    1461/     4B8 :                     ;	When done, each routine calls D_BLANK to remove any trailing spaces,
    1462/     4B8 :                     ;	and leaves READ_CHAR ready to fetch the next non-blank character.
    1463/     4B8 :                     ;
    1464/     4B8 :                     ;=======
    1465/     4B8 :                     ;
    1466/     4B8 :                     ;REWIND
    1467/     4B8 :                     ;	Reset Cursor to start of current program buffer space.
    1468/     4B8 :                     ;
    1469/     4B8 : C2 49               REWIND:	CLR	CHAR_FLG
    1470/     4BA : 20 41 05            	JB	ROMMOD,REWROM
    1471/     4BD : 7A 20                       MOV     PNTR_H,#(EXTRAM >> 8)
    1472/     4BF : 78 34                       MOV     PNTR_L,#(EXTRAM & 0ffh)
    1473/     4C1 : 22                  	RET
    1474/     4C2 :                     ;
    1475/     4C2 : 20 42 05            REWROM:	JB	EXTMOD,RWXROM
    1476/     4C5 : 7A 0C                       MOV     PNTR_H,#(INTROM >> 8)
    1477/     4C7 : 78 17                       MOV     PNTR_L,#(INTROM & 0ffh)
    1478/     4C9 : 22                  	RET
    1479/     4CA :                     ;
    1480/     4CA : 7A 10               RWXROM: MOV     PNTR_H,#(EXTROM >> 8)
    1481/     4CC : 78 80                       MOV     PNTR_L,#(EXTROM & 0ffh)
    1482/     4CE : 22                  	RET
    1483/     4CF :                     ;
    1484/     4CF :                     ;=======
    1485/     4CF :                     ;
    1486/     4CF :                     SAVE_PNTR:
    1487/     4CF :                     ;	Save PNTR variables in cursor.
    1488/     4CF :                     ;
    1489/     4CF : 88 51               	MOV	CURS_L,PNTR_L
    1490/     4D1 : 8A 52               	MOV	CURS_H,PNTR_H
    1491/     4D3 : 8C 53               	MOV	C_SAVE,CHAR
    1492/     4D5 : 22                  	RET
    1493/     4D6 :                     ;
    1494/     4D6 :                     ;=======
    1495/     4D6 :                     ;
    1496/     4D6 :                     LOAD_PNTR:
    1497/     4D6 :                     ;	Reload pointer with value saved earlier by SAVE_PNTR.
    1498/     4D6 :                     ;
    1499/     4D6 : AA 52               	MOV	PNTR_H,CURS_H
    1500/     4D8 : A8 51               	MOV	PNTR_L,CURS_L
    1501/     4DA : AC 53               	MOV	CHAR,C_SAVE
    1502/     4DC : 22                  	RET
    1503/     4DD :                     ;
    1504/     4DD :                     ;=======
    1505/     4DD :                     ;
    1506/     4DD :                     GET_C:
    1507/     4DD :                     ;	Read character from logical buffer space into A and return.
    1508/     4DD :                     ;
    1509/     4DD : 20 43 02            	JB	RUNMOD,GET_BUF
    1510/     4E0 : E6                  	MOV	A,@PNTR_L
    1511/     4E1 : 22                  	RET
    1512/     4E2 :                     ;
    1513/     4E2 :                     GET_BUF:
    1514/     4E2 :                     ;	Read character from active program buffer space into A and return.
    1515/     4E2 : 20 41 04            	JB	ROMMOD,GETROM
    1516/     4E5 : 8A A0               DD003:  MOV     P2,PNTR_H               ;Select variable storage page.
    1517/     4E7 : E2                          MOVX    A,@PNTR_L               ;Read from external address space.
    1518/     4E8 : 22                  	RET
    1519/     4E9 :                     ;
    1520/     4E9 : E8                  GETROM:	MOV	A,PNTR_L
    1521/     4EA : C5 82               	XCH	A,DPL
    1522/     4EC : CA                  	XCH	A,PNTR_H
    1523/     4ED : C5 83               	XCH	A,DPH
    1524/     4EF : F8                  	MOV	PNTR_L,A
    1525/     4F0 : E4                  	CLR	A
    1526/     4F1 : 93                  	MOVC	A,@A+DPTR
    1527/     4F2 : C8                  	XCH	A,PNTR_L		;Save char. and load old DPH.
    1528/     4F3 : C5 83               	XCH	A,DPH
    1529/     4F5 : CA                  	XCH	A,PNTR_H
    1530/     4F6 : C5 82               	XCH	A,DPL
    1531/     4F8 : C8                  	XCH	A,PNTR_L		;Store DPL and reload byte read.
    1532/     4F9 : 22                  	RET
    1533/     4FA :                     ;
    1534/     4FA :                     ;=======
    1535/     4FA :                     ;
    1536/     4FA :                     READ_CHAR:
    1537/     4FA :                     ;	READ_CHAR first tests the state of CHAR_FLG.
    1538/     4FA :                     ;	If it is still cleared, the character most recently read from the line
    1539/     4FA :                     ;	buffer or program buffer has been processed, so read the next
    1540/     4FA :                     ;	character, bump the buffer pointer, and return with the character
    1541/     4FA :                     ;	in both Acc. and CHAR and the CHAR_FLG cleared.
    1542/     4FA :                     ;	If CHAR_FLG has been set by the parsing routines,
    1543/     4FA :                     ;	then CHAR still holds a previously read character which has
    1544/     4FA :                     ;	not yet been processed.  Read this character into Acc. and return
    1545/     4FA :                     ;	with CHAR_FLG again cleared.
    1546/     4FA :                     ;
    1547/     4FA : 10 49 09            	JBC	CHAR_FLG,REREAD
    1548/     4FD : 91 DD               	CALL	GET_C
    1549/     4FF : FC                  	MOV	CHAR,A
    1550/     500 : 08                  	INC	PNTR_L
    1551/     501 : B8 00 01            	CJNE	PNTR_L,#00,RDCHDN
    1552/     504 : 0A                  	INC	PNTR_H
    1553/     505 : 22                  RDCHDN:	RET
    1554/     506 :                     ;
    1555/     506 : EC                  REREAD:	MOV	A,CHAR
    1556/     507 : 22                  	RET
    1557/     508 :                     ;
    1558/     508 :                     ;=======
    1559/     508 :                     ;
    1560/     508 :                     PUT_BUF:
    1561/     508 :                     ;	Put the contents of the acc. into program buffer space
    1562/     508 :                     ;	currently active at the address held in <DEST_H><DEST_L>.
    1563/     508 :                     ;
    1564/     508 : 20 41 04            	JB	ROMMOD,PUTROM
    1565/     50B : 8B A0               DD004:  MOV     P2,DEST_H
    1566/     50D : F3                          MOVX    @DEST_L,A
    1567/     50E : 22                  	RET
    1568/     50F :                     ;
    1569/     50F : 21 18               PUTROM:	JMP	EXP_ER
    1570/     511 :                     ;
    1571/     511 :                     ;=======
    1572/     511 :                     ;
    1573/     511 :                     WRITE_CHAR:
    1574/     511 :                     ;	Converse of READ_CHAR.
    1575/     511 :                     ;	Write contents of acc. into appropriate memory space (@DEST),
    1576/     511 :                     ;	increment DEST, and return.
    1577/     511 :                     ;
    1578/     511 : B1 08               	CALL	PUT_BUF
    1579/     513 : 09                  	INC	DEST_L
    1580/     514 : B9 00 01            	CJNE	DEST_L,#00H,WRCH_1
    1581/     517 : 0B                  	INC	DEST_H
    1582/     518 : 22                  WRCH_1:	RET
    1583/     519 :                     ;
    1584/     519 :                     ;=======
    1585/     519 :                     ;
    1586/     519 :                     D_BLNK:
    1587/     519 :                     ;	Remove leading blanks from BASIC source line, update cursor,
    1588/     519 :                     ;	load first non-blank character into CHAR,
    1589/     519 :                     ;	and leave pointer loaded with its address.
    1590/     519 :                     ;	(This routine is jumped to by parsing routines when successful,
    1591/     519 :                     ;	so set C before returning to original routines.)
    1592/     519 :                     ;
    1593/     519 : 91 FA               	CALL	READ_CHAR
    1594/     51B : 64 20               	XRL	A,#' '		;Verify that it is non-blank.
    1595/     51D : 60 FA               	JZ	D_BLNK		;Loop until non-blank leading character.
    1596/     51F : D2 49               	SETB	CHAR_FLG
    1597/     521 : D3                  	SETB	C
    1598/     522 : 22                  	RET			;Return to scanning code.
    1599/     523 :                     ;
    1600/     523 :                     ;=======
    1601/     523 :                     ;
    1602/     523 :                     ;SKPLIN
    1603/     523 :                     ;	Skip Cursor over entire BASIC source line, leaving
    1604/     523 :                     ;	cursor pointing to character after terminating <CR>.
    1605/     523 :                     ;SKPTXT
    1606/     523 :                     ;	Skip remainder of line in progress, assuming line number 
    1607/     523 :                     ;	has already been passed over.
    1608/     523 :                     ;	(Note that either byte of binary line number could be
    1609/     523 :                     ;	mis-interpreted as a CR.)
    1610/     523 :                     ;
    1611/     523 :                     ;
    1612/     523 : 91 FA               SKPLIN:	CALL	READ_CHAR
    1613/     525 : 91 FA               	CALL	READ_CHAR
    1614/     527 : 91 FA               SKPTXT:	CALL	READ_CHAR
    1615/     529 : B4 0D FB            	CJNE	A,#CR,SKPTXT	;Verify that it is non-<CR>.
    1616/     52C : 22                  	RET			;Return to scanning code.
    1617/     52D :                     ;
    1618/     52D :                     ;=======
    1619/     52D :                     ;$EJECT
    1620/     52D :                     ;
    1621/     52D :                     ;	Token recognition and processing routines.
    1622/     52D :                     ;
    1623/     52D :                     ;
    1624/     52D :                     TST:
    1625/     52D :                     ;	If "TEMPLATE" matches the BASIC character string read by 
    1626/     52D :                     ;	READ_CHAR then move pointer over string and any trailing blanks
    1627/     52D :                     ;	and continue with the following IL instruction.
    1628/     52D :                     ;	Otherwise leave pointer unchanged and branch to IL instruction at LBL.
    1629/     52D :                     ;
    1630/     52D : D0 83               	POP	DPH		;Get in-line parameter base address from stack.
    1631/     52F : D0 82               	POP	DPL
    1632/     531 : 91 FA               	CALL	READ_CHAR
    1633/     533 : 91 CF               	CALL	SAVE_PNTR
    1634/     535 : E4                  TST_1:	CLR	A
    1635/     536 : 93                  	MOVC	A,@A+DPTR	;Read next character from template string.
    1636/     537 : A2 E7               	MOV	C,ACC.7		;Save terminator bit.
    1637/     539 : 54 7F               	ANL	A,#7FH		;Mask off terminator.
    1638/     53B : 6C                  	XRL	A,CHAR		;Compare with template.
    1639/     53C : 70 12               	JNZ	T_BAD		;Abort if first characters miscompare.
    1640/     53E : A3                  	INC	DPTR		;Pass over template character just checked.
    1641/     53F : 40 0B               	JC	T_GOOD		;Done if template character bit 7 set.
    1642/     541 : 91 FA               	CALL	READ_CHAR	;Fetch next character for test.
    1643/     543 : BC 2E EF            	CJNE	CHAR,#'.',TST_1	;Done if input string abbreviated at this point
    1644/     546 : E4                  TST_2:	CLR	A		;Fetch template characters until end of string
    1645/     547 : 93                  	MOVC	A,@A+DPTR
    1646/     548 : A3                  	INC	DPTR
    1647/     549 : 30 E7 FA            	JNB	ACC.7,TST_2	;Loop until last character detected.
    1648/     54C : B1 19               T_GOOD:	CALL	D_BLNK
    1649/     54E : E4                  	CLR	A
    1650/     54F : 73                  	JMP	@A+DPTR		;Return to next IL instruction
    1651/     550 :                     ;
    1652/     550 :                     ;	Strings do not match.  Leave cursor at start of string.
    1653/     550 :                     ;
    1654/     550 : E4                  T_BAD:	CLR	A
    1655/     551 : 93                  	MOVC	A,@A+DPTR	;Search for final template character.
    1656/     552 : A3                  	INC	DPTR
    1657/     553 : 30 E7 FA            	JNB	ACC.7,T_BAD	;Loop until terminator found.
    1658/     556 : 91 D6               	CALL	LOAD_PNTR
    1659/     558 : D2 49               	SETB	CHAR_FLG
    1660/     55A : C3                  	CLR	C		;Mark string not found.
    1661/     55B : E4                  	CLR	A
    1662/     55C : 73                  	JMP	@A+DPTR		;Return to mismatch branch instruction.
    1663/     55D :                     ;
    1664/     55D :                     ;===============
    1665/     55D :                     ;
    1666/     55D :                     ;TSTV	(LBL)
    1667/     55D :                     ;
    1668/     55D :                     ;
    1669/     55D :                     TSTV:
    1670/     55D :                     ;	Test if first non-blank string is a legal variable symbol.
    1671/     55D :                     ;	If so, move cursor over string and any trailing blanks,
    1672/     55D :                     ;	compute variable index value,
    1673/     55D :                     ;	push onto arithmetic expression stack,
    1674/     55D :                     ;	and continue with following IL instruction.
    1675/     55D :                     ;	Otherwise branch to IL instruction at LBL with cursor unaffected.
    1676/     55D :                     ;
    1677/     55D : 91 FA               	CALL	READ_CHAR
    1678/     55F : 24 BF               	ADD	A,#-'A'		;Subtract offset for base variable.
    1679/     561 : FE                  	MOV	TOS_L,A		;Save index in case needed later.
    1680/     562 : 24 E6               	ADD	A,#-26
    1681/     564 : 50 04               	JNC	ALPHAB		;First character is alphabetic if C=0.
    1682/     566 : D2 49               	SETB	CHAR_FLG
    1683/     568 : C3                  	CLR	C
    1684/     569 : 22                  	RET
    1685/     56A :                     ;
    1686/     56A : 91 CF               ALPHAB:	CALL	SAVE_PNTR	;In case variable name not found.
    1687/     56C : 91 FA               	CALL	READ_CHAR	;Verify that next character is not alphabetic.
    1688/     56E : 24 BF               	ADD	A,#-'A'		;Alphabetic characters now <= 25.
    1689/     570 : 24 E6               	ADD	A,#-26		;Non-alphabetics cause overflow.
    1690/     572 : 50 03               	JNC	NOTVAR		;Alphabetic character means illegal var. name.
    1691/     574 : BC 2E 40            	CJNE	CHAR,#'.',TSTV_1	;Period indicates abbreviated keyword.
    1692/     577 : 91 D6               NOTVAR:	CALL	LOAD_PNTR
    1693/     579 : D2 49               	SETB	CHAR_FLG
    1694/     57B :                     ;*        %TST    (TSTRBI,DBYTE)  ;Test if direct byte token.
    1695/     57B : B1 2D                       call   tst
    1696/     57D : 44 42 59 54 C5              DB      "DBYT",('E' OR 80H)
    1697/     582 : 50 05                       jnc     tstrbi
    1698/     584 : (MACRO)                     LIT_    1
    1698/     584 : 31 76                       CALL    LIT
    1698/     586 : 01                          DB      1
    1699/     587 : 80 27               	SJMP	INDEX
    1700/     589 :                     ;
    1701/     589 :                     ;*TSTRBI: %TST    (TSTXBY,RBIT)
    1702/     589 : B1 2D               tstrbi: call   tst
    1703/     58B : 52 42 49 D4                 DB      "RBI",('T' OR 80H)
    1704/     58F : 50 05                       jnc     tstxby
    1705/     591 : (MACRO)                     LIT_    2
    1705/     591 : 31 76                       CALL    LIT
    1705/     593 : 02                          DB      2
    1706/     594 : 80 1A               	SJMP	INDEX
    1707/     596 :                     ;
    1708/     596 :                     ;*TSTXBY: %TST    (TSTCBY,XBYTE)  ;Test if expansion RAM byte token.
    1709/     596 : B1 2D               tstxby: call   tst
    1710/     598 : 58 42 59 54 C5              DB      "XBYT",('E' OR 80H)
    1711/     59D : 50 05                       jnc     tstcby
    1712/     59F : (MACRO)                     LIT_    3
    1712/     59F : 31 76                       CALL    LIT
    1712/     5A1 : 03                          DB      3
    1713/     5A2 : 80 0C               	SJMP	INDEX
    1714/     5A4 :                     ;
    1715/     5A4 :                     ;*TSTCBY: %TST    (NOTSYM,CBYTE)  ;Test if program memory byte token.
    1716/     5A4 : B1 2D               tstcby: call   tst
    1717/     5A6 : 43 42 59 54 C5              DB      "CBYT",('E' OR 80H)
    1718/     5AB : 50 08                       jnc     notsym
    1719/     5AD : (MACRO)                     LIT_    4
    1719/     5AD : 31 76                       CALL    LIT
    1719/     5AF : 04                          DB      4
    1720/     5B0 : 12 0B 87            INDEX:	CALL	VAR
    1721/     5B3 : D3                  	SETB	C
    1722/     5B4 : 22                  	RET
    1723/     5B5 :                     ;
    1724/     5B5 : C3                  NOTSYM:	CLR	C		;Indicate that condition tested wasn't true.
    1725/     5B6 : 22                  	RET
    1726/     5B7 :                     ;
    1727/     5B7 :                     ;	BASIC Variable name is legitimate (A-Z).
    1728/     5B7 :                     ;
    1729/     5B7 : (MACRO)             TSTV_1:	LIT_	0
    1729/     5B7 : 31 76                       CALL    LIT
    1729/     5B9 : 00                          DB      0
    1730/     5BA : 7F 00               	MOV	TOS_H,#0
    1731/     5BC : 31 4F               	CALL	PUSH_TOS
    1732/     5BE : D2 49               	SETB	CHAR_FLG
    1733/     5C0 : A1 19               	JMP	D_BLNK		;Remove leading blanks from source line.
    1734/     5C2 :                     ;
    1735/     5C2 :                     ;===============
    1736/     5C2 :                     ;
    1737/     5C2 :                     ;TSTN	(LBL)
    1738/     5C2 :                     ;	Test if indicated string is an unsigned number.
    1739/     5C2 :                     ;	If so, move cursor over string and trailing blanks,
    1740/     5C2 :                     ;	compute number's binary value,
    1741/     5C2 :                     ;	push onto arithmetic expression stack, and continue with
    1742/     5C2 :                     ;	following IL instruction.
    1743/     5C2 :                     ;	Otherwise restore cursor and branch to IL instruction at LBL.
    1744/     5C2 :                     ;
    1745/     5C2 :                     ;
    1746/     5C2 : 91 FA               TSTN:	CALL	READ_CHAR
    1747/     5C4 : 51 FC               	CALL	CREATE		;Create entry on AES if legit. digit.
    1748/     5C6 : 40 03               	JC	TSTN_1		;Abort if CHAR is not decimal digit.
    1749/     5C8 : D2 49               	SETB	CHAR_FLG
    1750/     5CA : 22                  	RET
    1751/     5CB :                     ;
    1752/     5CB : 91 FA               TSTN_1:	CALL	READ_CHAR	;Move over matched character.
    1753/     5CD : 71 09               	CALL	APPEND		;Append new digit to entry on TOS.
    1754/     5CF : 40 FA               	JC	TSTN_1		;Continue processing while legal characters.
    1755/     5D1 : 31 4F               	CALL	PUSH_TOS
    1756/     5D3 : D2 49               	SETB	CHAR_FLG
    1757/     5D5 : A1 19               	JMP	D_BLNK		;Remove leading blank characters.
    1758/     5D7 :                     ;
    1759/     5D7 :                     ;===============
    1760/     5D7 :                     ;
    1761/     5D7 :                     ;TSTL	(LBL)
    1762/     5D7 :                     ;	Test if first non-blank string is a BASIC source line number.
    1763/     5D7 :                     ;	If so, move cursor over string and following blanks,
    1764/     5D7 :                     ;	compute number's binary value,
    1765/     5D7 :                     ;	push onto arithmetic expression stack, 
    1766/     5D7 :                     ;	and continue with next IL instruction.
    1767/     5D7 :                     ;	If invalid source line number report syntax error.
    1768/     5D7 :                     ;	If line number not present restore cursor
    1769/     5D7 :                     ;	and branch to IL instruction at LBL.
    1770/     5D7 :                     ;
    1771/     5D7 :                     ;
    1772/     5D7 :                     ;===============
    1773/     5D7 :                     ;
    1774/     5D7 :                     ;TSTS	(LBL)
    1775/     5D7 :                     ;	Test if first character is a quote.
    1776/     5D7 :                     ;	If so, print characters from the BASIC source program to the console
    1777/     5D7 :                     ;	until a (closing) quote is encountered,
    1778/     5D7 :                     ;	pass over any trailing blanks,
    1779/     5D7 :                     ;	leave source cursor pointing to first non-blank character,
    1780/     5D7 :                     ;	and branch to IL instruction at location (LBL).
    1781/     5D7 :                     ;	(Report syntax error if <CR> encountered before quote.)
    1782/     5D7 :                     ;	If first character is not a quote, return to next
    1783/     5D7 :                     ;	sequential IL instruction with cursor unchanged.
    1784/     5D7 :                     ;
    1785/     5D7 :                     ;
    1786/     5D7 : 91 FA               TSTS:	CALL	READ_CHAR
    1787/     5D9 : F5 08               	MOV	TMP0,A
    1788/     5DB : 64 22               	XRL	A,#'"'
    1789/     5DD : 60 08               	JZ	TSTS_1
    1790/     5DF :                     ;	XRL	A,#'''' XOR '"'
    1791/     5DF : 64 05               	XRL	A,#(22h ! 27h)
    1792/     5E1 : 60 04               	JZ	TSTS_1
    1793/     5E3 : C3                  	CLR	C
    1794/     5E4 : D2 49               	SETB	CHAR_FLG
    1795/     5E6 : 22                  	RET
    1796/     5E7 :                     ;
    1797/     5E7 : 91 FA               TSTS_1:	CALL	READ_CHAR	;Read next string character.
    1798/     5E9 : B5 08 02            	CJNE	A,TMP0,TSTS_2
    1799/     5EC : A1 19               	JMP	D_BLNK
    1800/     5EE :                     ;
    1801/     5EE : 11 B2               TSTS_2:	CALL	C_OUT		;Call output routine.
    1802/     5F0 : B4 0D F4            	CJNE	A,#CR,TSTS_1	;<CR> before closing quote is illegal.
    1803/     5F3 : 21 2C               	JMP	SYN_ER		;Transmit error message.
    1804/     5F5 :                     ;
    1805/     5F5 :                     ;===============
    1806/     5F5 :                     ;
    1807/     5F5 :                     ;DONE
    1808/     5F5 :                     ;	Delete leading blanks from the BASIC source line.
    1809/     5F5 :                     ;	Return with the cursor positioned over the first non-blank
    1810/     5F5 :                     ;	character, which must be a colon or <CR> in the source line.
    1811/     5F5 :                     ;	If any other characters are encountered report a syntax error.
    1812/     5F5 :                     ;
    1813/     5F5 :                     ;
    1814/     5F5 :                     ;
    1815/     5F5 : 91 FA               DONE:	CALL	READ_CHAR
    1816/     5F7 : BC 3A 03            	CJNE	CHAR,#':',DONE_1	;Colon indicates resume interpretation.
    1817/     5FA : 22                  	RET			;Return to IL.
    1818/     5FB :                     ;
    1819/     5FB : 91 FA               LNDONE:	CALL	READ_CHAR
    1820/     5FD : BC 0D 01            DONE_1:	CJNE	CHAR,#CR,DONE_2	;Any non-colon, non-CR characters are illegal.
    1821/     600 : 22                  	RET
    1822/     601 :                     ;
    1823/     601 : D2 49               DONE_2:	SETB	CHAR_FLG
    1824/     603 : 21 2C               	JMP	SYN_ER		;Process syntax error if so.
    1825/     605 :                     ;
    1826/     605 :                     ;=======
    1827/     605 :                     ;
    1828/     605 :                     ;IFDONE	(LBL)
    1829/     605 :                     ;	If the first non-blank character is a colon or <CR> in the source line
    1830/     605 :                     ;	then branch to the IL instruction specified by (LBL).
    1831/     605 :                     ;	If any other characters are encountered
    1832/     605 :                     ;	then continue with next IL instruction.
    1833/     605 :                     ;
    1834/     605 :                     ;
    1835/     605 : 91 FA               IFDONE:	CALL	READ_CHAR
    1836/     607 : BC 3A 01            	CJNE	CHAR,#':',IFDN_1	;Colon indicates resume interpretation.
    1837/     60A : 22                  	RET			;Return to IL.
    1838/     60B :                     ;
    1839/     60B : BC 0D 01            IFDN_1:	CJNE	CHAR,#CR,IFDN_2	;Any non-colon, non-CR characters are illegal.
    1840/     60E : 22                  	RET
    1841/     60F :                     ;
    1842/     60F : D2 49               IFDN_2:	SETB	CHAR_FLG
    1843/     611 : D3                  	SETB	C
    1844/     612 : 22                  	RET
    1845/     613 :                     ;
    1846/     613 :                     ;=======
    1847/     613 :                     
    1848/     613 :                     ;$EJECT
    1849/     613 :                     READ_LABEL:
    1850/     613 :                     ;	Read next two characters from program buffer into <LABL_H><LABL_L>.
    1851/     613 :                     ;	Return with carry set if bit 15 of LABL is set (indicating EOF).
    1852/     613 :                     ;
    1853/     613 : 91 FA               	CALL	READ_CHAR
    1854/     615 : F5 55               	MOV	LABL_H,A
    1855/     617 : 91 FA               	CALL	READ_CHAR
    1856/     619 : F5 54               	MOV	LABL_L,A
    1857/     61B : E5 55               	MOV	A,LABL_H
    1858/     61D : A2 E7               	MOV	C,ACC.7
    1859/     61F : 22                  	RET
    1860/     620 :                     ;
    1861/     620 :                     ;=======
    1862/     620 :                     ;
    1863/     620 :                     ;
    1864/     620 :                     L_INIT:
    1865/     620 :                     ;	Initialize for execution of new BASIC source line.
    1866/     620 :                     ;	If none present, or if not in sequential execution mode, 
    1867/     620 :                     ;	then return to line collection operation.
    1868/     620 :                     ;
    1869/     620 : 30 43 02            	JNB	RUNMOD,LINI_1	;Determine operating mode.
    1870/     623 : 80 EE               	JMP	READ_LABEL
    1871/     625 :                     ;
    1872/     625 : D3                  LINI_1:	SETB	C
    1873/     626 : 22                  	RET
    1874/     627 :                     ;
    1875/     627 :                     ;=======
    1876/     627 :                     ;
    1877/     627 :                     ;
    1878/     627 :                     ;
    1879/     627 :                     NL_NXT:
    1880/     627 :                     ;	Output a <CR><LF> and continue with NXT routine.
    1881/     627 :                     ;
    1882/     627 : 11 B0               	CALL	NLINE
    1883/     629 :                     ;
    1884/     629 :                     NXT:
    1885/     629 :                     ;	A colon or carriage return has been previously READ_CHARed.
    1886/     629 :                     ;	If CHAR holds a colon,
    1887/     629 :                     ;	continue interpretation of source line in current mode
    1888/     629 :                     ;	from IL program instruction "TOKEN".
    1889/     629 :                     ;	Otherwise CHAR is a <CR>, and line has been completed.
    1890/     629 :                     ;	Resume execution from IL instruction "STMT".
    1891/     629 :                     ;
    1892/     629 : BC 3A 05            	CJNE	CHAR,#':',NXT_1	;Skip ahead unless colon detected.
    1893/     62C : B1 19               	CALL	D_BLNK
    1894/     62E : 02 08 A2            	JMP	TOKEN		;Continue with interpretation.
    1895/     631 :                     ;
    1896/     631 : 02 08 9D            NXT_1:	JMP	STMT
    1897/     634 :                     ;
    1898/     634 :                     ;=======
    1899/     634 :                     ;
    1900/     634 :                     ;$EJECT
    1901/     634 :                     ;
    1902/     634 :                     ;
    1903/     634 :                     GETLN:
    1904/     634 :                     ;	Input a line from console input device and put in line buffer
    1905/     634 :                     ;	in internal RAM.
    1906/     634 :                     ;
    1907/     634 : E5 2A               	MOV	A,AESP
    1908/     636 : 24 04               	ADD	A,#4
    1909/     638 : F5 08               	MOV	TMP0,A
    1910/     63A : A8 08               GETL_0:	MOV	R0,TMP0		;Point to beginning of line buffer.
    1911/     63C : 31 03               	CALL	STROUT
    1912/     63E : BE                          DB      ('>' OR 80H)
    1913/     63F : 11 95               GETL_1:	CALL	C_IN		;Get next character from console.
    1914/     641 : B4 12 12            	CJNE	A,#12H,GETL_5	;Re-type line on <CNTRL-R>.
    1915/     644 : 31 03               	CALL	STROUT
    1916/     646 : 8D                          DB      (CR OR 80H)     ;Newline.
    1917/     647 : 88 51               	MOV	CURS_L,R0	;Save old value of cursor.
    1918/     649 : A8 08               	MOV	R0,TMP0		;Start at beginning of line buffer.
    1919/     64B : E8                  GETL_6:	MOV	A,R0		;Check if re-write done.
    1920/     64C : 65 51               	XRL	A,CURS_L
    1921/     64E : 60 EF               	JZ	GETL_1		;Continue with line input.
    1922/     650 : E6                  	MOV	A,@R0		;Load character to re-write.
    1923/     651 : 11 B2               	CALL	C_OUT
    1924/     653 : 08                  	INC	R0
    1925/     654 : 80 F5               	SJMP	GETL_6		;Continue until done.
    1926/     656 :                     ;
    1927/     656 : B4 18 06            GETL_5:	CJNE	A,#18H,GETL_7	;Cancel whole line on <CNTRL-X>.
    1928/     659 : 31 03               	CALL	STROUT
    1929/     65B : 23 8D                       DB      '#',(CR OR 80H) ;Advance to next line.
    1930/     65D : 80 DB               	SJMP	GETL_0
    1931/     65F :                     ;
    1932/     65F : B4 7F 11            GETL_7:	CJNE	A,#7FH,GETL_3
    1933/     662 : E8                  	MOV	A,R0
    1934/     663 : B5 08 05            	CJNE	A,TMP0,GETL_4	;Delete previous character (if any).
    1935/     666 : 31 03               	CALL	STROUT
    1936/     668 : 87                          DB      (BEL OR 80H)    ;Echo <BEL>.
    1937/     669 : 80 D4               	SJMP	GETL_1		;Ignore rubouts at beginning of line
    1938/     66B :                     ;
    1939/     66B : 31 03               GETL_4:	CALL	STROUT
    1940/     66D : 08 20 88            	DB	08H,' ',88H	;BKSP,SPC,BKSP
    1941/     670 : 18                  	DEC	R0		;Wipeout last char.
    1942/     671 : 80 CC               	SJMP	GETL_1
    1943/     673 :                     ;
    1944/     673 : B8 4E 05            GETL_3:	CJNE	R0,#AES+AESLEN-1,GETL_2	;Test if buffer full.
    1945/     676 : 31 03               	CALL	STROUT		;Echo <BEL>.
    1946/     678 : 87                          DB      (BEL OR 80H)
    1947/     679 : 80 C4               	SJMP	GETL_1		;If so, override character received.
    1948/     67B :                     ;
    1949/     67B : F6                  GETL_2:	MOV	@R0,A		;Store into line buffer.
    1950/     67C : 11 B2               	CALL	C_OUT		;Echo character.
    1951/     67E : 08                  	INC	R0		;Bump pointer.
    1952/     67F : B4 0D BD            	CJNE	A,#CR,GETL_1	;Repeat for next character.
    1953/     682 : A8 08               	MOV	PNTR_L,TMP0	;Point cursor to beginning of line buffer.
    1954/     684 : C2 49               	CLR	CHAR_FLG
    1955/     686 : 22                  	RET
    1956/     687 :                     ;
    1957/     687 :                     ;===============
    1958/     687 :                     ;
    1959/     687 :                     ;
    1960/     687 :                     PRN:
    1961/     687 :                     ;	Pop top of arithmetic expression stack (AES), 
    1962/     687 :                     ;	convert to decimal number,
    1963/     687 :                     ;	and print to console output device, suppressing leading zeroes.
    1964/     687 :                     ;
    1965/     687 : C2 4A               	CLR	SGN_FLG
    1966/     689 : 71 A3               	CALL	IABS
    1967/     68B : 31 37               	CALL	POP_TOS
    1968/     68D : D2 48               PRNTOS:	SETB	ZERSUP		;Set zero suppression flag.
    1969/     68F : E4                  	CLR	A
    1970/     690 : F5 08               	MOV	TMP0,A
    1971/     692 : 7D 10               	MOV	LP_CNT,#16	;Conversion precision.
    1972/     694 : 20 44 1D            	JB	HEXMOD,PRNHEX
    1973/     697 : 30 4A 03            	JNB	SGN_FLG,PRN_1	;Skip ahead if positive number.
    1974/     69A : 31 03               	CALL	STROUT		;Output minus sign if negative.
    1975/     69C : AD                          DB      ('-' OR 80H)
    1976/     69D : CE                  PRN_1:	XCH	A,TOS_L
    1977/     69E : 33                  	RLC	A
    1978/     69F : CE                  	XCH	A,TOS_L
    1979/     6A0 : CF                  	XCH	A,TOS_H
    1980/     6A1 : 33                  	RLC	A
    1981/     6A2 : CF                  	XCH	A,TOS_H
    1982/     6A3 : C5 08               	XCH	A,TMP0
    1983/     6A5 : 35 E0               	ADDC	A,ACC
    1984/     6A7 : D4                  	DA	A
    1985/     6A8 : C5 08               	XCH	A,TMP0
    1986/     6AA : 35 E0               	ADDC	A,ACC
    1987/     6AC : D4                  	DA	A
    1988/     6AD : DD EE               	DJNZ	LP_CNT,PRN_1
    1989/     6AF : FF                  	MOV	TOS_H,A
    1990/     6B0 : EE                  	MOV	A,TOS_L
    1991/     6B1 : 33                  	RLC	A
    1992/     6B2 : AE 08               	MOV	TOS_L,TMP0
    1993/     6B4 : 11 E4               PRNHEX:	CALL	NIBOUT
    1994/     6B6 : EF                  	MOV	A,TOS_H
    1995/     6B7 : C4                  	SWAP	A
    1996/     6B8 : 11 E4               	CALL	NIBOUT		;Print second digit.
    1997/     6BA : EF                  	MOV	A,TOS_H
    1998/     6BB : 11 E4               	CALL	NIBOUT		;Print third digit.
    1999/     6BD : 30 44 02            	JNB	HEXMOD,PRNH_1
    2000/     6C0 : C2 48               	CLR	ZERSUP		;Print out last two chars. (at least) in hex.
    2001/     6C2 : EE                  PRNH_1:	MOV	A,TOS_L		;Read into Acc.
    2002/     6C3 : C4                  	SWAP	A		;Interchange nibbles.
    2003/     6C4 : 11 E4               	CALL	NIBOUT		;Print fourth digit.
    2004/     6C6 : C2 48               	CLR	ZERSUP
    2005/     6C8 : EE                  	MOV	A,TOS_L		;Reload byte.
    2006/     6C9 : 11 E4               	CALL	NIBOUT		;Print last digit.
    2007/     6CB : 30 44 03            	JNB	HEXMOD,PRNRET
    2008/     6CE : 31 03               	CALL	STROUT		;Print trailing "H".
    2009/     6D0 : C8                          DB      ('H' OR 80H)
    2010/     6D1 : 22                  PRNRET:	RET
    2011/     6D2 :                     ;
    2012/     6D2 :                     ;===============
    2013/     6D2 :                     ;
    2014/     6D2 :                     LSTLIN:
    2015/     6D2 :                     ;	Check Label of Program line pointed to by Cursor.
    2016/     6D2 :                     ;	If legal, print line number, source line, and <CR><LF> to console,
    2017/     6D2 :                     ;	adjust Cursor to start of next line, 
    2018/     6D2 :                     ;	and return with carry set.
    2019/     6D2 :                     ;	Else return with carry cleared.
    2020/     6D2 :                     ;
    2021/     6D2 : D1 13               	CALL	READ_LABEL
    2022/     6D4 : 40 12               	JC	LSTL_1
    2023/     6D6 : AF 55               	MOV	TOS_H,LABL_H
    2024/     6D8 : AE 54               	MOV	TOS_L,LABL_L
    2025/     6DA : C2 4A               	CLR	SGN_FLG
    2026/     6DC : D1 8D               	CALL	PRNTOS
    2027/     6DE : 31 03               	CALL	STROUT		;Insert space before user's source line.
    2028/     6E0 : A0                          DB      (' ' OR 80H)
    2029/     6E1 : 91 FA               LSTL_2:	CALL	READ_CHAR
    2030/     6E3 : 11 B2               	CALL	C_OUT
    2031/     6E5 : B4 0D F9            	CJNE	A,#CR,LSTL_2
    2032/     6E8 : 22                  LSTL_1:	RET
    2033/     6E9 :                     ;
    2034/     6E9 :                     ;===============
    2035/     6E9 :                     ;
    2036/     6E9 :                     ;LST
    2037/     6E9 :                     ;	List the contents of the program memory area.
    2038/     6E9 :                     ;
    2039/     6E9 :                     ;
    2040/     6E9 : D2 43               LST:	SETB	RUNMOD
    2041/     6EB : 91 B8               	CALL	REWIND		;Point to first char of external buffer.
    2042/     6ED : 11 CF               LST_1:	CALL	CNTRL
    2043/     6EF : 40 04               	JC	LSTRET
    2044/     6F1 : D1 D2               	CALL	LSTLIN		;Print out current line if present.
    2045/     6F3 : 50 F8               	JNC	LST_1		;Repeat if successful.
    2046/     6F5 : C2 43               LSTRET:	CLR	RUNMOD
    2047/     6F7 : 22                  	RET
    2048/     6F8 :                     ;
    2049/     6F8 :                     ;===============
    2050/     6F8 :                     ;
    2051/     6F8 :                     ;
    2052/     6F8 :                     INNUM:
    2053/     6F8 :                     ;	Read a numeric character string from the console input device.
    2054/     6F8 :                     ;	Convert to binary value and push onto arithmetic expression stack.
    2055/     6F8 :                     ;	Report error if illegal characters read.
    2056/     6F8 :                     ;
    2057/     6F8 : C2 4A               	CLR	SGN_FLG		;Assume number will be positive.
    2058/     6FA : 31 03               	CALL	STROUT
    2059/     6FC : 3A A0                       DB      ':',(' ' OR 80H);Print input prompt.
    2060/     6FE : 11 95               INUM_0:	CALL	C_IN
    2061/     700 : 11 B2               	CALL	C_OUT		;Echo input
    2062/     702 : B4 20 02            	CJNE	A,#' ',INUM_3
    2063/     705 : 80 F7               	SJMP	INUM_0
    2064/     707 :                     ;
    2065/     707 : B4 2B 02            INUM_3:	CJNE	A,#'+',INUM_4
    2066/     70A : 80 F2               	SJMP	INUM_0
    2067/     70C :                     ;
    2068/     70C : B4 2D 04            INUM_4:	CJNE	A,#'-',INUM_5
    2069/     70F : B2 4A               	CPL	SGN_FLG
    2070/     711 : 80 EB               	SJMP	INUM_0
    2071/     713 :                     ;
    2072/     713 : 51 FC               INUM_5:	CALL	CREATE		;Create value on stack if legal decimal digit.
    2073/     715 : 50 07               	JNC	INUM_2		;Abort if first character received not legal.
    2074/     717 : 11 95               INUM_1:	CALL	C_IN		;Get additional characters.
    2075/     719 : 11 B2               	CALL	C_OUT		;Echo input.
    2076/     71B : B4 7F 06            	CJNE	A,#7FH,INUM_6	;Start over if delete char detected.
    2077/     71E : 31 03               INUM_2:	CALL	STROUT
    2078/     720 : 23 8D                       DB      '#',(CR OR 80H)
    2079/     722 : 80 D4               	SJMP	INNUM
    2080/     724 :                     ;
    2081/     724 : 71 09               INUM_6:	CALL	APPEND		;Incorporate into stack entry.
    2082/     726 : 40 EF               	JC	INUM_1		;Loop while legal characters arrive.
    2083/     728 : 31 4F               	CALL	PUSH_TOS
    2084/     72A : 61 AD               	JMP	NEG_IF_NEG
    2085/     72C :                     ;
    2086/     72C :                     ;===============
    2087/     72C :                     ;$EJECT
    2088/     72C :                     RAM_INIT:
    2089/     72C : E4                  	CLR	A		;Many bytes to be cleared...
    2090/     72D : F5 28               	MOV	MODE,A		;Interactive mode, decimal radix.
    2091/     72F : F5 29               	MOV	FLAGS,A		;Interroutine flags.
    2092/     731 : 75 A0 20            DD010:  MOV     P2,#(EXTRAM >> 8);Select first External RAM page.
    2093/     734 : F8                          MOV     R0,A
    2094/     735 : 74 5A               	MOV	A,#5AH		;Random bit pattern.
    2095/     737 : F2                  	MOVX	@R0,A
    2096/     738 : E2                  	MOVX	A,@R0
    2097/     739 : 64 5A               	XRL	A,#5AH
    2098/     73B : 60 0A               	JZ	EXTINI
    2099/     73D : E4                  	CLR	A
    2100/     73E : 78 10               	MOV	R0,#US_VAR	;Clear variable array.
    2101/     740 : F6                  INIT_1:	MOV	@R0,A
    2102/     741 : 08                  	INC	R0
    2103/     742 : B8 28 FB            	CJNE	R0,#US_VAR+2*NO_VAR,INIT_1	;Loop until all vars cleared.
    2104/     745 : 80 09               	SJMP	INIT_3
    2105/     747 :                     ;
    2106/     747 : D2 40               EXTINI:	SETB	EXTVAR
    2107/     749 : E4                  	CLR	A
    2108/     74A : F8                  	MOV	R0,A		;Clear variable array.
    2109/     74B : F2                  INIT_2:	MOVX	@R0,A
    2110/     74C : 08                  	INC	R0
    2111/     74D : B8 34 FB            	CJNE	R0,#2*26,INIT_2	;Loop until all vars cleared.
    2112/     750 : 22                  INIT_3:	RET
    2113/     751 :                     ;
    2114/     751 :                     ;========
    2115/     751 :                     ;
    2116/     751 :                     ;INIT
    2117/     751 :                     ;	Perform global initialization:
    2118/     751 :                     ;	Clear program memory, empty all I/O buffers, reset all stack
    2119/     751 :                     ;	pointers, etc.
    2120/     751 :                     ;
    2121/     751 :                     ;
    2122/     751 : F1 2C               INIT:	CALL	RAM_INIT
    2123/     753 : 78 34                       MOV     R0,#(EXTRAM & 0ffh)
    2124/     755 : 74 FF               	MOV	A,#0FFH
    2125/     757 : F2                  	MOVX	@R0,A
    2126/     758 : 22                  	RET
    2127/     759 :                     ;
    2128/     759 :                     ;===============
    2129/     759 :                     ;
    2130/     759 :                     ;$EJECT
    2131/     759 :                     ;
    2132/     759 :                     ;	BASIC PROGRAM LINE SEQUENCE CONTROL MACROS:
    2133/     759 :                     ;	===== ======= ==== ======== ======= ======
    2134/     759 :                     ;
    2135/     759 :                     ;XINIT
    2136/     759 :                     ;	Perform initialization needed before starting sequential execution.
    2137/     759 :                     ;	Empty stacks, set BASIC line number to 1, etc.
    2138/     759 :                     ;
    2139/     759 :                     ;
    2140/     759 : 75 2A 2A            XINIT:	MOV	AESP,#AES-1	;Initialize AE Stack.
    2141/     75C : 91 B8               	CALL	REWIND
    2142/     75E : D2 43               	SETB	RUNMOD
    2143/     760 : 22                  	RET			;Begin execution.
    2144/     761 :                     ;
    2145/     761 :                     ;===============
    2146/     761 :                     ;
    2147/     761 :                     FNDLBL:
    2148/     761 :                     ;	Search program buffer for line with label passed on AES (Pop AES).
    2149/     761 :                     ;	If found, return with CURSOR pointing to start of line (before label)
    2150/     761 :                     ;	and carry cleared.
    2151/     761 :                     ;	If not found return with carry set and pointer at start of first
    2152/     761 :                     ;	line with a greater label value (possible EOF).
    2153/     761 :                     ;
    2154/     761 : D2 43               	SETB	RUNMOD		;Kludge to make GET_C fetch from prog. buffer.
    2155/     763 : 91 B8               	CALL	REWIND
    2156/     765 : 31 37               	CALL	POP_TOS
    2157/     767 : 91 CF               FND_1:	CALL	SAVE_PNTR	;Store position of beginning of line.
    2158/     769 : D1 13               	CALL	READ_LABEL
    2159/     76B : 40 12               	JC	FNDDON
    2160/     76D : EE                  	MOV	A,TOS_L
    2161/     76E : 95 54               	SUBB	A,LABL_L
    2162/     770 : F5 54               	MOV	LABL_L,A	;Save non-zero bits.
    2163/     772 : EF                  	MOV	A,TOS_H
    2164/     773 : 95 55               	SUBB	A,LABL_H
    2165/     775 : 45 54               	ORL	A,LABL_L	;Test for non-zero bits.
    2166/     777 : 60 06               	JZ	FNDDON
    2167/     779 : 40 04               	JC	FNDDON		;Carry=1 if a greater label value found.
    2168/     77B : B1 27               	CALL	SKPTXT		;Skip over remaining text portion of line.
    2169/     77D : 80 E8               	SJMP	FND_1
    2170/     77F :                     ;
    2171/     77F : 81 D6               FNDDON:	JMP	LOAD_PNTR
    2172/     781 :                     ;
    2173/     781 :                     ;=======
    2174/     781 :                     ;
    2175/     781 :                     KILL_L:
    2176/     781 :                     ;	Kill (delete) line from code buffer indicated by pointer.
    2177/     781 :                     ;	When called, CURSOR and POINTER hold the address of first LABEL byte of
    2178/     781 :                     ;	line to be deleted.
    2179/     781 :                     ;
    2180/     781 : A9 51               	MOV	DEST_L,CURS_L
    2181/     783 : AB 52               	MOV	DEST_H,CURS_H
    2182/     785 : B1 23               	CALL	SKPLIN		;Pass pointer over full text line.
    2183/     787 :                     ;
    2184/     787 :                     ;	Pointer now indicates first label byte of following line.
    2185/     787 :                     ;	Cursor and DEST still indicate first label byte of obsolete line.
    2186/     787 :                     ;
    2187/     787 : 91 FA               KILL_2:	CALL	READ_CHAR	;Copy down first label byte.
    2188/     789 : B1 11               	CALL	WRITE_CHAR	;Transfer first byte of label number.
    2189/     78B : 20 E7 0D            	JB	ACC.7,KILL_9	;Quit when End of Code sentinel reached.
    2190/     78E : 91 FA               	CALL	READ_CHAR	;Copy down second label byte.
    2191/     790 : B1 11               	CALL	WRITE_CHAR	;Store second byte of label number.
    2192/     792 : 91 FA               KILL_3:	CALL	READ_CHAR	;Transfer text character.
    2193/     794 : B1 11               	CALL	WRITE_CHAR
    2194/     796 : B4 0D F9            	CJNE	A,#CR,KILL_3	;Loop until full line moved.
    2195/     799 : 80 EC               	SJMP	KILL_2		;Continue until all code moved forward.
    2196/     79B :                     ;
    2197/     79B : 22                  KILL_9:	RET			;Full line now deleted.
    2198/     79C :                     ;
    2199/     79C :                     ;=======
    2200/     79C :                     ;
    2201/     79C :                     OPEN_L:
    2202/     79C :                     ;	Open space for new line in code buffer starting at Cursor.
    2203/     79C :                     ;
    2204/     79C : 91 D6               	CALL	LOAD_PNTR	;Load address of point for insertion.
    2205/     79E : C2 49               	CLR	CHAR_FLG
    2206/     7A0 : 91 FA               OPEN_3:	CALL	READ_CHAR	;Test first label byte of following line.
    2207/     7A2 : 20 E7 09            	JB	ACC.7,OPEN_4
    2208/     7A5 : 91 FA               	CALL	READ_CHAR	;Pass over next LABEL byte.
    2209/     7A7 : 91 FA               OPEN_5:	CALL	READ_CHAR
    2210/     7A9 : B4 0D FB            	CJNE	A,#CR,OPEN_5
    2211/     7AC : 80 F2               	SJMP	OPEN_3
    2212/     7AE :                     ;
    2213/     7AE :                     ;	Pointer now indicates end-of-buffer sentinel.
    2214/     7AE :                     ;
    2215/     7AE : E5 0F               OPEN_4:	MOV	A,STRLEN	;Number of bytes needed for BASIC text.
    2216/     7B0 : 24 03               	ADD	A,#3		;Space needed for for label and <CR>.
    2217/     7B2 : 28                  	ADD	A,R0		;Low-order byte of old pointer.
    2218/     7B3 : F9                  	MOV	DEST_L,A
    2219/     7B4 : E4                  	CLR	A
    2220/     7B5 : 3A                  	ADDC	A,PNTR_H
    2221/     7B6 : FB                  	MOV	DEST_H,A
    2222/     7B7 : B4 30 02                    CJNE    A,#(RAMLIM >> 8),OPEN_1
    2223/     7BA : 21 21               	JMP	AES_ER
    2224/     7BC :                     ;
    2225/     7BC :                     ;	Transfer characters from source back to destination
    2226/     7BC :                     ;	until pointer at original CURSOR value.
    2227/     7BC :                     ;
    2228/     7BC : 91 E2               OPEN_1:	CALL	GET_BUF		;Move back next character.
    2229/     7BE : B1 08               	CALL	PUT_BUF
    2230/     7C0 : E8                  	MOV	A,PNTR_L
    2231/     7C1 : B5 51 05            	CJNE	A,CURS_L,OPEN_2
    2232/     7C4 : EA                  	MOV	A,PNTR_H
    2233/     7C5 : B5 52 01            	CJNE	A,CURS_H,OPEN_2
    2234/     7C8 :                     ;
    2235/     7C8 :                     ;	All bytes have been moved back.
    2236/     7C8 :                     ;
    2237/     7C8 : 22                  	RET
    2238/     7C9 :                     ;
    2239/     7C9 :                     OPEN_2:
    2240/     7C9 :                     ;	Decrement src. and dest. pointers and repeat.
    2241/     7C9 :                     ;
    2242/     7C9 : 18                  	DEC	PNTR_L
    2243/     7CA : B8 FF 01            	CJNE	PNTR_L,#0FFH,OPEN_6
    2244/     7CD : 1A                  	DEC	PNTR_H
    2245/     7CE : 19                  OPEN_6:	DEC	DEST_L
    2246/     7CF : B9 FF EA            	CJNE	DEST_L,#0FFH,OPEN_1
    2247/     7D2 : 1B                  	DEC	DEST_H
    2248/     7D3 : 80 E7               	SJMP	OPEN_1		;Repeat for next character.
    2249/     7D5 :                     ;
    2250/     7D5 :                     ;=======
    2251/     7D5 :                     ;
    2252/     7D5 :                     INSR_L:
    2253/     7D5 :                     ;	Insert program line label (still held in <TOS_H><TOS_L> from earlier
    2254/     7D5 :                     ;	call to FNDLBL)
    2255/     7D5 :                     ;	and character string in line buffer (pointed at by L_CURS)
    2256/     7D5 :                     ;	into program buffer gap created by OPEN_L routine
    2257/     7D5 :                     ;	(still pointed at by CURSOR).
    2258/     7D5 :                     ;
    2259/     7D5 : A9 51               	MOV	DEST_L,CURS_L
    2260/     7D7 : AB 52               	MOV	DEST_H,CURS_H
    2261/     7D9 : EF                  	MOV	A,TOS_H
    2262/     7DA : B1 11               	CALL	WRITE_CHAR
    2263/     7DC : EE                  	MOV	A,TOS_L
    2264/     7DD : B1 11               	CALL	WRITE_CHAR
    2265/     7DF : A8 4F               	MOV	PNTR_L,L_CURS
    2266/     7E1 : E6                  INSL_1:	MOV	A,@PNTR_L
    2267/     7E2 : B1 11               	CALL	WRITE_CHAR
    2268/     7E4 : 08                  	INC	PNTR_L
    2269/     7E5 : B4 0D F9            	CJNE	A,#CR,INSL_1
    2270/     7E8 : 22                  	RET
    2271/     7E9 :                     ;
    2272/     7E9 :                     ;=======
    2273/     7E9 :                     ;
    2274/     7E9 :                     ;
    2275/     7E9 :                     INSRT:
    2276/     7E9 :                     ;	Pop line number from top of arithmetic expression stack.
    2277/     7E9 :                     ;	Search BASIC source program for corresponding line number.
    2278/     7E9 :                     ;	If found, delete old line.
    2279/     7E9 :                     ;	Otherwise position cursor before next sequential line number.
    2280/     7E9 :                     ;	If line buffer is not empty then insert line number, contents of
    2281/     7E9 :                     ;	line buffer, and line terminator.
    2282/     7E9 :                     ;
    2283/     7E9 : 18                  	DEC	PNTR_L		;Since previous D_BLNK passed over first char.
    2284/     7EA : 88 4F               	MOV	L_CURS,PNTR_L
    2285/     7EC : F1 61               	CALL	FNDLBL
    2286/     7EE : 40 02               	JC	INSR_1
    2287/     7F0 : F1 81               	CALL	KILL_L		;Delete line iff label found in buffer.
    2288/     7F2 : A9 4F               INSR_1:	MOV	R1,L_CURS
    2289/     7F4 : 19                  	DEC	R1
    2290/     7F5 : 09                  INSR_2:	INC	R1
    2291/     7F6 : E7                  	MOV	A,@R1
    2292/     7F7 : B4 0D FB            	CJNE	A,#CR,INSR_2
    2293/     7FA : E9                  	MOV	A,R1
    2294/     7FB : C3                  	CLR	C
    2295/     7FC : 95 4F               	SUBB	A,L_CURS
    2296/     7FE : F5 0F               	MOV	STRLEN,A
    2297/     800 : 60 06               	JZ	INSR_4
    2298/     802 : 12 07 9C            	CALL	OPEN_L
    2299/     805 : 12 07 D5            	CALL	INSR_L
    2300/     808 : C2 43               INSR_4:	CLR	RUNMOD
    2301/     80A : 22                  	RET
    2302/     80B :                     ;
    2303/     80B :                     ;===============
    2304/     80B :                     ;
    2305/     80B :                     ;
    2306/     80B : 12 01 37            COND:	CALL	POP_TOS
    2307/     80E : EE                  	MOV	A,TOS_L
    2308/     80F : 13                  	RRC	A
    2309/     810 : 22                  	RET
    2310/     811 :                     ;
    2311/     811 :                     ;=======
    2312/     811 :                     ;
    2313/     811 :                     ;XFER
    2314/     811 :                     ;	Pop the value from the top of the arithmetic expression stack (AES).
    2315/     811 :                     ;	Position cursor at beginning of the BASIC source program line
    2316/     811 :                     ;	with that label and begin source interpretation.
    2317/     811 :                     ;	(Report error if corresponding source line not found.)
    2318/     811 :                     ;
    2319/     811 :                     ;
    2320/     811 : 12 07 61            XFER:	CALL	FNDLBL
    2321/     814 : 40 02               	JC	XFERNG
    2322/     816 : 01 9D               	JMP	STMT		;Begin execution of source line.
    2323/     818 :                     ;
    2324/     818 : 02 01 18            XFERNG:	JMP	EXP_ER
    2325/     81B :                     ;
    2326/     81B :                     ;===============
    2327/     81B :                     ;
    2328/     81B :                     ;
    2329/     81B :                     SAV:
    2330/     81B :                     ;	Push BASIC line number of current source line onto AES.
    2331/     81B :                     ;
    2332/     81B : AF 55               	MOV	TOS_H,LABL_H
    2333/     81D : AE 54               	MOV	TOS_L,LABL_L
    2334/     81F : 02 01 4F            	JMP	PUSH_TOS
    2335/     822 :                     ;
    2336/     822 :                     ;===============
    2337/     822 :                     ;
    2338/     822 :                     ;
    2339/     822 :                     RSTR:
    2340/     822 :                     ;	If AES is empty report a nesting error.
    2341/     822 :                     ;	Otherwise, pop AES into current BASIC souce program line number.
    2342/     822 :                     ;
    2343/     822 : 12 07 61            	CALL	FNDLBL
    2344/     825 : 12 05 23            	CALL	SKPLIN		;Pass over statement initiating transfer.
    2345/     828 : 80 73               	JMP	STMT
    2346/     82A :                     ;
    2347/     82A :                     ;===============
    2348/     82A :                     ;
    2349/     82A :                     ;
    2350/     82A :                     LOOP:
    2351/     82A :                     ;	LOOP is called with the AES holding:
    2352/     82A :                     ;	(TOS:)	2 byte VALUE of variable after being incremented,
    2353/     82A :                     ;		2 byte INDEX of variable being incremented,
    2354/     82A :                     ;		1 byte TYPE of variable code,
    2355/     82A :                     ;		2 byte LABEL of line initiating FOR loop,
    2356/     82A :                     ;		2 byte LIMIT specified by FOR statement,
    2357/     82A :                     ;		2 byte INDEX of variable used by FOR loop,
    2358/     82A :                     ;		1 byte TYPE of variable code.
    2359/     82A :                     ;	If indices disagree, then generate syntax error.
    2360/     82A :                     ;	Otherwise, store incremented value in variable popping both from AES.
    2361/     82A :                     ;	If the incremented value <= LIMIT then return with carry set.
    2362/     82A :                     ;	If incr. val. > LIMIT looping is done, so return with carry not set.
    2363/     82A :                     ;
    2364/     82A :                     ;	Compare all three bytes of variable index.
    2365/     82A : E8                  	MOV	A,R0
    2366/     82B : C0 E0               	PUSH	ACC
    2367/     82D : E5 2A               	MOV	A,AESP
    2368/     82F : 24 FE               	ADD	A,#-2
    2369/     831 : F9                  	MOV	R1,A
    2370/     832 : 24 F9               	ADD	A,#-7
    2371/     834 : F8                  	MOV	R0,A
    2372/     835 : 7D 03               	MOV	LP_CNT,#3	;Set to test three bytes.
    2373/     837 : E7                  LOOP_0:	MOV	A,@R1
    2374/     838 : 66                  	XRL	A,@R0
    2375/     839 : 70 20               	JNZ	LOOP_1
    2376/     83B : 18                  	DEC	R0
    2377/     83C : 19                  	DEC	R1
    2378/     83D : DD F8               	DJNZ	LP_CNT,LOOP_0
    2379/     83F :                     ;
    2380/     83F :                     ;	All three bytes of variable code match.
    2381/     83F : D0 E0               	POP	ACC
    2382/     841 : F8                  	MOV	R0,A
    2383/     842 : 12 02 3B            	CALL	STORE
    2384/     845 : E5 2A               	MOV	A,AESP
    2385/     847 : 24 FD               	ADD	A,#-3
    2386/     849 : F9                  	MOV	R1,A
    2387/     84A : C3                  	CLR	C
    2388/     84B : E7                  	MOV	A,@R1
    2389/     84C : 95 08               	SUBB	A,TMP0
    2390/     84E : 09                  	INC	R1
    2391/     84F : E7                  	MOV	A,@R1
    2392/     850 : 20 44 05            	JB	HEXMOD,LOOP_2	;Branch forward if unsigned compare correct.
    2393/     853 : 64 80               	XRL	A,#80H		;Adjust sign bits so signed compare valid.
    2394/     855 : 63 09 80            	XRL	TMP1,#80H
    2395/     858 : 95 09               LOOP_2:	SUBB	A,TMP1
    2396/     85A : 22                  	RET
    2397/     85B :                     ;
    2398/     85B :                     ;	Indices don't match.
    2399/     85B :                     ;
    2400/     85B : D0 E0               LOOP_1:	POP	ACC
    2401/     85D : F8                  	MOV	R0,A
    2402/     85E : 02 01 2C            	JMP	SYN_ER
    2403/     861 :                     ;
    2404/     861 :                     ;=======
    2405/     861 :                     ;
    2406/     861 :                     ;FIN
    2407/     861 :                     ;	Return to line collection routine.
    2408/     861 :                     ;
    2409/     861 :                     ;
    2410/     861 : C2 43               FIN:	CLR	RUNMOD
    2411/     863 : 80 1F               	JMP	CONT		;Return to line collection mode.
    2412/     865 :                     ;
    2413/     865 :                     ;===============
    2414/     865 :                     ;
    2415/     865 :                     ;$EJECT
    2416/     865 :                     ;
    2417/     865 :                     ;	IL SEQUENCE CONTROL INSTRUCTIONS:
    2418/     865 :                     ;	== ======== ======= ============
    2419/     865 :                     ;
    2420/     865 :                     ;IJMP	(LBL)
    2421/     865 :                     ;	Jump to the (potentially distant) IL instruction at location LBL.
    2422/     865 :                     ;Note:	In this implementation IL addresses are equivalent to machine
    2423/     865 :                     ;	language addresses, so IJMP performs a generic JMP.
    2424/     865 :                     ;
    2425/     865 :                     ;
    2426/     865 :                     ;===============
    2427/     865 :                     ;
    2428/     865 :                     ;HOP	(LBL)
    2429/     865 :                     ;	Perform a branch to the IL instruction at (nearby) location LBL.
    2430/     865 :                     ;Note:	In this implementation IL addresses are equivalent to machine
    2431/     865 :                     ;	language addresses, so HOP performs a simple relative SJMP.
    2432/     865 :                     ;
    2433/     865 :                     ;
    2434/     865 :                     ;===============
    2435/     865 :                     ;
    2436/     865 :                     ;ICALL	(LBL)
    2437/     865 :                     ;	Call the IL subroutine starting at instruction LBL.
    2438/     865 :                     ;	Save the location of the next IL instruction on the control stack.
    2439/     865 :                     ;Note:	In this implementation, IL addresses are identical with 
    2440/     865 :                     ;	machine language addresses, and are saved on the MCS-51 hardware stack.
    2441/     865 :                     ;
    2442/     865 :                     ;
    2443/     865 :                     ;===============
    2444/     865 :                     ;
    2445/     865 :                     ;IRET
    2446/     865 :                     ;	Return from IL subroutine to location on top of control stack.
    2447/     865 :                     ;Note:	In this implementation, IL addresses are identical with machine 
    2448/     865 :                     ;	language addresses, which are saved on the hardware stack.
    2449/     865 :                     ;
    2450/     865 :                     ;
    2451/     865 :                     ;===============
    2452/     865 :                     ;
    2453/     865 :                     ;MLCALL
    2454/     865 :                     ;	Call the ML subroutine starting at the address on top of AES.
    2455/     865 :                     ;
    2456/     865 :                     ;
    2457/     865 : A9 2A               MLCALL:	MOV	R1,AESP
    2458/     867 : 87 F0               	MOV	B,@R1
    2459/     869 : 19                  	DEC	R1
    2460/     86A : E7                  	MOV	A,@R1
    2461/     86B : 19                  	DEC	R1
    2462/     86C : 89 2A               	MOV	AESP,R1
    2463/     86E : C0 E0               	PUSH	ACC
    2464/     870 : C0 F0               	PUSH	B
    2465/     872 : 43 D0 18            	ORL	PSW,#00011000B	;Select RB3.
    2466/     875 : 22                  	RET			;Branch to user routine.
    2467/     876 :                     ;
    2468/     876 :                     ;=======
    2469/     876 :                     ;$EJECT
    2470/     876 :                     ;$RESTORE
    2471/     876 :                     ;
    2472/     876 :                     ;	STATEMENT EXECUTOR WRITTEN IN IL (INTERPRETIVE LANGUAGE)
    2473/     876 :                     ;	OPERATIONS IMPLEMENTED BY ASM51 MPL MACRO PROCESSING LANGUAGE
    2474/     876 :                     ;			(8/11/80)
    2475/     876 :                     ;
    2476/     876 : 02 01 2C            CMD_NG:	JMP	SYN_ER
    2477/     879 :                     ;
    2478/     879 : 12 07 51            START:  CALL    INIT
    2479/     87C : C2 43               ERRENT:	CLR	RUNMOD
    2480/     87E : 75 81 55            	MOV	SP,#SP_BASE	;Re-initialize hardware stack.
    2481/     881 : 75 2A 2A            	MOV	AESP,#AES-1	;Initialize AES pointer.
    2482/     884 : 12 01 03            CONT:	CALL	STROUT
    2483/     887 : 4F 4B 8D                    DB      "OK",(CR OR 80H)
    2484/     88A : 12 06 34            CONT_1: CALL    GETLN          ;Receive interactive command line.
    2485/     88D : 12 05 19            	CALL	D_BLNK
    2486/     890 : (MACRO)                     TSTL_   TOKEN
    2486/     890 : 12 05 C2                    CALL    TSTN
    2486/     893 : 50 0D                       JNC     TOKEN
    2487/     895 : 12 07 E9                    CALL    INSRT
    2488/     898 : (MACRO)                     HOP_    CONT_1
    2488/     898 : 80 F0                       SJMP    CONT_1
    2489/     89A :                     ;
    2490/     89A :                     ;=======
    2491/     89A :                     ;
    2492/     89A : 12 07 59            XEC:    CALL    XINIT          ;Initialize for sequential execution.
    2493/     89D : (MACRO)             STMT:   LINIT_          ;Initialize for line execution.
    2493/     89D : 12 06 20                    CALL   L_INIT
    2493/     8A0 : 40 DA                       JC      ERRENT
    2494/     8A2 : 12 00 CF            TOKEN:	CALL	CNTRL
    2495/     8A5 : 12 05 19            	CALL	D_BLNK
    2496/     8A8 : (MACRO)                     TSTV_   S0            ;Parse implied LET command.
    2496/     8A8 : 12 05 5D                    CALL    TSTV
    2496/     8AB : 50 08                       JNC     S0
    2497/     8AD :                     ;*        %TST    (SE4,=)
    2498/     8AD : 12 05 2D                    call   tst
    2499/     8B0 : BD                          db      ('=' OR 80H)
    2500/     8B1 : 50 2E                       jnc     se4
    2501/     8B3 : (MACRO)                     HOP_    SE3
    2501/     8B3 : 80 13                       SJMP    SE3
    2502/     8B5 :                     ;
    2503/     8B5 :                     ;*S0:     %TST    (S1,LET)                ;Parse explicit LET command.
    2504/     8B5 : 12 05 2D            s0:     call   tst
    2505/     8B8 : 4C 45 D4                    DB      "LE",('T' OR 80H)
    2506/     8BB : 50 30                       jnc     s1
    2507/     8BD : (MACRO)                     TSTV_   CMD_NG
    2507/     8BD : 12 05 5D                    CALL    TSTV
    2507/     8C0 : 50 B4                       JNC     CMD_NG
    2508/     8C2 :                     ;*        %TST    (CMD_NG,=)
    2509/     8C2 : 12 05 2D                    call   tst
    2510/     8C5 : BD                          db      ('=' OR 80H)
    2511/     8C6 : 50 AE                       jnc     cmd_ng
    2512/     8C8 : (MACRO)             SE3:    ICALL_  EXPR
    2512/     8C8 : 51 EB                       CALL    EXPR
    2513/     8CA :                     ;*        %TST    (SE3A,%1,)
    2514/     8CA : 12 05 2D                    call   tst
    2515/     8CD : AC                          db      (',' OR 80H)            ;to match tb51.lst
    2516/     8CE : 50 08                       jnc     se3a
    2517/     8D0 : 12 02 37                    CALL    SEQ_STORE
    2518/     8D3 : 12 03 B1            	CALL	IINC
    2519/     8D6 : (MACRO)                     HOP_    SE3
    2519/     8D6 : 80 F0                       SJMP    SE3
    2520/     8D8 :                     ;
    2521/     8D8 : 12 05 F5            SE3A:   CALL    DONE
    2522/     8DB : 12 02 3B            	CALL	STORE
    2523/     8DE : 02 06 29                    JMP     NXT
    2524/     8E1 :                     ;
    2525/     8E1 : 12 05 F5            SE4:    CALL    DONE           ;Process implied PRINT command.
    2526/     8E4 : 12 02 9F            	CALL	FETCH
    2527/     8E7 : 12 06 87                    CALL    PRN
    2528/     8EA : 02 06 27                    JMP     NL_NXT
    2529/     8ED :                     ;
    2530/     8ED :                     ;=======
    2531/     8ED :                     ;
    2532/     8ED :                     ;*S1:     %TST    (S2,GOTO)               ;Parse GOTO command.
    2533/     8ED : 12 05 2D            s1:     call   tst
    2534/     8F0 : 47 4F 54 CF                 DB      "GOT",('O' OR 80H)
    2535/     8F4 : 50 07                       jnc     s2
    2536/     8F6 : (MACRO)                     ICALL_  EXPR
    2536/     8F6 : 51 EB                       CALL    EXPR
    2537/     8F8 : 12 05 FB                    CALL    LNDONE
    2538/     8FB : 01 11                       JMP     XFER
    2539/     8FD :                     ;
    2540/     8FD :                     ;=======
    2541/     8FD :                     ;
    2542/     8FD :                     ;*S2:     %TST    (S3,GOSUB)              ;Parse GOSUB command.
    2543/     8FD : 12 05 2D            s2:     call   tst
    2544/     900 : 47 4F 53 55 C2              DB      "GOSU",('B' OR 80H)
    2545/     905 : 50 09                       jnc     s3
    2546/     907 : 11 1B                       CALL    SAV
    2547/     909 : (MACRO)                     ICALL_  EXPR
    2547/     909 : 51 EB                       CALL    EXPR
    2548/     90B : 12 05 FB                    CALL    LNDONE
    2549/     90E : 01 11                       JMP     XFER
    2550/     910 :                     ;
    2551/     910 :                     ;=======
    2552/     910 :                     ;
    2553/     910 :                     ;*S3:     %TST    (S8,PRINT)              ;Parse PRINT command.
    2554/     910 : 12 05 2D            s3:     call   tst
    2555/     913 : 50 52 49 4E D4              DB      "PRIN",('T' OR 80H)
    2556/     918 : 50 43                       jnc     s8
    2557/     91A : (MACRO)                     IFDONE_ S6B
    2557/     91A : 12 06 05                    CALL    IFDONE
    2557/     91D : 50 38                       JNC     S6B
    2558/     91F :                     ;*S3A:    %TST    (S3B,;)
    2559/     91F : 12 05 2D            s3a:    call   tst
    2560/     922 : BB                          db      (';' OR 80H)
    2561/     923 : 50 02                       jnc     s3b
    2562/     925 : (MACRO)                     HOP_    S3A
    2562/     925 : 80 F8                       SJMP    S3A
    2563/     927 :                     ;
    2564/     927 :                     ;*S3B:    %TST    (S3C,%1,)
    2565/     927 : 12 05 2D            s3b:    call   tst
    2566/     92A : AC                          db      (',' OR 80H)            ;to match TB51.LST
    2567/     92B : 50 05                       jnc     s3c
    2568/     92D : 12 00 DD                    CALL    SPC
    2569/     930 : (MACRO)                     HOP_    S3A
    2569/     930 : 80 ED                       SJMP    S3A
    2570/     932 :                     ;
    2571/     932 : (MACRO)             S3C:    IFDONE_ S6A
    2571/     932 : 12 06 05                    CALL    IFDONE
    2571/     935 : 50 23                       JNC     S6A
    2572/     937 : (MACRO)                     TSTS_   S5
    2572/     937 : 12 05 D7                    CALL    TSTS
    2572/     93A : 40 05                       JC      S5
    2573/     93C : (MACRO)                     ICALL_  EXPR
    2573/     93C : 51 EB                       CALL    EXPR
    2574/     93E : 12 06 87                    CALL    PRN
    2575/     941 :                     ;*S5:     %TST    (S5A,%1,)
    2576/     941 : 12 05 2D            s5:     call   tst
    2577/     944 : AC                          db      (',' OR 80H)            ;to match TB51.LST
    2578/     945 : 50 05                       jnc     s5a
    2579/     947 : 12 00 DD                    CALL    SPC
    2580/     94A : (MACRO)                     HOP_    S3A
    2580/     94A : 80 D3                       SJMP    S3A
    2581/     94C :                     ;
    2582/     94C :                     ;*S5A:    %TST    (S6,;)
    2583/     94C : 12 05 2D            s5a:    call   tst
    2584/     94F : BB                          db      (';' OR 80H)
    2585/     950 : 50 02                       jnc     s6
    2586/     952 : (MACRO)                     HOP_    S3A
    2586/     952 : 80 CB                       SJMP    S3A
    2587/     954 :                     ;
    2588/     954 : 12 05 F5            S6:     CALL    DONE
    2589/     957 : 02 06 27            S6B:    JMP     NL_NXT
    2590/     95A :                     ;
    2591/     95A : 02 06 29            S6A:    JMP     NXT
    2592/     95D :                     ;
    2593/     95D :                     ;=======
    2594/     95D :                     ;
    2595/     95D :                     ;*S8:     %TST    (S9,IF)         ;Parse IF command.
    2596/     95D : 12 05 2D            s8:     call   tst
    2597/     960 : 49 C6                       db      'I',('F' OR 80H)
    2598/     962 : 50 16                       jnc     s9
    2599/     964 : (MACRO)                     ICALL_  EXPR
    2599/     964 : 51 EB                       CALL    EXPR
    2600/     966 :                     ;*        %TST    (S8A,THEN)
    2601/     966 : 12 05 2D                    call   tst
    2602/     969 : 54 48 45 CE                 DB      "THE",('N' OR 80H)
    2603/     96D : 50 00                       jnc     s8a
    2604/     96F : (MACRO)             S8A:    COND_   S8B
    2604/     96F : 11 0B                       CALL   COND
    2604/     971 : 50 02                       JNC    S8B
    2605/     973 : (MACRO)                     IJMP_   TOKEN         ;Continue parsing command.
    2605/     973 : 01 A2                       JMP     TOKEN
    2606/     975 :                     ;
    2607/     975 : 12 05 27            S8B:    CALL    SKPTXT
    2608/     978 : (MACRO)                     IJMP_   STMT
    2608/     978 : 01 9D                       JMP     STMT
    2609/     97A :                     ;
    2610/     97A :                     ;=======
    2611/     97A :                     ;
    2612/     97A :                     ;*S9:     %TST    (S12,INPUT)             ;Parse INPUT command.
    2613/     97A : 12 05 2D            s9:     call   tst
    2614/     97D : 49 4E 50 55 D4              DB      "INPU",('T' OR 80H)
    2615/     982 : 50 2B                       jnc     s12
    2616/     984 : (MACRO)             S10:    TSTS_   S10B
    2616/     984 : 12 05 D7                    CALL    TSTS
    2616/     987 : 40 0B                       JC      S10B
    2617/     989 : (MACRO)                     TSTV_   S10D
    2617/     989 : 12 05 5D                    CALL    TSTV
    2617/     98C : 50 19                       JNC     S10D
    2618/     98E : 12 06 F8                    CALL    INNUM
    2619/     991 : 12 02 3B            	CALL	STORE
    2620/     994 :                     ;*S10B:   %TST    (S10C,;)
    2621/     994 : 12 05 2D            s10b:   call   tst
    2622/     997 : BB                          db      (';' OR 80H)
    2623/     998 : 50 02                       jnc     s10c
    2624/     99A : (MACRO)                     HOP_    S10
    2624/     99A : 80 E8                       SJMP    S10
    2625/     99C :                     ;
    2626/     99C :                     ;*S10C:   %TST    (S11,%1,)
    2627/     99C : 12 05 2D            s10c:   call   tst
    2628/     99F : AC                          db      (',' OR 80H)            ;to match TB51.LST
    2629/     9A0 : 50 07                       jnc     s11
    2630/     9A2 : 12 00 DD                    CALL    SPC
    2631/     9A5 : (MACRO)                     HOP_    S10
    2631/     9A5 : 80 DD                       SJMP    S10
    2632/     9A7 :                     ;
    2633/     9A7 : (MACRO)             S10D:   IJMP_   SYN_NG
    2633/     9A7 : 61 CA                       JMP     SYN_NG
    2634/     9A9 :                     ;
    2635/     9A9 : 12 05 F5            S11:    CALL    DONE
    2636/     9AC : 02 06 27                    JMP     NL_NXT
    2637/     9AF :                     ;
    2638/     9AF :                     ;=======
    2639/     9AF :                     ;
    2640/     9AF :                     ;*S12:    %TST    (S13,RETURN)            ;Parse RETURN command.
    2641/     9AF : 12 05 2D            s12:    call   tst
    2642/     9B2 : 52 45 54 55 52 CE           DB      "RETUR",('N' OR 80H)
    2643/     9B8 : 50 05                       jnc     s13
    2644/     9BA : 12 05 FB                    CALL    LNDONE
    2645/     9BD : 01 22                       JMP     RSTR
    2646/     9BF :                     ;
    2647/     9BF :                     ;=======
    2648/     9BF :                     ;
    2649/     9BF :                     ;*S13:    %TST    (S13A,CALL)             ;Machine language CALL.
    2650/     9BF : 12 05 2D            s13:    call   tst
    2651/     9C2 : 43 41 4C CC                 DB      "CAL",('L' OR 80H)
    2652/     9C6 : 50 0D                       jnc     s13a
    2653/     9C8 : (MACRO)                     ICALL_  EXPR
    2653/     9C8 : 51 EB                       CALL    EXPR
    2654/     9CA : 12 05 FB                    CALL    LNDONE
    2655/     9CD : (MACRO)                     MLCALL_
    2655/     9CD : 11 65                       CALL    MLCALL
    2655/     9CF : 53 D0 E7                    ANL     PSW,#11100111B
    2656/     9D2 : 02 06 29                    JMP     NXT
    2657/     9D5 :                     ;
    2658/     9D5 :                     ;=======
    2659/     9D5 :                     ;
    2660/     9D5 :                     ;*S13A:   %TST    (S13B,FOR)
    2661/     9D5 : 12 05 2D            s13a:   call   tst
    2662/     9D8 : 46 4F D2                    DB      "FO",('R' OR 80H)
    2663/     9DB : 50 21                       jnc     s13b
    2664/     9DD : (MACRO)                     TSTV_   FOR_ER
    2664/     9DD : 12 05 5D                    CALL    TSTV
    2664/     9E0 : 50 4B                       JNC     FOR_ER
    2665/     9E2 :                     ;*        %TST    (FOR_ER,=)
    2666/     9E2 : 12 05 2D                    call   tst
    2667/     9E5 : BD                          db      ('=' OR 80H)
    2668/     9E6 : 50 45                       jnc     for_er
    2669/     9E8 : (MACRO)                     ICALL_  EXPR
    2669/     9E8 : 51 EB                       CALL    EXPR
    2670/     9EA : 12 02 37            	CALL	SEQ_STORE
    2671/     9ED :                     ;*        %TST    (FOR_ER,TO)
    2672/     9ED : 12 05 2D                    call   tst
    2673/     9F0 : 54 CF                       db      'T',('O' OR 80H)
    2674/     9F2 : 50 39                       jnc     for_er
    2675/     9F4 : (MACRO)                     ICALL_  EXPR
    2675/     9F4 : 51 EB                       CALL    EXPR
    2676/     9F6 : 12 05 FB                    CALL    LNDONE
    2677/     9F9 : 11 1B                       CALL    SAV
    2678/     9FB : 02 06 29                    JMP     NXT
    2679/     9FE :                     ;
    2680/     9FE :                     ;=======
    2681/     9FE :                     ;
    2682/     9FE :                     ;*S13B:   %TST    (S13C,NEXT)
    2683/     9FE : 12 05 2D            s13b:   call   tst
    2684/     A01 : 4E 45 58 D4                 DB      "NEX",('T' OR 80H)
    2685/     A05 : 50 28                       jnc     s13c
    2686/     A07 : (MACRO)                     TSTV_   FOR_ER
    2686/     A07 : 12 05 5D                    CALL    TSTV
    2686/     A0A : 50 21                       JNC     FOR_ER
    2687/     A0C : 12 05 F5                    CALL    DONE
    2688/     A0F : 12 02 9B            	CALL	SEQ_FETCH
    2689/     A12 : 12 03 B1            	CALL	IINC
    2690/     A15 : (MACRO)                     NEXT_LOOP_      FORDON
    2690/     A15 : 11 2A                       CALL   LOOP
    2690/     A17 : 40 05                       JC     FORDON
    2691/     A19 : 12 01 62            	CALL	DUPL
    2692/     A1C : 01 22                       JMP     RSTR
    2693/     A1E :                     ;
    2694/     A1E : 12 01 37            FORDON:	CALL	POP_TOS
    2695/     A21 : 12 01 37            	CALL	POP_TOS
    2696/     A24 : 12 01 37            	CALL	POP_TOS
    2697/     A27 : 12 01 49            	CALL	POP_ACC
    2698/     A2A : 02 06 29                    JMP     NXT
    2699/     A2D :                     ;
    2700/     A2D :                     ;=======
    2701/     A2D :                     ;
    2702/     A2D : (MACRO)             FOR_ER: IJMP_   CMD_NG
    2702/     A2D : 01 76                       JMP     CMD_NG
    2703/     A2F :                     ;
    2704/     A2F :                     ;=======
    2705/     A2F :                     ;
    2706/     A2F :                     ;*S13C:   %TST    (S14,END)               ;Parse END command.
    2707/     A2F : 12 05 2D            s13c:   call   tst
    2708/     A32 : 45 4E C4                    DB      "EN",('D' OR 80H)
    2709/     A35 : 50 05                       jnc     s14
    2710/     A37 : 12 05 FB                    CALL    LNDONE
    2711/     A3A : 01 61                       JMP     FIN
    2712/     A3C :                     ;
    2713/     A3C :                     ;=======
    2714/     A3C :                     ;
    2715/     A3C :                     ;*S14:    %TST    (S15,LIST)              ;Parse LIST command.
    2716/     A3C : 12 05 2D            s14:    call   tst
    2717/     A3F : 4C 49 53 D4                 DB      "LIS",('T' OR 80H)
    2718/     A43 : 50 14                       jnc     s15
    2719/     A45 : (MACRO)                     IFDONE_ S14B
    2719/     A45 : 12 06 05                    CALL    IFDONE
    2719/     A48 : 50 0A                       JNC     S14B
    2720/     A4A : (MACRO)                     ICALL_  EXPR
    2720/     A4A : 51 EB                       CALL    EXPR
    2721/     A4C : 12 07 61            	CALL	FNDLBL
    2722/     A4F : 12 06 ED            	CALL	LST_1
    2723/     A52 : (MACRO)                     IJMP_   CONT
    2723/     A52 : 01 84                       JMP     CONT
    2724/     A54 :                     ;
    2725/     A54 : 12 06 E9            S14B:   CALL    LST
    2726/     A57 : (MACRO)                     IJMP_   CONT
    2726/     A57 : 01 84                       JMP     CONT
    2727/     A59 :                     ;
    2728/     A59 :                     ;=======
    2729/     A59 :                     ;
    2730/     A59 :                     ;*S15:    %TST    (S16,RUN)               ;Parse LIST command.
    2731/     A59 : 12 05 2D            s15:    call   tst
    2732/     A5C : 52 55 CE                    DB      "RU",('N' OR 80H)
    2733/     A5F : 50 05                       jnc     s16
    2734/     A61 : 12 05 FB                    CALL    LNDONE
    2735/     A64 : (MACRO)                     IJMP_   XEC
    2735/     A64 : 01 9A                       JMP     XEC
    2736/     A66 :                     ;
    2737/     A66 :                     ;=======
    2738/     A66 :                     ;
    2739/     A66 :                     ;*S16:    %TST    (S16A,NEW)
    2740/     A66 : 12 05 2D            s16:    call   tst
    2741/     A69 : 4E 45 D7                    DB      "NE",('W' OR 80H)
    2742/     A6C : 50 05                       jnc     s16a
    2743/     A6E : 12 05 F5                    CALL    DONE
    2744/     A71 : (MACRO)                     IJMP_   START
    2744/     A71 : 01 79                       JMP     START
    2745/     A73 :                     ;
    2746/     A73 :                     ;=======
    2747/     A73 :                     ;*S16A:   %TST    (S17,RESET)
    2748/     A73 : 12 05 2D            s16a:   call   tst
    2749/     A76 : 52 45 53 45 D4              DB      "RESE",('T' OR 80H)
    2750/     A7B : 50 06                       jnc     s17
    2751/     A7D : 12 05 F5                    CALL    DONE
    2752/     A80 : 02 00 00            	JMP	0000H
    2753/     A83 :                     ;
    2754/     A83 :                     ;=======
    2755/     A83 :                     ;
    2756/     A83 :                     ;*S17:    %TST    (S17A,ROM)
    2757/     A83 : 12 05 2D            s17:    call   tst
    2758/     A86 : 52 4F CD                    DB      "RO",('M' OR 80H)
    2759/     A89 : 50 0A                       jnc     s17a
    2760/     A8B : 12 05 F5                    CALL    DONE
    2761/     A8E : D2 41               	SETB	ROMMOD
    2762/     A90 : C2 42               	CLR	EXTMOD
    2763/     A92 : 02 06 29                    JMP     NXT
    2764/     A95 :                     ;
    2765/     A95 :                     ;*S17A:   %TST    (S17B,RAM)
    2766/     A95 : 12 05 2D            s17a:   call   tst
    2767/     A98 : 52 41 CD                    DB      "RA",('M' OR 80H)
    2768/     A9B : 50 08                       jnc     s17b
    2769/     A9D : 12 05 F5                    CALL    DONE
    2770/     AA0 : C2 41               	CLR	ROMMOD
    2771/     AA2 : 02 06 29                    JMP     NXT
    2772/     AA5 :                     ;
    2773/     AA5 :                     ;*S17B:   %TST    (S17C,PROM)
    2774/     AA5 : 12 05 2D            s17b:   call   tst
    2775/     AA8 : 50 52 4F CD                 DB      "PRO",('M' OR 80H)
    2776/     AAC : 50 0A                       jnc     s17c
    2777/     AAE : 12 05 F5                    CALL    DONE
    2778/     AB1 : D2 41               	SETB	ROMMOD
    2779/     AB3 : D2 42               	SETB	EXTMOD
    2780/     AB5 : 02 06 29                    JMP     NXT
    2781/     AB8 :                     ;
    2782/     AB8 :                     ;*S17C:   %TST    (S18,HEX)
    2783/     AB8 : 12 05 2D            s17c:   call   tst
    2784/     ABB : 48 45 D8                    DB      "HE",('X' OR 80H)
    2785/     ABE : 50 08                       jnc     s18
    2786/     AC0 : 12 05 F5                    CALL    DONE
    2787/     AC3 : D2 44               	SETB	HEXMOD
    2788/     AC5 : 02 06 29                    JMP     NXT
    2789/     AC8 :                     ;
    2790/     AC8 :                     ;*S18:    %TST    (S19,DECIMAL)
    2791/     AC8 : 12 05 2D            s18:    call   tst
    2792/     ACB : 44 45 43 49 4D 41           DB      "DECIMA",('L' OR 80H)
                    CC 
    2793/     AD2 : 50 08                       jnc     s19
    2794/     AD4 : 12 05 F5                    CALL    DONE
    2795/     AD7 : C2 44               	CLR	HEXMOD
    2796/     AD9 : 02 06 29                    JMP     NXT
    2797/     ADC :                     ;
    2798/     ADC :                     ;*S19:    %TST    (S20,REM)
    2799/     ADC : 12 05 2D            s19:    call   tst
    2800/     ADF : 52 45 CD                    DB      "RE",('M' OR 80H)
    2801/     AE2 : 50 05                       jnc     s20
    2802/     AE4 : 12 05 27                    CALL    SKPTXT
    2803/     AE7 : (MACRO)                     IJMP_   STMT
    2803/     AE7 : 01 9D                       JMP     STMT
    2804/     AE9 :                     ;
    2805/     AE9 : (MACRO)             S20:    IJMP_   CMD_NG
    2805/     AE9 : 01 76                       JMP     CMD_NG
    2806/     AEB :                     ;
    2807/     AEB :                     ;$EJECT
    2808/     AEB :                     ;
    2809/     AEB :                     ;	INTERPRETIVE LANGUAGE SUBROUTINES:
    2810/     AEB :                     ;	============ ======== ===========
    2811/     AEB :                     ;
    2812/     AEB : (MACRO)             EXPR:   ICALL_  AR_EXP
    2812/     AEB : 51 F8                       CALL    AR_EXP
    2813/     AED : (MACRO)             E0:     ICALL_  RELOP
    2813/     AED : 71 CC                       CALL    RELOP
    2814/     AEF : 50 40               	JNC	E5
    2815/     AF1 : (MACRO)                     ICALL_  AR_EXP
    2815/     AF1 : 51 F8                       CALL    AR_EXP
    2816/     AF3 : 12 04 8B                    CALL    CMPR
    2817/     AF6 : (MACRO)                     HOP_    E0
    2817/     AF6 : 80 F5                       SJMP    E0
    2818/     AF8 :                     ;
    2819/     AF8 : (MACRO)             AR_EXP: ICALL_  TERM
    2819/     AF8 : 71 32                       CALL    TERM
    2820/     AFA :                     ;*E1:     %TST    (E2,+)
    2821/     AFA : 12 05 2D            e1:     call   tst
    2822/     AFD : AB                          db      ('+' OR 80H)
    2823/     AFE : 50 07                       jnc     e2
    2824/     B00 : (MACRO)                     ICALL_  TERM
    2824/     B00 : 71 32                       CALL    TERM
    2825/     B02 : 12 03 61            	CALL	IADD
    2826/     B05 : (MACRO)                     HOP_    E1
    2826/     B05 : 80 F3                       SJMP    E1
    2827/     B07 :                     ;
    2828/     B07 :                     ;*E2:     %TST    (E3,-)
    2829/     B07 : 12 05 2D            e2:     call   tst
    2830/     B0A : AD                          db      ('-' OR 80H)
    2831/     B0B : 50 07                       jnc     e3
    2832/     B0D : (MACRO)                     ICALL_  TERM
    2832/     B0D : 71 32                       CALL    TERM
    2833/     B0F : 12 03 67            	CALL	ISUB
    2834/     B12 : (MACRO)                     HOP_    E1
    2834/     B12 : 80 E6                       SJMP    E1
    2835/     B14 :                     ;
    2836/     B14 :                     ;*E3:     %TST    (E4,OR)
    2837/     B14 : 12 05 2D            e3:     call   tst
    2838/     B17 : 4F D2                       db      'O',('R' OR 80H)
    2839/     B19 : 50 07                       jnc     e4
    2840/     B1B : (MACRO)                     ICALL_  TERM
    2840/     B1B : 71 32                       CALL    TERM
    2841/     B1D : 12 03 7D            	CALL	IOR
    2842/     B20 : (MACRO)                     HOP_    E1
    2842/     B20 : 80 D8                       SJMP    E1
    2843/     B22 :                     ;
    2844/     B22 :                     ;*E4:     %TST    (E5,XOR)
    2845/     B22 : 12 05 2D            e4:     call   tst
    2846/     B25 : 58 4F D2                    DB      "XO",('R' OR 80H)
    2847/     B28 : 50 07                       jnc     e5
    2848/     B2A : (MACRO)                     ICALL_  TERM
    2848/     B2A : 71 32                       CALL    TERM
    2849/     B2C : 12 03 87            	CALL	IXOR
    2850/     B2F : (MACRO)                     HOP_    E1
    2850/     B2F : 80 C9                       SJMP    E1
    2851/     B31 :                     ;
    2852/     B31 : 22                  E5:     RET
    2853/     B32 :                     ;
    2854/     B32 :                     ;=======
    2855/     B32 :                     ;
    2856/     B32 : (MACRO)             TERM:   ICALL_  FACT
    2856/     B32 : 71 6D                       CALL    FACT
    2857/     B34 :                     ;*TERM_0: %TST    (TERM_1,*)
    2858/     B34 : 12 05 2D            term_0: call   tst
    2859/     B37 : AA                          db      ('*' OR 80H)
    2860/     B38 : 50 07                       jnc     term_1
    2861/     B3A : (MACRO)                     ICALL_  FACT
    2861/     B3A : 71 6D                       CALL    FACT
    2862/     B3C : 12 03 F3            	CALL	IMUL
    2863/     B3F : (MACRO)                     HOP_    TERM_0
    2863/     B3F : 80 F3                       SJMP    TERM_0
    2864/     B41 :                     ;
    2865/     B41 :                     ;*TERM_1: %TST    (TERM_2,/)
    2866/     B41 : 12 05 2D            term_1: call   tst
    2867/     B44 : AF                          db      ('/' OR 80H)
    2868/     B45 : 50 07                       jnc     term_2
    2869/     B47 : (MACRO)                     ICALL_  FACT
    2869/     B47 : 71 6D                       CALL    FACT
    2870/     B49 : 12 04 06            	CALL	IDIV
    2871/     B4C : (MACRO)                     HOP_    TERM_0
    2871/     B4C : 80 E6                       SJMP    TERM_0
    2872/     B4E :                     ;
    2873/     B4E :                     ;*TERM_2: %TST    (TERM_3,AND)
    2874/     B4E : 12 05 2D            term_2: call   tst
    2875/     B51 : 41 4E C4                    DB      "AN",('D' OR 80H)
    2876/     B54 : 50 07                       jnc     term_3
    2877/     B56 : (MACRO)                     ICALL_  FACT
    2877/     B56 : 71 6D                       CALL    FACT
    2878/     B58 : 12 03 73            	CALL	IAND
    2879/     B5B : (MACRO)                     HOP_    TERM_0
    2879/     B5B : 80 D7                       SJMP    TERM_0
    2880/     B5D :                     ;
    2881/     B5D :                     ;*TERM_3: %TST    (TERM_4,MOD)
    2882/     B5D : 12 05 2D            term_3: call   tst
    2883/     B60 : 4D 4F C4                    DB      "MO",('D' OR 80H)
    2884/     B63 : 50 07                       jnc     term_4
    2885/     B65 : (MACRO)                     ICALL_  FACT
    2885/     B65 : 71 6D                       CALL    FACT
    2886/     B67 : 12 04 02            	CALL	IMOD
    2887/     B6A : (MACRO)                     HOP_    TERM_0
    2887/     B6A : 80 C8                       SJMP    TERM_0
    2888/     B6C :                     ;
    2889/     B6C : 22                  TERM_4: RET
    2890/     B6D :                     ;
    2891/     B6D :                     ;=======
    2892/     B6D :                     ;
    2893/     B6D :                     ;*FACT:   %TST    (FACT_1,-)
    2894/     B6D : 12 05 2D            fact:   call   tst
    2895/     B70 : AD                          db      ('-' OR 80H)
    2896/     B71 : 50 06                       jnc     fact_1
    2897/     B73 : (MACRO)                     ICALL_  VAR
    2897/     B73 : 71 87                       CALL    VAR
    2898/     B75 : 12 03 91            	CALL	NEG
    2899/     B78 : 22                          RET
    2900/     B79 :                     ;
    2901/     B79 :                     ;*FACT_1: %TST    (VAR,NOT)
    2902/     B79 : 12 05 2D            fact_1: call   tst
    2903/     B7C : 4E 4F D4                    DB      "NO",('T' OR 80H)
    2904/     B7F : 50 06                       jnc     var
    2905/     B81 : (MACRO)                     ICALL_  VAR
    2905/     B81 : 71 87                       CALL    VAR
    2906/     B83 : 12 03 A0            	CALL	ICPL
    2907/     B86 : 22                          RET
    2908/     B87 :                     ;
    2909/     B87 :                     ;
    2910/     B87 :                     ;=======
    2911/     B87 :                     ;
    2912/     B87 : (MACRO)             VAR:    TSTV_   VAR_0
    2912/     B87 : 12 05 5D                    CALL    TSTV
    2912/     B8A : 50 04                       JNC     VAR_0
    2913/     B8C : 12 02 9F            	CALL	FETCH
    2914/     B8F : 22                          RET
    2915/     B90 :                     ;
    2916/     B90 : (MACRO)             VAR_0:  TSTN_   VAR_1
    2916/     B90 : 12 05 C2                    CALL    TSTN
    2916/     B93 : 50 01                       JNC     VAR_1
    2917/     B95 : 22                          RET
    2918/     B96 :                     ;
    2919/     B96 :                     ;*VAR_1:  %TST    (VAR_1A,RND)
    2920/     B96 : 12 05 2D            var_1:  call   tst
    2921/     B99 : 52 4E C4                    DB      "RN",('D' OR 80H)
    2922/     B9C : 50 0F                       jnc     var_1a
    2923/     B9E : 12 04 63                    CALL    RND
    2924/     BA1 : (MACRO)                     ICALL_  VAR_2
    2924/     BA1 : 71 BB                       CALL    VAR_2
    2925/     BA3 : 12 04 02            	CALL	IMOD
    2926/     BA6 : 12 03 A3            	CALL	IABS
    2927/     BA9 : 12 03 B1            	CALL	IINC
    2928/     BAC : 22                          RET
    2929/     BAD :                     ;
    2930/     BAD :                     ;*VAR_1A: %TST    (VAR_2,ABS)
    2931/     BAD : 12 05 2D            var_1a: call   tst
    2932/     BB0 : 41 42 D3                    DB      "AB",('S' OR 80H)
    2933/     BB3 : 50 06                       jnc     var_2
    2934/     BB5 : (MACRO)                     ICALL_  VAR_2
    2934/     BB5 : 71 BB                       CALL    VAR_2
    2935/     BB7 : 12 03 A3            	CALL	IABS
    2936/     BBA : 22                          RET
    2937/     BBB :                     ;
    2938/     BBB :                     ;*VAR_2:  %TST    (SYN_NG,%1()
    2939/     BBB : 12 05 2D            var_2:  call   tst
    2940/     BBE : A8                          db      '(' OR 80H              ;to match TB51.LST
    2941/     BBF : 50 09                       jnc     syn_ng
    2942/     BC1 : (MACRO)                     ICALL_  EXPR
    2942/     BC1 : 51 EB                       CALL    EXPR
    2943/     BC3 :                     ;*        %TST    (SYN_NG,%1))
    2944/     BC3 : 12 05 2D                    call   tst
    2945/     BC6 : A9                          db      ')' OR 80H              ;to match TB51.LST
    2946/     BC7 : 50 01                       jnc     syn_ng
    2947/     BC9 : 22                          RET
    2948/     BCA :                     ;
    2949/     BCA :                     ;=======
    2950/     BCA :                     ;
    2951/     BCA : (MACRO)             SYN_NG: IJMP_   CMD_NG
    2951/     BCA : 01 76                       JMP     CMD_NG
    2952/     BCC :                     ;
    2953/     BCC :                     ;$EJECT
    2954/     BCC :                     ;
    2955/     BCC :                     RELOP:
    2956/     BCC :                     ;	Search for relational operator in text string.
    2957/     BCC :                     ;	If found, push appropriate operator code on AES and return with
    2958/     BCC :                     ;	carry set.
    2959/     BCC :                     ;	Otherwise restore cursor and return with carry=0.
    2960/     BCC :                     ;
    2961/     BCC :                     ;*        %TST    (REL_1,=)
    2962/     BCC : 12 05 2D                    call   tst
    2963/     BCF : BD                          db      ('=' OR 80H)
    2964/     BD0 : 50 05                       jnc     rel_1
    2965/     BD2 : (MACRO)                     LIT_    010B            ;Test for _=_
    2965/     BD2 : 12 01 76                    CALL    LIT
    2965/     BD5 : 02                          DB      010B
    2966/     BD6 : 22                          RET
    2967/     BD7 :                     ;
    2968/     BD7 :                     ;*REL_1:  %TST    (REL_2,<=)
    2969/     BD7 : 12 05 2D            rel_1:  call   tst
    2970/     BDA : 3C BD                       db      '<',('=' OR 80H)
    2971/     BDC : 50 05                       jnc     rel_2
    2972/     BDE : (MACRO)                     LIT_    110B            ;Test for <=_
    2972/     BDE : 12 01 76                    CALL    LIT
    2972/     BE1 : 06                          DB      110B
    2973/     BE2 : 22                          RET
    2974/     BE3 :                     ;
    2975/     BE3 :                     ;*REL_2:  %TST    (REL_3,<>)
    2976/     BE3 : 12 05 2D            rel_2:  call   tst
    2977/     BE6 : 3C BE                       db      '<',('>' OR 80H)
    2978/     BE8 : 50 05                       jnc     rel_3
    2979/     BEA : (MACRO)                     LIT_    101B            ;Test for <_>
    2979/     BEA : 12 01 76                    CALL    LIT
    2979/     BED : 05                          DB      101B
    2980/     BEE : 22                          RET
    2981/     BEF :                     ;
    2982/     BEF :                     ;*REL_3:  %TST    (REL_4,<)
    2983/     BEF : 12 05 2D            rel_3:  call   tst
    2984/     BF2 : BC                          db      ('<' OR 80H)
    2985/     BF3 : 50 05                       jnc     rel_4
    2986/     BF5 : (MACRO)                     LIT_    100B            ;Test for <__
    2986/     BF5 : 12 01 76                    CALL    LIT
    2986/     BF8 : 04                          DB      100B
    2987/     BF9 : 22                          RET
    2988/     BFA :                     ;
    2989/     BFA :                     ;*REL_4:  %TST    (REL_5,>=)
    2990/     BFA : 12 05 2D            rel_4:  call   tst
    2991/     BFD : 3E BD                       db      '>',('=' OR 80H)
    2992/     BFF : 50 05                       jnc     rel_5
    2993/     C01 : (MACRO)                     LIT_    011B            ;Test for _=>
    2993/     C01 : 12 01 76                    CALL    LIT
    2993/     C04 : 03                          DB      011B
    2994/     C05 : 22                          RET
    2995/     C06 :                     ;
    2996/     C06 :                     ;*REL_5:  %TST    (REL_6,>)
    2997/     C06 : 12 05 2D            rel_5:  call   tst
    2998/     C09 : BE                          db      ('>' OR 80H)
    2999/     C0A : 50 05                       jnc     rel_6
    3000/     C0C : (MACRO)                     LIT_    001B            ;Test for __>
    3000/     C0C : 12 01 76                    CALL    LIT
    3000/     C0F : 01                          DB      001B
    3001/     C10 : 22                          RET
    3002/     C11 :                     ;
    3003/     C11 : C3                  REL_6:	CLR	C
    3004/     C12 : 22                          RET
    3005/     C13 :                     ;
    3006/     C13 :                     ;=======
    3007/     C13 :                     ;
    3008/     C13 :                     ;$EJECT
    3009/     C13 :                     ;$LIST
    3010/     C13 :                     ;
    3011/     C13 : 0F                  	INC	R7		;Dummy ML program.
    3012/     C14 : 8F 90               	MOV	P1,R7
    3013/     C16 : 22                  	RET
    3014/     C17 :                     ;
    3015/     C17 :                     INTROM:				;Start of ROM program buffer.
    3016/     C17 :                     ;$INCLUDE(TBACEY.SRC)
    3017/     C17 : 35 08                       dw      2101
    3018/     C19 : 50 52 2E 22 48 65           db      "PR.\"Hello\"",CR
                    6C 6C 6F 22 0D 
    3019/     C24 : 36 08                       dw      2102
    3020/     C26 : 50 52 2E 22 54 68           db      "PR.\"This is being run under Tiny Basic V2.3\"",CR
                    69 73 69 73 62 65 
                    69 6E 67 72 75 6E 
                    75 6E 64 65 72 54 
                    69 6E 79 42 61 73 
                    69 63 56 32 2E 33 
                    22 0D 
    3021/     C4C : E0 0B                       dw      3040
    3022/     C4E : 50 52 2E 3A 49 4E           db      "PR.:IN.\"TYPE anything TO END PROGRAM\",D",CR
                    2E 22 54 59 50 45 
                    61 6E 79 74 68 69 
                    6E 67 54 4F 45 4E 
                    44 50 52 4F 47 52 
                    41 4D 22 2C 44 0D 
    3023/     C72 : EA 0B                       dw      3050
    3024/     C74 : 50 52 2E 22 48 61           db      "PR.\"Have fun!!.....J Lum  4/25/92\"",CR
                    76 65 66 75 6E 21 
                    21 2E 2E 2E 2E 2E 
                    4A 4C 75 6D 34 2F 
                    32 35 2F 39 32 22 
                    0D 
    3025/     C93 : F4 0B                       dw      3060
    3026/     C95 : 45 4E 44 0D                 db      "END",CR
    3027/     C99 : 80                  	DB	80H		;Marks end of program.
    3028/     C9A :                     ;
    3029/     C9A :                     	END
 AS V1.42 Beta [Bld 32] - source file tb51as23.asm - page 2 - 1/7/2020 15:50:22
Tiny-Basic51 - Modified for Macro Assembler AS


  symbol table (* = unused):
  ------------------------

*AC :                            D6 B |  ACC :                           E0 D |
 ADD_16 :                       359 C |  ADR_ER :                       1FF C |
 AES :                           2B D |  AESLEN :                        24 - |
 AESP :                          2A D |  AES_ER :                       121 C |
 ALPHAB :                       56A C |  APND_1 :                       326 C |
 APND_2 :                       34A C |  APND_4 :                       324 C |
 APN_ER :                       34C C |  APPEND :                       309 C |
*ARCHITECTURE : i386-unknown-freebsd - |
 AR_EXP :                       AF8 C |  ASCTBL :                        F3 C |
 B :                             F0 D | *BANK0 :                          0 - |
*BANK1 :                          1 - | *BANK2 :                          2 - |
*BANK3 :                          3 - |  BAUDID :                        45 C |
 BEL :                            7 - | *BIGENDIAN :                      0 - |
*BIG_PROBLEM :                  480 C | *BRANCHEXT :                      0 - |
*CASESENSITIVE :                  0 - |  CMD_NG :                       876 C |
 CMPR :                         48B C |  CMPR_1 :                       4AA C |
 CMPR_2 :                       4B0 C |  CMPR_4 :                       4A2 C |
 CNTRET :                        DC C |  CNTRL :                         CF C |
 CNTR_2 :                        D7 C |  COND :                         80B C |
*CONSTPI :        3.141592653589793 - |  CONT :                         884 C |
 CONT_1 :                       88A C |  COUT_1 :                        CE C |
 COUT_2 :                        C6 C |  COUT_3 :                        CA C |
 CR :                             D - |  CREATE :                       2FC C |
 CREA_1 :                       308 C |  CURS_H :                        52 D |
 CURS_L :                        51 D | *CY :                            D7 B |
 C_IN :                          95 C |  C_IN_1 :                        AF C |
 C_IN_2 :                        A3 C |  C_OUT :                         B2 C |
 C_SAVE :                        53 D | *DATE :                    1/7/2020 - |
*DD001 :                        26D C | *DD002 :                        2CC C |
*DD003 :                        4E5 C | *DD004 :                        50B C |
*DD005 :                         95 C | *DD006 :                         B2 C |
*DD007 :                         B5 C | *DD008 :                         BC C |
*DD009 :                         BF C | *DD010 :                        731 C |
*DD012 :                          3 C | *DD014 :                          B C |
*DD016 :                         13 C | *DD018 :                         1B C |
*DD020 :                         23 C |  DIV_1 :                        459 C |
 DIV_2 :                        45E C |  DIV_LP :                       42C C |
 DIV_NG :                       461 C |  DIV_RP :                       443 C |
 DONE :                         5F5 C |  DONE_1 :                       5FD C |
 DONE_2 :                       601 C |  DPH :                           83 D |
 DPL :                           82 D |  DUPL :                         162 C |
 D_BLNK :                       519 C |  E0 :                           AED C |
 E1 :                           AFA C |  E2 :                           B07 C |
 E3 :                           B14 C |  E4 :                           B22 C |
 E5 :                           B31 C | *EA :                            AF B |
 ERRENT :                       87C C |  ERROUT :                       115 C |
*ES :                            AC B | *ET0 :                           A9 B |
*ET1 :                           AB B | *EX0 :                           A8 B |
*EX1 :                           AA B |  EXPR :                         AEB C |
 EXP_ER :                       118 C |  EXP_OV :                       356 C |
 EXTINI :                       747 C |  EXTMOD :                        42 B |
 EXTRAM :                      2034 - |  EXTROM :                      1080 - |
 EXTVAR :                        40 B |  F0 :                            D5 B |
 FACT :                         B6D C |  FACT_1 :                       B79 C |
*FALSE :                          0 - |  FETBDN :                       2F7 C |
 FETCBY :                       2F1 C |  FETCH :                        29F C |
 FETDBY :                       2D8 C |  FETDIR :                       20F C |
 FETERR :                       2D6 C |  FETEXT :                       2CB C |
 FETJTB :                       2B3 C |  FETRBI :                       2DE C |
 FETSFR :                       215 C |  FETVAR :                       2B8 C |
 FETXBY :                       2EA C |  FET_0 :                        2A1 C |
 FET_1 :                        2AE C |  FIN :                          861 C |
 FLAGS :                         29 D |  FNDDON :                       77F C |
 FNDLBL :                       761 C |  FND_1 :                        767 C |
 FORDON :                       A1E C |  FOR_ER :                       A2D C |
*FULLPMMU :                       1 - |  GETLN :                        634 C |
 GETL_0 :                       63A C |  GETL_1 :                       63F C |
 GETL_2 :                       67B C |  GETL_3 :                       673 C |
 GETL_4 :                       66B C |  GETL_5 :                       656 C |
 GETL_6 :                       64B C |  GETL_7 :                       65F C |
 GETROM :                       4E9 C |  GET_BUF :                      4E2 C |
 GET_C :                        4DD C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - |  HEXMOD :                        44 B |
 H_FLG :                         4D B |  IABS :                         3A3 C |
 IADD :                         361 C |  IAND :                         373 C |
 ICPL :                         3A0 C |  IDIV :                         406 C |
 IDIV_0 :                       408 C |  IE :                            A8 D |
*IE0 :                           89 B | *IE1 :                           8B B |
*IEC :                           A8 D |  IFDN_1 :                       60B C |
 IFDN_2 :                       60F C |  IFDONE :                       605 C |
 IINC :                         3B1 C |  IINC_1 :                       3BA C |
 IMOD :                         402 C |  IMUL :                         3F3 C |
 IMUL_1 :                       3C7 C |  IMUL_2 :                       3D1 C |
 IMUL_3 :                       3DB C |  INDEX :                        5B0 C |
 INDTBL :                       1C2 C | *INEXTMODE :                      0 - |
 INIT :                         751 C |  INIT_1 :                       740 C |
 INIT_2 :                       74B C |  INIT_3 :                       750 C |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
 INNUM :                        6F8 C |  INSL_1 :                       7E1 C |
*INSRCMODE :                      0 - |  INSRT :                        7E9 C |
 INSR_1 :                       7F2 C |  INSR_2 :                       7F5 C |
 INSR_4 :                       808 C |  INSR_L :                       7D5 C |
*INSUPMODE :                      0 - | *INT0 :                          B2 B |
*INT1 :                          B3 B |  INTROM :                       C17 C |
 INUM_0 :                       6FE C |  INUM_1 :                       717 C |
 INUM_2 :                       71E C |  INUM_3 :                       707 C |
 INUM_4 :                       70C C |  INUM_5 :                       713 C |
 INUM_6 :                       724 C |  IOR :                          37D C |
 IP :                            B8 D | *IPC :                           B8 D |
 ISUB :                         367 C | *IT0 :                           88 B |
*IT1 :                           8A B |  IXOR :                         387 C |
 KILL_2 :                       787 C |  KILL_3 :                       792 C |
 KILL_9 :                       79B C |  KILL_L :                       781 C |
 LABL_H :                        55 D |  LABL_L :                        54 D |
 LF :                             A - |  LINI_1 :                       625 C |
*LISTON :                         1 - |  LIT :                          176 C |
 LIT_1 :                        185 C |  LNDONE :                       5FB C |
 LOAD_PNTR :                    4D6 C |  LOOP :                         82A C |
 LOOP_0 :                       837 C |  LOOP_1 :                       85B C |
 LOOP_2 :                       858 C |  LST :                          6E9 C |
 LSTLIN :                       6D2 C |  LSTL_1 :                       6E8 C |
 LSTL_2 :                       6E1 C |  LSTRET :                       6F5 C |
 LST_1 :                        6ED C |  L_CURS :                        4F D |
 L_INIT :                       620 C | *MACEXP :                         1 - |
 MLCALL :                       865 C |  MODE :                          28 D |
 MOD_FLG :                       4C B |  MOMCPU :                      8051 - |
 MOMCPUNAME :                  8051 - |  MSKTBL :                       22F C |
 MSK_PC :                       22C C |  MUL_16 :                       3BB C |
 NEG :                          391 C |  NEG_0 :                        394 C |
 NEG_IF_NEG :                   3AD C | *NESTMAX :                      100 - |
 NIBOUT :                        E4 C |  NIBO_1 :                        EF C |
 NIBO_2 :                        EB C |  NIBO_3 :                        F2 C |
 NLINE :                         B0 C |  NL_NXT :                       627 C |
 NOTSYM :                       5B5 C |  NOTVAR :                       577 C |
 NO_PROBLEM :                   484 C |  NO_SFR :                         E - |
 NO_VAR :                         C - |  NXT :                          629 C |
 NXT_1 :                        631 C |  OPEN_1 :                       7BC C |
 OPEN_2 :                       7C9 C |  OPEN_3 :                       7A0 C |
 OPEN_4 :                       7AE C |  OPEN_5 :                       7A7 C |
 OPEN_6 :                       7CE C |  OPEN_L :                       79C C |
 OV :                            D2 B |  OV_TST :                       34F C |
*P :                             D0 B | *P0 :                            80 D |
 P1 :                            90 D |  P2 :                            A0 D |
 P3 :                            B0 D | *PACKING :                        0 - |
*PADDING :                        1 - | *PCON :                          87 D |
 POP_ACC :                      149 C |  POP_TOS :                      137 C |
 PRN :                          687 C |  PRNHEX :                       6B4 C |
 PRNH_1 :                       6C2 C |  PRNRET :                       6D1 C |
 PRNTOS :                       68D C |  PRN_1 :                        69D C |
*PS :                            BC B |  PSW :                           D0 D |
*PT0 :                           B9 B | *PT1 :                           BB B |
 PUSH_C :                       4B2 C |  PUSH_TOS :                     14F C |
 PUTROM :                       50F C |  PUT_BUF :                      508 C |
*PX0 :                           B8 B | *PX1 :                           BA B |
 R4_FLG :                        49 B |  RAMLIM :                      3000 - |
 RAM_INIT :                     72C C | *RB8 :                           9A B |
*RD :                            B7 B |  RDCHDN :                       505 C |
 READ_LABEL :                   613 C |  READ_R4 :                      4FA C |
*RELAXED :                        0 - |  RELOP :                        BCC C |
 REL_1 :                        BD7 C |  REL_2 :                        BE3 C |
 REL_3 :                        BEF C |  REL_4 :                        BFA C |
 REL_5 :                        C06 C |  REL_6 :                        C11 C |
*REN :                           9C B |  REREAD :                       506 C |
 REWIND :                       4B8 C |  REWROM :                       4C2 C |
 RI :                            98 B |  RND :                          463 C |
 ROMMOD :                        41 B | *RS0 :                           D3 B |
*RS1 :                           D4 B |  RSTR :                         822 C |
 RUNMOD :                        43 B |  RUNROM :                        8E C |
 RWXROM :                       4CA C |  RXD :                           B0 B |
 S0 :                           8B5 C |  S1 :                           8ED C |
 S10 :                          984 C |  S10B :                         994 C |
 S10C :                         99C C |  S10D :                         9A7 C |
 S11 :                          9A9 C |  S12 :                          9AF C |
 S13 :                          9BF C |  S13A :                         9D5 C |
 S13B :                         9FE C |  S13C :                         A2F C |
 S14 :                          A3C C |  S14B :                         A54 C |
 S15 :                          A59 C |  S16 :                          A66 C |
 S16A :                         A73 C |  S17 :                          A83 C |
 S17A :                         A95 C |  S17B :                         AA5 C |
 S17C :                         AB8 C |  S18 :                          AC8 C |
 S19 :                          ADC C |  S2 :                           8FD C |
 S20 :                          AE9 C |  S3 :                           910 C |
 S3A :                          91F C |  S3B :                          927 C |
 S3C :                          932 C |  S5 :                           941 C |
 S5A :                          94C C |  S6 :                           954 C |
 S6A :                          95A C |  S6B :                          957 C |
 S8 :                           95D C |  S8A :                          96F C |
 S8B :                          975 C |  S9 :                           97A C |
 SAV :                          81B C |  SAVE_PNTR :                    4CF C |
 SBUF :                          99 D |  SCON :                          98 D |
 SE3 :                          8C8 C |  SE3A :                         8D8 C |
 SE4 :                          8E1 C |  SEED_H :                         E D |
 SEED_L :                         D D |  SEQ_FETCH :                    29B C |
 SEQ_FLG :                       4B B |  SEQ_STORE :                    237 C |
 SETRBI :                       28E C |  SFID_1 :                       1F1 C |
 SFID_2 :                       1FA C |  SFRTBL :                       18A C |
 SFR_ID :                       1EC C |  SGN_FLG :                       4A B |
 SKPLIN :                       523 C |  SKPTXT :                       527 C |
*SM0 :                           9F B | *SM1 :                           9E B |
*SM2 :                           9D B |  SP :                            81 D |
 SPC :                           DD C |  SPLIT_DBA :                    21B C |
 SPLSFR :                       225 C |  SP_BASE :                       55 - |
*SP_INI :                        32 C |  START :                        879 C |
*STDDEF51INC :                    1 - |  STK_ER :                       15F C |
 STMT :                         89D C |  STORE :                        23B C |
 STOR_0 :                       23D C |  STOR_1 :                       250 C |
 STRCBY :                       293 C |  STRDBY :                       278 C |
 STRDIR :                       201 C |  STREXT :                       26C C |
 STRJTB :                       255 C |  STRLEN :                         F D |
 STROUT :                       103 C |  STRO_1 :                       107 C |
 STRO_2 :                       111 C |  STRRBI :                       27E C |
 STRSFR :                       209 C |  STRTBL :                       198 C |
 STRVAR :                       25A C |  STRXBY :                       293 C |
 SYN_ER :                       12C C |  SYN_NG :                       BCA C |
 S_INIT :                        26 C | *T0 :                            B4 B |
*T1 :                            B5 B |  TABCNT :                        50 D |
 TABSIZ :                         8 - | *TB8 :                           9B B |
 TCON :                          88 D |  TERM :                         B32 C |
 TERM_0 :                       B34 C |  TERM_1 :                       B41 C |
 TERM_2 :                       B4E C |  TERM_3 :                       B5D C |
 TERM_4 :                       B6C C | *TF0 :                           8D B |
*TF1 :                           8F B | *TH0 :                           8C D |
 TH1 :                           8D D |  TI :                            99 B |
*TIME :                    15:50:22 - | *TL0 :                           8A D |
*TL1 :                           8B D |  TMOD :                          89 D |
 TMP0 :                           8 D |  TMP1 :                           9 D |
 TMP2 :                           A D |  TMP3 :                           B D |
 TMP4 :                           C D |  TOKEN :                        8A2 C |
*TR0 :                           8C B |  TR1 :                           8E B |
*TRUE :                           1 - |  TST :                          52D C |
 TSTCBY :                       5A4 C |  TSTN :                         5C2 C |
 TSTN_1 :                       5CB C |  TSTRBI :                       589 C |
 TSTS :                         5D7 C |  TSTS_1 :                       5E7 C |
 TSTS_2 :                       5EE C |  TSTV :                         55D C |
 TSTV_1 :                       5B7 C |  TSTXBY :                       596 C |
 TST_1 :                        535 C |  TST_2 :                        546 C |
*TXD :                           B1 B |  T_BAD :                        550 C |
 T_GOOD :                       54C C |  US_VAR :                        10 D |
 VAR :                          B87 C |  VAR_0 :                        B90 C |
 VAR_1 :                        B96 C |  VAR_1A :                       BAD C |
 VAR_2 :                        BBB C |  VERS :                          23 - |
*VERSION :                     142F - | *WR :                            B6 B |
 WRCH_1 :                       518 C |  WRITE_R4 :                     511 C |
 XEC :                          89A C |  XFER :                         811 C |
 XFERNG :                       818 C |  XINIT :                        759 C |
 XRAD_1 :                       330 C |  ZERSUP :                        48 B |

    473 symbols
     91 unused symbols

 AS V1.42 Beta [Bld 32] - source file tb51as23.asm - page 3 - 1/7/2020 15:50:22
Tiny-Basic51 - Modified for Macro Assembler AS


  defined macros:
  ---------------

COND_                                 | HOP_                                 
ICALL_                                | IFDONE_                              
IJMP_                                 | LINIT_                               
LIT_                                  | MLCALL_                              
NEXT_LOOP_                            | TSTL_                                
TSTN_                                 | TSTS_                                
TSTV_                                 | USING                                

     14 macros

 AS V1.42 Beta [Bld 32] - source file tb51as23.asm - page 4 - 1/7/2020 15:50:22
Tiny-Basic51 - Modified for Macro Assembler AS


  DEFINEs:
  --------

TOS_H      = R7
TOS_L      = R6
LP_CNT     = R5
CHAR       = R4
DEST_H     = R3
PNTR_H     = R2
DEST_L     = R1
PNTR_L     = R0
AND        = &
OR         = |

 AS V1.42 Beta [Bld 32] - source file tb51as23.asm - page 5 - 1/7/2020 15:50:22
Tiny-Basic51 - Modified for Macro Assembler AS


  codepages:
  ----------

STANDARD (0 changed characters)


0.10 seconds assembly time

   3408 lines source file
   3520 lines incl. macro expansions
      3 passes
      0 errors
      0 warnings
