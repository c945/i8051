 AS V1.42 Beta [Bld 32] - source file tb51as23.asm - page 1 - 1/12/2020 19:43:56
Tiny-Basic51 - Modified for Macro Assembler AS


       1/       0 :                     ;	$MOD51
       2/       0 :                     	CPU	8051
       3/       0 :                     	include	stddef51.inc
(1)    1/       0 :                                     save
(1)  375/       0 :                                     restore                 ; wieder erlauben
(1)  376/       0 :                     
(1)  377/       0 :                     
       4/       0 :                     ;       $NODEBUG
       5/       0 :                     ;	$PAGEWIDTH	(80)
       6/       0 :                     ;	$PAGELENGTH	(66)
       7/       0 :                     	page	0
       8/       0 :                     ;       $TITLE          (Tiny-Basic51 - Modified for Metalink ASM51)
       9/       0 :                     	title	"Tiny-Basic51 - Modified for Macro Assembler AS"
      10/       0 :                     
      11/       0 :                     #define	OR	|
      12/       0 :                     #define	AND	&
      13/       0 :                     
      14/       0 :                     LIT_    MACRO   K
      15/       0 :                     	CALL	LIT
      16/       0 :                     	DB	K
      17/       0 :                     	ENDM
      18/       0 :                     
      19/       0 :                     TSTV_   MACRO   LBL
      20/       0 :                             CALL    TSTV
      21/       0 :                             JNC     LBL
      22/       0 :                             ENDM
      23/       0 :                     
      24/       0 :                     TSTN_   MACRO   LBL
      25/       0 :                             CALL    TSTN
      26/       0 :                             JNC     LBL
      27/       0 :                             ENDM
      28/       0 :                     
      29/       0 :                     TSTL_   MACRO   LBL
      30/       0 :                             CALL    TSTN
      31/       0 :                             JNC     LBL
      32/       0 :                             ENDM
      33/       0 :                     
      34/       0 :                     TSTS_   MACRO   LBL
      35/       0 :                             CALL    TSTS
      36/       0 :                             JC      LBL
      37/       0 :                             ENDM
      38/       0 :                     
      39/       0 :                     IFDONE_ MACRO   LBL
      40/       0 :                             CALL    IFDONE
      41/       0 :                             JNC     LBL
      42/       0 :                             ENDM
      43/       0 :                     
      44/       0 :                     LINIT_  MACRO
      45/       0 :                             CALL   L_INIT
      46/       0 :                             JC      ERRENT
      47/       0 :                             ENDM
      48/       0 :                     
      49/       0 :                     COND_   MACRO   LBL
      50/       0 :                             CALL   COND
      51/       0 :                             JNC    LBL
      52/       0 :                             ENDM
      53/       0 :                     
      54/       0 :                     NEXT_LOOP_       MACRO   LBL
      55/       0 :                             CALL   LOOP
      56/       0 :                             JC     LBL
      57/       0 :                             ENDM
      58/       0 :                     
      59/       0 :                     IJMP_   MACRO   LBL
      60/       0 :                             JMP     LBL
      61/       0 :                             ENDM
      62/       0 :                     
      63/       0 :                     HOP_    MACRO   LBL
      64/       0 :                             SJMP    LBL
      65/       0 :                             ENDM
      66/       0 :                     
      67/       0 :                     ICALL_  MACRO   LBL
      68/       0 :                             CALL    LBL
      69/       0 :                             ENDM
      70/       0 :                     
      71/       0 :                     MLCALL_ MACRO
      72/       0 :                             CALL    MLCALL
      73/       0 :                             ANL     PSW,#11100111B
      74/       0 :                             ENDM
      75/       0 :                     
      76/       0 :                     ;$ERRORPRINT TITLE(MCS-51(TM) TINY BASIC INTERPRETER 8/26/80)
      77/       0 :                     ;
      78/       0 :                     ;	TINY BASIC INTERPRETER PROGRAM  (CREATED 3/10/80   JHW)
      79/       0 :                     ;	==============================
      80/       0 :                     ;
      81/       0 :                     ;	INSITE ORDER NO. BF10
      82/       0 :                     ;
      83/       0 : =23H                VERS    EQU     23H
      84/       0 :                     ;
      85/       0 :                     ; Known Update History:
      86/       0 :                     ; Modified from 2.1 to 2.2 by lss 4 jan 1983 to fix errors in the divide routine; and the random number generator.
      87/       0 :                     ; Updated: Jim Lum/CompTech Systems, Inc. 04/25/92  V2.3  Converted to Metalink ASM51
      88/       0 :                     ;
      89/       0 :                     ;
      90/       0 :                     ;	STATUS:
      91/       0 :                     ;	======
      92/       0 :                     ;
      93/       0 :                     ;
      94/       0 :                     ;	NEW FEATURES/GIMMICKS TO BE CONSIDERED:
      95/       0 :                     ;
      96/       0 :                     ;	On power-up, system should adapt itself to whatever RAM it can
      97/       0 :                     ;	find off-chip.
      98/       0 :                     ;	Should allow for and/or identify multiple baud rates for serial link.
      99/       0 :                     ;	Should allow other physical devices (software serial I/O, etc.).
     100/       0 :                     ;
     101/       0 :                     ;	Amount of RAM consumed by BASIC variables should be user-alterable.
     102/       0 :                     ;	16-bit variable array handling should be provided when external RAM
     103/       0 :                     ;	is available.
     104/       0 :                     ;	Program buffering in internal RAM and/or line buffering in external RAM
     105/       0 :                     ;	(when available/not available) might be nice.
     106/       0 :                     ;
     107/       0 :                     ;	INNUM could be changed to allow line editing and expression input.
     108/       0 :                     ;
     109/       0 :                     ;	Interrupt handlers should be provided for, and supported by strapping
     110/       0 :                     ;	options so that CRT is not required.
     111/       0 :                     ;
     112/       0 :                     ;	Symbolically-accessable 8-bit pseudo CPU-registers, ports,
     113/       0 :                     ;	etc. desired to support ML debug.
     114/       0 :                     ;	During CALL, pseudo-registers should be loaded/saved.
     115/       0 :                     ;
     116/       0 :                     ;	Capability to load and dump programs to MDS or twin system desired.
     117/       0 :                     ;	Download command desired compatible with ISIS hex file format.
     118/       0 :                     ;	Line buffering should ignore initial line-feed to be compatible
     119/       0 :                     ;	with down-load or cross-load, and terminate on <cntrl-Z>.
     120/       0 :                     ;
     121/       0 :                     ;	Expression evaluation algorithm should be changed to use less stack
     122/       0 :                     ;	and allow more precedence levels.
     123/       0 :                     ;	Since EXPR recursive, hardware stack can overflow (not checked).
     124/       0 :                     ;
     125/       0 :                     ;	NEXT command should verify that a valid loop record is on the AES 
     126/       0 :                     ;	as opposed to GOSUB return address, and vice-versa.
     127/       0 :                     ;	STEP values other than +1 should be considered.
     128/       0 :                     ;
     129/       0 :                     ;	Error reporting could re-type line and indicate error point.
     130/       0 :                     ;	Error numbers (if retained) should make some sense.
     131/       0 :                     ;	Might be indices for error message strings.
     132/       0 :                     ;
     133/       0 :                     ;	TRACE mode could aid BASIC debug by typing each source line # executed.
     134/       0 :                     ;
     135/       0 :                     ;	RND number seed should be easily alterable for games, etc.
     136/       0 :                     ;
     137/       0 :                     ;$EJECT
     138/       0 :                     ;
     139/       0 :                     ;	AESTHETIC IMPROVEMENTS DESIRED:
     140/       0 :                     ;
     141/       0 :                     ;	Disallow 0 and >7FFFH line numbers.
     142/       0 :                     ;
     143/       0 :                     ;	Source modules could be re-grouped to be more readable
     144/       0 :                     ;	and re-ordered to minimize use of LJMPs and LCALLs.
     145/       0 :                     ;	Linkage jumps might be created in second 2K page to provide efficient
     146/       0 :                     ;	access to first 2K.
     147/       0 :                     ;
     148/       0 :                     ;	PRN could insert zeros before leading Hex digits.
     149/       0 :                     ;
     150/       0 :                     ;	IDIV uses variable storage inefficiently (TMP0-TMP4).
     151/       0 :                     ;	Should be modified to make use of actual stack variables.
     152/       0 :                     ;
     153/       0 :                     ;	TST could use optimized algorithm for single character token tests.
     154/       0 :                     ;	String tests should skip over unsearched strings more efficiently.
     155/       0 :                     ;
     156/       0 :                     ;	Program buffer searching could be speeded by giving line length 
     157/       0 :                     ;	before text string and computing branch over undesired lines.
     158/       0 :                     ;
     159/       0 :                     ;	Math and AES operations might be optimized by dedicating R1 as AESP
     160/       0 :                     ;	to be loaded and saved only on entering/leaving execution mode.
     161/       0 :                     ;
     162/       0 :                     ;	Input radix should be determined by 'H' suffix presence.
     163/       0 :                     ;	Otherwise labels (GOTO destinations) should always be decimal.
     164/       0 :                     ;
     165/       0 :                     ;	Space between GO and TO might be forgiven.
     166/       0 :                     ;
     167/       0 :                     ;	Certain commands might be disallowed in each operating mode:
     168/       0 :                     ;	No LIST in execution, no INPUT in interactive, for instance.
     169/       0 :                     ;	Some commands (FOR, GOTO, RETURN, etc.) must be last command in line.
     170/       0 :                     ;
     171/       0 :                     ;	GETLN could be made somewhat more abstract, so that L_INIT and READ_C
     172/       0 :                     ;	return characters from edited line buffer in interactive mode and
     173/       0 :                     ;	code buffer in execution mode.  Dual execution loops in main IL program
     174/       0 :                     ;	can then be combined.  (Line insertion should default when no keyword
     175/       0 :                     ;	tokens would be detected during parsing.)
     176/       0 :                     ;
     177/       0 :                     ;	Get rid of LIST and FNDLBL kludge which falsely sets RUNFLG to fool
     178/       0 :                     ;	READ_C subroutine.
     179/       0 :                     ;
     180/       0 :                     ;	Sequential string testing (command parsing, operator recognition, etc.)
     181/       0 :                     ;	could be made table-driven, eliminating repeated "CALL TST"s.
     182/       0 :                     ;
     183/       0 :                     ;	All data structures need to be better defined in listing.
     184/       0 :                     ;	It would be a wise exercize to gather each 
     185/       0 :                     ;	data-structure definition/declaration/accessing-routine set
     186/       0 :                     ;	into isolated functional modules (like objects),
     187/       0 :                     ;	with communication only via global variables.
     188/       0 :                     
     189/       0 :                     ;
     190/       0 :                     ;$EJECT
     191/       0 :                     ;
     192/       0 :                     ;	GLOBAL VARIABLE AND DATA STRUCTURE DECLARATIONS:
     193/       0 :                     ;	====== ======== === ==== ========= ============
     194/       0 :                     ;
     195/       0 :                     ;	Intended System Configuration Constants:
     196/       0 :                     ;
     197/       0 : =2034H              EXTRAM	EQU	2034H		;External program buffer begins after 26 vars.
     198/       0 : =3000H              RAMLIM	EQU	3000H		;Allowance made for 4K RAM buffer.
     199/       0 : =1080H              EXTROM	EQU	1080H		;Start of external ROM space.
     200/       0 : =8H                 TABSIZ	EQU	8		;Formatted column spacing.
     201/       0 : =24H                AESLEN	EQU	36		;AES Length.
     202/       0 :                     ;
     203/       0 :                     ;	Working Register Definitions.
     204/       0 :                     ;
     205/       0 :                     #define	PNTR_L	R0
     206/       0 :                     		;Program buffer pointer.
     207/       0 :                     #define	DEST_L	R1
     208/       0 :                     		;Destination pointer for line insertion.
     209/       0 :                     #define	PNTR_H	R2
     210/       0 :                     		;High-order pointer byte (temp. cursor)
     211/       0 :                     #define	DEST_H	R3
     212/       0 :                     
     213/       0 :                     #define	CHAR	R4
     214/       0 :                     		;BASIC source string character being parsed.
     215/       0 :                     #define	LP_CNT	R5
     216/       0 :                     
     217/       0 :                     #define	TOS_L	R6
     218/       0 :                     #define	TOS_H	R7
     219/       0 :                     		;Variable popped from stack for math routines.
     220/       0 :                     ;
     221/      30 :                     	segment	DATA
     222/       8 :                     	ORG	08H
     223/       8 :                     ;
     224/       8 :                     ;	Temporary variables used by IDIV routine.
     225/       8 :                     ;
     226/       8 :                     TMP0:	DS	1
     227/       9 :                     TMP1:	DS	1
     228/       A :                     TMP2:	DS	1
     229/       B :                     TMP3:	DS	1
     230/       C :                     TMP4:	DS	1
     231/       D :                     ;
     232/       D :                     ;	Random number key.
     233/       D :                     ;
     234/       D :                     SEED_L:	DS	1
     235/       E :                     SEED_H:	DS	1
     236/       F :                     ;
     237/       F :                     ;
     238/       F :                     STRLEN:	DS	1		;Length of text string in L_BUF.
     239/      10 :                     ;
     240/      10 :                     ;US_VAR		User Variable (A,B,...) Array:
     241/      10 :                     ;
     242/      10 : =CH                 NO_VAR	EQU	12		;Allow 12 internal variables A - L.
     243/      10 :                     US_VAR:	DS	2*NO_VAR	;Allocate variable storage space.
     244/      28 :                     ;
     245/      28 : =28H                MODE:	SFR	$
     246/      28 :                     	DS	1		;Operating mode bits.
     247/      29 : =40                 EXTVAR	BIT	MODE.0		;Set when BASIC variables in external RAM.
     248/      29 : =41                 ROMMOD	BIT	MODE.1		;Set when BASIC programs executed from ROM.
     249/      29 : =42                 EXTMOD	BIT	MODE.2		;Set when BASIC programs fetched externally.
     250/      29 : =43                 RUNMOD	BIT	MODE.3		;Set when stored BASIC program is running.
     251/      29 : =44                 HEXMOD	BIT	MODE.4		;Set when operations should use HEX radix.
     252/      29 :                     ;
     253/      29 : =29H                FLAGS:	SFR	$
     254/      29 :                     	DS	1		;Interroutine communication flags.
     255/      2A : =48                 ZERSUP	BIT	FLAGS.0		;If set, suppress printing leading zeroes.
     256/      2A : =49                 CHAR_FLG	BIT	FLAGS.1		;Set when CHAR has not been processed.
     257/      2A : =4A                 SGN_FLG	BIT	FLAGS.2		;Keeps track of operand(s) sign during math.
     258/      2A : =4B                 SEQ_FLG	BIT	FLAGS.3		;
     259/      2A : =4C                 MOD_FLG	BIT	FLAGS.4		;Set if divide routine should return MOD value.
     260/      2A : =4D                 H_FLG	BIT	FLAGS.5		;Used to sense allow 'H' suffix in HEX mode.
     261/      2A :                     ;
     262/      2A :                     ;AES	Arithmetic Expression Stack.
     263/      2A :                     ;
     264/      2A :                     AESP:	DS	1		;AES Stack Pointer
     265/      2B :                     AES:	DS	AESLEN		;Buffer allocation.
     266/      4F :                     ;
     267/      4F :                     ;
     268/      4F :                     ;	Line Buffer Variables:
     269/      4F :                     L_CURS:	DS	1		;Cursor for line buffer.
     270/      50 :                     ;
     271/      50 :                     TABCNT:	DS	1		;Column formatting count.
     272/      51 :                     ;
     273/      51 :                     ;CURSOR	Source line cursor.
     274/      51 :                     CURS_L:	DS	1
     275/      52 :                     CURS_H:	DS	1
     276/      53 :                     C_SAVE:	DS	1		;CHAR saved during SAVE_PNTR.
     277/      54 :                     ;
     278/      54 :                     LABL_L:	DS	1		;BASIC program source line counter.
     279/      55 :                     LABL_H:	DS	1		;  "       "       "     high byte.
     280/      56 :                     ;
     281/      56 : =55H                SP_BASE	EQU	$-1		;Initialization value for hardware SP.
     282/      56 :                     ;
     283/      56 : =DH                 CR	EQU	0DH		;ASCII CODE FOR <CARRIAGE RETURN>.
     284/      56 : =AH                 LF	EQU	0AH		;  "    "    "  <LINE FEED>.
     285/      56 : =7H                 BEL	EQU	07H		;  "    "    "  <BELL>.
     286/      56 :                     ;
     287/      56 :                     ;$EJECT
     288/      56 :                     ;$SAVE NOGEN
     289/      56 :                     ;
     290/       0 :                     	segment	CODE
     291/       0 :                     	ORG	0
     292/       0 : 80 24               	JMP	S_INIT		;Jump to system initialization routine.
     293/       2 :                     ;
     294/       2 :                     ;	Interrupt routine expansion hooks:
     295/       2 :                     ;
     296/       3 :                             ORG     0003H
     297/       3 : 02 10 03            DD012:  JMP     1003H           ;External interrupt 0 service routine.
     298/       6 :                     ;
     299/       6 : 00 00 00 00 00              DB      0,0,0,0,0
     300/       B :                             ORG     000BH
     301/       B : 02 10 0B            DD014:  JMP     100BH           ;Timer 0 service routine.
     302/       E :                     ;
     303/       E : 00 00 00 00 00              DB      0,0,0,0,0
     304/      13 :                             ORG     0013H
     305/      13 : 02 10 13            DD016:  JMP     1013H           ;External interrupt 1 service routine.
     306/      16 :                     ;
     307/      16 : 00 00 00 00 00              DB      0,0,0,0,0
     308/      1B :                             ORG     001BH
     309/      1B : 02 10 1B            DD018:  JMP     101BH           ;Timer 1 service routine.
     310/      1E :                     ;
     311/      1E : 00 00 00 00 00              DB      0,0,0,0,0
     312/      23 :                             ORG     0023H
     313/      23 : 02 10 23            DD020:  JMP     1023H           ;Serial port interrupt service routine.
     314/      26 :                     ;
     315/      26 :                     ;$EJECT
     316/      26 :                     ;
     317/      26 :                     ;	CONSOLE I/O ROUTINES AND DRIVERS:
     318/      26 :                     ;	======= === ======== === =======
     319/      26 :                     ;
     320/      26 : E4                  S_INIT:	CLR	A
     321/      27 : F5 D0               	MOV	PSW,A
     322/      29 : F5 0E               	MOV	SEED_H,A
     323/      2B : F5 0D               	MOV	SEED_L,A
     324/      2D : 75 81 55            	MOV	SP,#SP_BASE	;Re-initialize hardware stack.
     325/      30 : F1 2E               	CALL	RAM_INIT	;Clear-out variable RAM.
     326/      32 : 30 B0 5B            SP_INI:	JNB	RXD,RUNROM
     327/      35 : C2 8E               	CLR	TR1
     328/      37 : 75 98 5A            	MOV	SCON,#01011010B	;TI set indicates transmitter ready.
     329/      3A : 75 89 21            	MOV	TMOD,#00100001B	;Timer 1 is set to auto-reload timer mode.
     330/      3D : 75 8D 00            	MOV	TH1,#0		;Assume fastest rate.
     331/      40 : 78 90               	MOV	R0,#144
     332/      42 : 20 B0 FD            	JB	RXD,$
     333/      45 : D8 FE               BAUDID:	DJNZ	R0,$
     334/      47 : 15 8D               	DEC	TH1
     335/      49 : 78 5E               	MOV	R0,#94
     336/      4B : 30 B0 F7            	JNB	RXD,BAUDID
     337/      4E : 20 B0 FD            	JB	RXD,$		;Hang-up here until space char. over.
     338/      51 : 30 B0 FD            	JNB	RXD,$
     339/      54 : D2 8E               	SETB	TR1
     340/      56 : 31 05               	CALL	STROUT
     341/      58 : 0D 4D 43 53 2D 35           DB      CR,"MCS-51 TINY BASIC/AS Porting from TB51ML23.ZIP V"
                    31 20 54 49 4E 59 
                    20 42 41 53 49 43 
                    2F 41 53 20 50 6F 
                    72 74 69 6E 67 20 
                    66 72 6F 6D 20 54 
                    42 35 31 4D 4C 32 
                    33 2E 5A 49 50 20 
                    56 
     342/      89 : 32 2E 33 8D                 DB      ('0'+VERS/10H),".",('0'+(VERS AND 0FH)),(CR OR  80H)
     343/      8D : 02 08 7B            	JMP	START
     344/      90 :                     ;
     345/      90 : D2 42               RUNROM:	SETB	EXTMOD
     346/      92 : D2 41               	SETB	ROMMOD
     347/      94 : 02 08 9C            	JMP	XEC
     348/      97 :                     ;
     349/      97 :                     ;=======
     350/      97 :                     ;
     351/      97 :                     C_IN:
     352/      97 :                     ;	Console character input routine.
     353/      97 :                     ;	Waits for next input from console device and returns with character
     354/      97 :                     ;	code in accumulator.
     355/      97 :                     ;	If character is <CNTRL-C> process syntax error.
     356/      97 :                     ;	Adjust lower-case alphabetics to upper case.
     357/      97 :                     ;
     358/      97 : 30 98 FD            DD005:  JNB     RI,$            ;Wait until character received.
     359/      9A : E5 99                       MOV     A,SBUF          ;Read input character.
     360/      9C : C2 98               	CLR	RI		;Clear reception flag.
     361/      9E : 54 7F               	ANL	A,#7FH		;Mask off data bits.
     362/      A0 : B4 03 02            	CJNE	A,#03H,C_IN_2	;Test for CNTRL-C code.
     363/      A3 : 21 2E               	JMP	SYN_ER		;Abort if detected.
     364/      A5 :                     ;
     365/      A5 : B4 61 00            C_IN_2:	CJNE	A,#'a',$+3	;Check for lower-case alphabetics.
     366/      A8 : 40 07               	JC	C_IN_1
     367/      AA : B4 7B 00            	CJNE	A,#'z'+1,$+3
     368/      AD : 50 02               	JNC	C_IN_1
     369/      AF : 54 DF               	ANL	A,#11011111B	;Force upper-case code.
     370/      B1 : 22                  C_IN_1:	RET			;Return to calling routine.
     371/      B2 :                     ;
     372/      B2 :                     ;=======
     373/      B2 :                     ;
     374/      B2 :                     ;
     375/      B2 :                     NLINE:
     376/      B2 :                     ;	Transmit <CR><LF> sequence to console device.
     377/      B2 :                     ;
     378/      B2 : 74 0D               	MOV	A,#CR
     379/      B4 :                     C_OUT:
     380/      B4 :                     ;	Console character output routine.
     381/      B4 :                     ;	Outputs character received in accumulator to console output device.
     382/      B4 :                     ;
     383/      B4 : 30 99 FD            DD006:  JNB     TI,$            ;Wait until transmission completed.
     384/      B7 : C2 99               DD007:  CLR     TI              ;Clear interrupt flag.
     385/      B9 : F5 99               	MOV	SBUF,A		;Write out character.
     386/      BB : B4 0D 0A            	CJNE	A,#CR,COUT_2
     387/      BE : 30 99 FD            DD008:  JNB     TI,$
     388/      C1 : C2 99               DD009:  CLR     TI
     389/      C3 : 75 99 0A            	MOV	SBUF,#LF	;Output linefeed.
     390/      C6 : 80 04               	SJMP	COUT_3
     391/      C8 :                     ;
     392/      C8 : C3                  COUT_2:	CLR	C
     393/      C9 : D5 50 04            	DJNZ	TABCNT,COUT_1	;Monitor output field position.
     394/      CC : 75 50 08            COUT_3:	MOV	TABCNT,#TABSIZ	;Reload field counter.
     395/      CF : D3                  	SETB	C
     396/      D0 : 22                  COUT_1:	RET
     397/      D1 :                     ;
     398/      D1 :                     ;=======
     399/      D1 :                     ;
     400/      D1 :                     ;
     401/      D1 : 30 98 0A            CNTRL:	JNB	RI,CNTRET	;Poll whether character has been typed.
     402/      D4 : 11 97               	CALL	C_IN
     403/      D6 : B4 13 05            	CJNE	A,#13H,CNTRET	;Check if char. is <CNTRL-S>.
     404/      D9 : 11 97               CNTR_2:	CALL	C_IN		;If so, hang up...
     405/      DB : B4 11 FB            	CJNE	A,#11H,CNTR_2	;    ...until <CNTRL-Q> received.
     406/      DE : 22                  CNTRET:	RET
     407/      DF :                     ;
     408/      DF :                     ;=======
     409/      DF :                     ;
     410/      DF :                     ;
     411/      DF :                     SPC:
     412/      DF :                     ;	Transmit one or more space characters to console to move console
     413/      DF :                     ;	cursor to start of next field.
     414/      DF :                     ;
     415/      DF : 74 20               	MOV	A,#' '	;Load ASCII code for space character.
     416/      E1 : 11 B4               	CALL	C_OUT
     417/      E3 : 50 FA               	JNC	SPC		;Repeat until at TAB boundary.
     418/      E5 : 22                  	RET
     419/      E6 :                     ;
     420/      E6 :                     ;===============
     421/      E6 :                     ;
     422/      E6 :                     ;NIBOUT
     423/      E6 :                     ;	If low-order nibble in Acc. is non-zero or ZERSUP flag is cleared,
     424/      E6 :                     ;	output the corresponding ASCII value and clear ZERSUP flag.
     425/      E6 :                     ;	Otherwise return without affecting output or ZERSUP.
     426/      E6 :                     ;
     427/      E6 : 54 0F               NIBOUT:	ANL	A,#0FH		;Mask out low-order bits.
     428/      E8 : 70 03               	JNZ	NIBO_2		;Output ASCII code for Acc contents.
     429/      EA : 20 48 07            	JB	ZERSUP,NIBO_3
     430/      ED : C2 48               NIBO_2:	CLR	ZERSUP		;Mark that non-zero character encountered.
     431/      EF : 24 03               	ADD	A,#(ASCTBL-(NIBO_1+1))	;Offset to start of table.
     432/      F1 : 83                  NIBO_1:	MOVC	A,@A+PC		;Look up corresponding code.
     433/      F2 : 11 B4               	CALL	C_OUT		;Output character.
     434/      F4 : 22                  NIBO_3:	RET
     435/      F5 :                     ;
     436/      F5 : 30 31 32 33 34 35   ASCTBL:	DB	"0123456789ABCDEF"
                    36 37 38 39 41 42 
                    43 44 45 46 
     437/     105 :                     ;
     438/     105 :                     ;=======
     439/     105 :                     ;
     440/     105 :                     ;STROUT
     441/     105 :                     ;	Copy in-line character string to console output device.
     442/     105 :                     ;
     443/     105 : D0 83               STROUT:	POP	DPH		;Access in-line string.
     444/     107 : D0 82               	POP	DPL
     445/     109 : E4                  STRO_1:	CLR	A
     446/     10A : 93                  	MOVC	A,@A+DPTR	;Read next byte.
     447/     10B : A3                  	INC	DPTR		;Bump pointer.
     448/     10C : 10 E7 04            	JBC	ACC.7,STRO_2	;Escape after last character.
     449/     10F : 11 B4               	CALL	C_OUT		;Output character.
     450/     111 : 80 F6               	SJMP	STRO_1		;Loop until done.
     451/     113 :                     ;
     452/     113 : 11 B4               STRO_2:	CALL	C_OUT		;Output character.
     453/     115 : E4                  	CLR	A
     454/     116 : 73                  	JMP	@A+DPTR		;Return to program.
     455/     117 :                     ;
     456/     117 :                     ;=======
     457/     117 :                     ;$EJECT
     458/     117 :                     ERROUT:
     459/     117 :                     ;	Error handling routine common entry point. 
     460/     117 :                     ;	(Could retype bad line, etc.)
     461/     117 :                     ;
     462/     117 : 02 08 7E            	JMP	ERRENT		;Return to executive.
     463/     11A :                     ;
     464/     11A :                     ;=======
     465/     11A :                     ;
     466/     11A :                     ;EXP_ER	Expression evaluation error.
     467/     11A : 31 05               EXP_ER:	CALL	STROUT		;Output error message.
     468/     11C : 48 4F 57 3F 8D              DB      "HOW?",(CR OR 80H)
     469/     121 : 80 F4               	JMP	ERROUT		;Return to executive.
     470/     123 :                     ;
     471/     123 :                     ;=======
     472/     123 :                     ;
     473/     123 :                     ;AES_ER	Arithmetic expression stack error handling routine.
     474/     123 : 31 05               AES_ER:	CALL	STROUT		;Output error message.
     475/     125 : 53 4F 52 52 59 21           DB      "SORRY!",(CR OR 80H)
                    8D 
     476/     12C : 80 E9               	JMP	ERROUT		;Return to executive.
     477/     12E :                     ;
     478/     12E :                     ;
     479/     12E :                     ;=======
     480/     12E :                     ;
     481/     12E :                     ;SYN_ER	Syntax error handling routine.
     482/     12E : 31 05               SYN_ER:	CALL	STROUT		;Output error message.
     483/     130 : 0D 57 48 41 54 3F           DB      CR,"WHAT?",(CR OR 80H)
                    8D 
     484/     137 : 80 DE               	JMP	ERROUT		;Process error.
     485/     139 :                     ;
     486/     139 :                     ;=======
     487/     139 :                     ;$EJECT
     488/     139 :                     
     489/     139 :                     ;
     490/     139 :                     ;	ARITHMETIC SUBROUTINE PACKAGE  (8/12/80)
     491/     139 :                     ;
     492/     139 :                     ;=======
     493/     139 :                     ;
     494/     139 :                     POP_TOS:
     495/     139 :                     ;	Verify that stack holds at least on (16-bit) entry.
     496/     139 :                     ;	(Call AES_ER otherwise.)
     497/     139 :                     ;	Pop TOS into registers TOS_H and TOS_L,
     498/     139 :                     ;	update AESP,
     499/     139 :                     ;	and return with R1 pointing to low-order byte of previous NOS.
     500/     139 :                     ;	Do not affect accumulator contents.
     501/     139 :                     ;
     502/     139 : A9 2A               	MOV	R1,AESP
     503/     13B : B9 2C 00            	CJNE	R1,#AES+1,$+3	;Compare pointer with min. legal level.
     504/     13E : 40 21               	JC	STK_ER
     505/     140 : FE                  	MOV	TOS_L,A
     506/     141 : E7                  	MOV	A,@R1
     507/     142 : FF                  	MOV	TOS_H,A
     508/     143 : 19                  	DEC	R1
     509/     144 : E7                  	MOV	A,@R1
     510/     145 : CE                  	XCH	A,TOS_L		;Store byte and reload ACC.
     511/     146 : 19                  	DEC	R1
     512/     147 : 89 2A               	MOV	AESP,R1
     513/     149 : 19                  	DEC	R1
     514/     14A : 22                  	RET
     515/     14B :                     ;
     516/     14B :                     ;=======
     517/     14B :                     ;
     518/     14B :                     POP_ACC:
     519/     14B :                     ;	Pop TOS into accumulator and update AESP.
     520/     14B :                     ;
     521/     14B : A9 2A               	MOV	R1,AESP
     522/     14D : E7                  	MOV	A,@R1
     523/     14E : 15 2A               	DEC	AESP
     524/     150 : 22                  	RET
     525/     151 :                     ;
     526/     151 :                     ;=======
     527/     151 :                     ;
     528/     151 :                     PUSH_TOS:
     529/     151 :                     ;	Verify that the AES is not full,
     530/     151 :                     ;	push registers TOS_H and TOS_L onto AES,
     531/     151 :                     ;	and update AESP.
     532/     151 :                     ;
     533/     151 : A9 2A               	MOV	R1,AESP
     534/     153 : B9 4D 00            	CJNE	R1,#AES+AESLEN-2,$+3	;Compare pointer with max. legal level.
     535/     156 : 50 09               	JNC	STK_ER
     536/     158 : 09                  	INC	R1
     537/     159 : EE                  	MOV	A,TOS_L		;Push low-order byte.
     538/     15A : F7                  	MOV	@R1,A
     539/     15B : 09                  	INC	R1
     540/     15C : EF                  	MOV	A,TOS_H		;Push high-order byte.
     541/     15D : F7                  	MOV	@R1,A
     542/     15E : 89 2A               	MOV	AESP,R1
     543/     160 : 22                  	RET
     544/     161 :                     ;
     545/     161 : 31 23               STK_ER:	CALL	AES_ER
     546/     163 : 0F                  	DB	0FH
     547/     164 :                     ;
     548/     164 :                     ;=======
     549/     164 :                     ;
     550/     164 :                     ;
     551/     164 :                     DUPL:
     552/     164 :                     ;	Verify that the AES is not full,
     553/     164 :                     ;	then duplicate the top element and update AESP.
     554/     164 :                     ;
     555/     164 : A9 2A               	MOV	R1,AESP
     556/     166 : B9 4D 00            	CJNE	R1,#AES+AESLEN-2,$+3	;Compare pointer with max. legal level.
     557/     169 : 50 F6               	JNC	STK_ER
     558/     16B : 19                  	DEC	R1
     559/     16C : E7                  	MOV	A,@R1
     560/     16D : 09                  	INC	R1
     561/     16E : 87 F0               	MOV	B,@R1
     562/     170 : 09                  	INC	R1
     563/     171 : F7                  	MOV	@R1,A			;Push low-order byte.
     564/     172 : 09                  	INC	R1
     565/     173 : A7 F0               	MOV	@R1,B
     566/     175 : 89 2A               	MOV	AESP,R1
     567/     177 : 22                  	RET
     568/     178 :                     ;
     569/     178 :                     ;=======
     570/     178 :                     ;
     571/     178 :                     ;LIT	(K)
     572/     178 :                     ;	Report error if arithmetic expression stack is full.
     573/     178 :                     ;	Otherwise push the one-byte constant K onto AES.
     574/     178 :                     ;	Return with carry=1, since LIT marks a successful match.
     575/     178 :                     ;
     576/     178 : D0 83               LIT:	POP	DPH		;Get parameter address.
     577/     17A : D0 82               	POP	DPL
     578/     17C : E4                  	CLR	A
     579/     17D : 93                  	MOVC	A,@A+DPTR	;Read literal value.
     580/     17E : 05 2A               	INC	AESP		;Reserve storage on top of AES.
     581/     180 : A9 2A               	MOV	R1,AESP		;Point to free entry on stack.
     582/     182 : B9 4F 02            	CJNE	R1,#AES+AESLEN,LIT_1
     583/     185 : 80 9C               	JMP	AES_ER
     584/     187 :                     ;
     585/     187 : F7                  LIT_1:	MOV	@R1,A		;Store literal.
     586/     188 : 74 01               	MOV	A,#1		;Branch over constant on return.
     587/     18A : D3                  	SETB	C
     588/     18B : 73                  	JMP	@A+DPTR		;Return to IL program.
     589/     18C :                     ;
     590/     18C :                     ;=======
     591/     18C :                     ;$EJECT
     592/     18C :                     ;
     593/     18C :                     ;	BASIC VARIABLE ACCESSING OPERATIONS  (8/20/80)
     594/     18C :                     ;	===== ======== ========= ==========
     595/     18C :                     ;
     596/     18C :                     ;
     597/     18C :                     ;	Direct address mode emulation tables:
     598/     18C :                     ;
     599/     18C : 80                  SFRTBL:	DB	80H
     600/     18D : 90                  	DB	90H
     601/     18E : A0                  	DB	0A0H
     602/     18F : B0                  	DB	0B0H
     603/     190 : 88                  	DB	88H
     604/     191 : 98                  	DB	98H
     605/     192 : A8                  	DB	0A8H
     606/     193 : B8                  	DB	0B8H
     607/     194 : 89                  	DB	89H
     608/     195 : 8A                  	DB	8AH
     609/     196 : 8B                  	DB	8BH
     610/     197 : 8C                  	DB	8CH
     611/     198 : 8D                  	DB	8DH
     612/     199 : 99                  	DB	99H
     613/     19A : =EH                 NO_SFR	EQU	$-SFRTBL
     614/     19A :                     ;
     615/     19A :                     ;===
     616/     19A :                     ;
     617/     19A : 8E 80               STRTBL:	MOV	80H,TOS_L
     618/     19C : 22                  	RET
     619/     19D : 8E 90               	MOV	90H,TOS_L
     620/     19F : 22                  	RET
     621/     1A0 : 8E A0               	MOV	0A0H,TOS_L
     622/     1A2 : 22                  	RET
     623/     1A3 : 8E B0               	MOV	0B0H,TOS_L
     624/     1A5 : 22                  	RET
     625/     1A6 : 8E 88               	MOV	88H,TOS_L
     626/     1A8 : 22                  	RET
     627/     1A9 : 8E 98               	MOV	98H,TOS_L
     628/     1AB : 22                  	RET
     629/     1AC : 8E A8               	MOV	0A8H,TOS_L
     630/     1AE : 22                  	RET
     631/     1AF : 8E B8               	MOV	0B8H,TOS_L
     632/     1B1 : 22                  	RET
     633/     1B2 : 8E 89               	MOV	89H,TOS_L
     634/     1B4 : 22                  	RET
     635/     1B5 : 8E 8A               	MOV	8AH,TOS_L
     636/     1B7 : 22                  	RET
     637/     1B8 : 8E 8B               	MOV	8BH,TOS_L
     638/     1BA : 22                  	RET
     639/     1BB : 8E 8C               	MOV	8CH,TOS_L
     640/     1BD : 22                  	RET
     641/     1BE : 8E 8D               	MOV	8DH,TOS_L
     642/     1C0 : 22                  	RET
     643/     1C1 : 8E 99               	MOV	99H,TOS_L
     644/     1C3 : 22                  	RET
     645/     1C4 :                     ;
     646/     1C4 :                     ;===
     647/     1C4 :                     ;
     648/     1C4 : E5 80               INDTBL:	MOV	A,80H
     649/     1C6 : 22                  	RET
     650/     1C7 : E5 90               	MOV	A,90H
     651/     1C9 : 22                  	RET
     652/     1CA : E5 A0               	MOV	A,0A0H
     653/     1CC : 22                  	RET
     654/     1CD : E5 B0               	MOV	A,0B0H
     655/     1CF : 22                  	RET
     656/     1D0 : E5 88               	MOV	A,88H
     657/     1D2 : 22                  	RET
     658/     1D3 : E5 98               	MOV	A,98H
     659/     1D5 : 22                  	RET
     660/     1D6 : E5 A8               	MOV	A,0A8H
     661/     1D8 : 22                  	RET
     662/     1D9 : E5 B8               	MOV	A,0B8H
     663/     1DB : 22                  	RET
     664/     1DC : E5 89               	MOV	A,89H
     665/     1DE : 22                  	RET
     666/     1DF : E5 8A               	MOV	A,8AH
     667/     1E1 : 22                  	RET
     668/     1E2 : E5 8B               	MOV	A,8BH
     669/     1E4 : 22                  	RET
     670/     1E5 : E5 8C               	MOV	A,8CH
     671/     1E7 : 22                  	RET
     672/     1E8 : E5 8D               	MOV	A,8DH
     673/     1EA : 22                  	RET
     674/     1EB : E5 99               	MOV	A,99H
     675/     1ED : 22                  	RET
     676/     1EE :                     ;
     677/     1EE :                     ;$EJECT
     678/     1EE :                     SFR_ID:
     679/     1EE :                     ;	Identify which SFR is indicated by the contents of R1.
     680/     1EE :                     ;	Return with acc holding (Index of said register)*3.
     681/     1EE :                     ;	Call error routine if register number not found.
     682/     1EE :                     ;
     683/     1EE : 90 01 8C            	MOV	DPTR,#SFRTBL
     684/     1F1 : E4                  	CLR	A
     685/     1F2 : FD                  	MOV	LP_CNT,A
     686/     1F3 : ED                  SFID_1:	MOV	A,LP_CNT
     687/     1F4 : 93                  	MOVC	A,@A+DPTR
     688/     1F5 : 69                  	XRL	A,R1
     689/     1F6 : 70 04               	JNZ	SFID_2
     690/     1F8 : ED                  	MOV	A,LP_CNT
     691/     1F9 : 23                  	RL	A
     692/     1FA : 2D                  	ADD	A,LP_CNT
     693/     1FB : 22                  	RET
     694/     1FC :                     ;
     695/     1FC : 0D                  SFID_2:	INC	LP_CNT
     696/     1FD : ED                  	MOV	A,LP_CNT
     697/     1FE : B4 0E F2            	CJNE	A,#NO_SFR,SFID_1
     698/     201 : 21 1A               ADR_ER:	JMP	EXP_ER
     699/     203 :                     ;
     700/     203 :                     ;=======
     701/     203 :                     ;
     702/     203 :                     STRDIR:
     703/     203 :                     ;	Store data byte in ACC into direct on-chip RAM address held in R1.
     704/     203 :                     ;
     705/     203 : FE                  	MOV	TOS_L,A
     706/     204 : E9                  	MOV	A,R1
     707/     205 : 20 E7 03            	JB	ACC.7,STRSFR	;Direct addresses above 7FH are SFRs.
     708/     208 : EE                  	MOV	A,TOS_L
     709/     209 : F7                  	MOV	@R1,A		;Store low-order byte in RAM.
     710/     20A : 22                  	RET
     711/     20B :                     ;
     712/     20B : 31 EE               STRSFR:	CALL	SFR_ID
     713/     20D : 90 01 9A            	MOV	DPTR,#STRTBL
     714/     210 : 73                  	JMP	@A+DPTR		;Jump into store sequence.
     715/     211 :                     ;
     716/     211 :                     ;=======
     717/     211 :                     ;
     718/     211 :                     FETDIR:
     719/     211 :                     ;	Fetch on-chip directly addressed byte indicated by R1 into Acc. 
     720/     211 :                     ;	and return.
     721/     211 :                     ;
     722/     211 : E9                  	MOV	A,R1
     723/     212 : 20 E7 02            	JB	ACC.7,FETSFR
     724/     215 : E7                  	MOV	A,@R1
     725/     216 : 22                  	RET
     726/     217 :                     ;
     727/     217 : 31 EE               FETSFR:	CALL	SFR_ID
     728/     219 : 90 01 C4            	MOV	DPTR,#INDTBL
     729/     21C : 73                  	JMP	@A+DPTR
     730/     21D :                     ;
     731/     21D :                     ;=======
     732/     21D :                     ;
     733/     21D :                     SPLIT_DBA:
     734/     21D :                     ;	Called with TOS_L containing a direct on-chip bit address.
     735/     21D :                     ;	Return the direct &byte& address of encompassing 
     736/     21D :                     ;	register in R1, and load B with a mask containing a single 1 
     737/     21D :                     ;	corresponding to the bit's position in a field of zeroes.
     738/     21D :                     ;
     739/     21D : EE                  	MOV	A,TOS_L
     740/     21E : 54 F8               	ANL	A,#11111000B
     741/     220 : 20 E7 04            	JB	ACC.7,SPLSFR
     742/     223 : 23                  	RL	A
     743/     224 : C4                  	SWAP	A
     744/     225 : 24 20               	ADD	A,#20H		;Address of bit-address space.
     745/     227 : F9                  SPLSFR:	MOV	R1,A
     746/     228 : EE                  	MOV	A,TOS_L
     747/     229 : 54 07               	ANL	A,#07H		;Mask off bit-displacement field.
     748/     22B : 24 03               	ADD	A,#MSKTBL-MSK_PC
     749/     22D : 83                  	MOVC	A,@A+PC		;Read mask byte.
     750/     22E :                     MSK_PC:
     751/     22E : F5 F0               	MOV	B,A
     752/     230 : 22                  	RET
     753/     231 :                     ;
     754/     231 : 01                  MSKTBL:	DB	00000001B
     755/     232 : 02                  	DB	00000010B
     756/     233 : 04                  	DB	00000100B
     757/     234 : 08                  	DB	00001000B
     758/     235 : 10                  	DB	00010000B
     759/     236 : 20                  	DB	00100000B
     760/     237 : 40                  	DB	01000000B
     761/     238 : 80                  	DB	10000000B
     762/     239 :                     ;
     763/     239 :                     ;=======
     764/     239 :                     ;
     765/     239 :                     ;
     766/     239 :                     SEQ_STORE:
     767/     239 :                     ;	Same as STORE, below, except that index is retained
     768/     239 :                     ;	rather than being popped.
     769/     239 : D2 4B               	SETB	SEQ_FLG
     770/     23B : 80 02               	SJMP	STOR_0
     771/     23D :                     ;
     772/     23D :                     ;
     773/     23D :                     STORE:
     774/     23D :                     ;	When STORE is called, AES contains
     775/     23D :                     ;	(TOS:)	2 byte VALUE to be stored,
     776/     23D :                     ;		2 byte INDEX of destination variable,
     777/     23D :                     ;		1 byte TYPE code for variable space.
     778/     23D :                     ;			(0=BASIC variable,
     779/     23D :                     ;			 1=DBYTE,
     780/     23D :                     ;			 2=RBIT,
     781/     23D :                     ;			 3=XBYTE,
     782/     23D :                     ;			 4=CBYTE.)
     783/     23D :                     ;	Store (VAR_1) into appropriate variable memory at location of (INDEX).
     784/     23D :                     ;
     785/     23D : C2 4B               	CLR	SEQ_FLG
     786/     23F : 31 39               STOR_0:	CALL	POP_TOS
     787/     241 : 8E 08               	MOV	TMP0,TOS_L
     788/     243 : 8F 09               	MOV	TMP1,TOS_H
     789/     245 : 31 39               	CALL	POP_TOS
     790/     247 : 31 4B               	CALL	POP_ACC		;Load TYPE code.
     791/     249 : 30 4B 06            	JNB	SEQ_FLG,STOR_1	;Jump forward if simple store.
     792/     24C : 05 2A               	INC	AESP
     793/     24E : 05 2A               	INC	AESP
     794/     250 : 05 2A               	INC	AESP
     795/     252 : 90 02 57            STOR_1:	MOV	DPTR,#STRJTB
     796/     255 : 93                  	MOVC	A,@A+DPTR
     797/     256 : 73                  	JMP	@A+DPTR
     798/     257 :                     ;
     799/     257 : 05                  STRJTB:	DB	STRVAR-STRJTB
     800/     258 : 23                  	DB	STRDBY-STRJTB
     801/     259 : 29                  	DB	STRRBI-STRJTB
     802/     25A : 3E                  	DB	STRXBY-STRJTB
     803/     25B : 3E                  	DB	STRCBY-STRJTB
     804/     25C :                     ;
     805/     25C :                     ;=======
     806/     25C :                     ;
     807/     25C :                     ;	All of the following routines are called with 
     808/     25C :                     ;	TOS_L holding the low-order address of the destination,
     809/     25C :                     ;	TOS_H holding the high-order address (if necessary),
     810/     25C :                     ;	and <TMP1><TMP0> holding the 8- or 16-bit data to be stored.
     811/     25C :                     ;
     812/     25C : EE                  STRVAR:	MOV	A,TOS_L
     813/     25D : 23                  	RL	A		;Multiply by two for 2 byte variables.
     814/     25E : 20 40 0D            	JB	EXTVAR,STREXT	;Branch if vars in external RAM.
     815/     261 : 24 10               	ADD	A,#US_VAR	;Offset for variable array.
     816/     263 : F9                  	MOV	R1,A
     817/     264 : 24 D9               	ADD	A,#-(US_VAR+2*NO_VAR-1)	;Compare with maximum legal address.
     818/     266 : 40 99               	JC	ADR_ER
     819/     268 : A7 08               	MOV	@R1,TMP0
     820/     26A : 09                  	INC	R1
     821/     26B : A7 09               	MOV	@R1,TMP1
     822/     26D : 22                  	RET
     823/     26E :                     ;
     824/     26E : F9                  STREXT:	MOV	R1,A
     825/     26F : 75 A0 20            DD001:  MOV     P2,#(EXTRAM >> 8)
     826/     272 : E5 08                       MOV     A,TMP0
     827/     274 : F3                  	MOVX	@R1,A
     828/     275 : 09                  	INC	R1		;Bump pointers.
     829/     276 : E5 09               	MOV	A,TMP1		;Move high-order byte into variable array.
     830/     278 : F3                  	MOVX	@R1,A
     831/     279 : 22                  	RET
     832/     27A :                     ;
     833/     27A :                     ;===
     834/     27A :                     ;
     835/     27A : EE                  STRDBY:	MOV	A,TOS_L		;Load acc. with low-order dest. addr.
     836/     27B : F9                  	MOV	R1,A
     837/     27C : E5 08               	MOV	A,TMP0
     838/     27E : 80 83               	JMP	STRDIR
     839/     280 :                     ;
     840/     280 :                     ;===
     841/     280 :                     ;
     842/     280 : 51 1D               STRRBI:	CALL	SPLIT_DBA
     843/     282 : 51 11               	CALL	FETDIR
     844/     284 : FE                  	MOV	TOS_L,A
     845/     285 : E5 08               	MOV	A,TMP0
     846/     287 : 20 E0 06            	JB	ACC.0,SETRBI
     847/     28A :                     ;
     848/     28A :                     ;	Clear RBIT.
     849/     28A :                     ;
     850/     28A : E5 F0               	MOV	A,B
     851/     28C : F4                  	CPL	A
     852/     28D : 5E                  	ANL	A,TOS_L
     853/     28E : 41 03               	JMP	STRDIR
     854/     290 :                     ;
     855/     290 : E5 F0               SETRBI:	MOV	A,B
     856/     292 : 4E                  	ORL	A,TOS_L
     857/     293 : 41 03               	JMP	STRDIR
     858/     295 :                     ;
     859/     295 :                     ;===
     860/     295 :                     ;
     861/     295 :                     STRXBY:
     862/     295 : 8F A0               STRCBY:	MOV	P2,TOS_H
     863/     297 : EE                  	MOV	A,TOS_L
     864/     298 : F9                  	MOV	R1,A
     865/     299 : E5 08               	MOV	A,TMP0
     866/     29B : F3                  	MOVX	@R1,A
     867/     29C : 22                  	RET
     868/     29D :                     ;
     869/     29D :                     ;===============
     870/     29D :                     ;
     871/     29D :                     ;
     872/     29D :                     SEQ_FETCH:
     873/     29D :                     ;	Same as FETCH, below, except that index is retained
     874/     29D :                     ;	rather than being popped.
     875/     29D : D2 4B               	SETB	SEQ_FLG
     876/     29F : 80 02               	SJMP	FET_0
     877/     2A1 :                     ;
     878/     2A1 :                     ;
     879/     2A1 :                     FETCH:
     880/     2A1 :                     ;	When FETCH is called, AES contains
     881/     2A1 :                     ;	(TOS:)	2 byte INDEX of source variable,
     882/     2A1 :                     ;		1 byte TYPE code for variable space.
     883/     2A1 :                     ;			(0=BASIC variable,
     884/     2A1 :                     ;			 1=DBYTE,
     885/     2A1 :                     ;			 2=RBIT,
     886/     2A1 :                     ;			 3=XBYTE,
     887/     2A1 :                     ;			 4=CBYTE.)
     888/     2A1 :                     ;	Read 8- or 16-bit variable from the appropriate variable 
     889/     2A1 :                     ;	memory at location of (INDEX) and return on AES.
     890/     2A1 :                     ;
     891/     2A1 : C2 4B               	CLR	SEQ_FLG
     892/     2A3 : 31 39               FET_0:	CALL	POP_TOS
     893/     2A5 : 31 4B               	CALL	POP_ACC
     894/     2A7 : 30 4B 06            	JNB	SEQ_FLG,FET_1	;Jump forward if simple store.
     895/     2AA : 05 2A               	INC	AESP
     896/     2AC : 05 2A               	INC	AESP
     897/     2AE : 05 2A               	INC	AESP
     898/     2B0 : 90 02 B5            FET_1:	MOV	DPTR,#FETJTB
     899/     2B3 : 93                  	MOVC	A,@A+DPTR
     900/     2B4 : 73                  	JMP	@A+DPTR
     901/     2B5 :                     ;
     902/     2B5 : 05                  FETJTB:	DB	FETVAR-FETJTB
     903/     2B6 : 25                  	DB	FETDBY-FETJTB
     904/     2B7 : 2B                  	DB	FETRBI-FETJTB
     905/     2B8 : 37                  	DB	FETXBY-FETJTB
     906/     2B9 : 3E                  	DB	FETCBY-FETJTB
     907/     2BA :                     ;
     908/     2BA :                     ;=======
     909/     2BA :                     ;
     910/     2BA :                     ;	All of the following routines are called with 
     911/     2BA :                     ;	TOS_L holding the low-order index of the desired variable,
     912/     2BA :                     ;	and TOS_H holding the high-order index (if necessary).
     913/     2BA :                     ;
     914/     2BA : EE                  FETVAR:	MOV	A,TOS_L
     915/     2BB : 23                  	RL	A		;Correct for double-byte entries.
     916/     2BC : 20 40 0E            	JB	EXTVAR,FETEXT
     917/     2BF : 24 10               	ADD	A,#US_VAR	;Offset for variable array.
     918/     2C1 : F9                  	MOV	R1,A		;Index to variable storage array.
     919/     2C2 : 24 D9               	ADD	A,#-(US_VAR+2*NO_VAR-1)
     920/     2C4 : 40 12               	JC	FETERR
     921/     2C6 : E7                  	MOV	A,@R1		;Load low-order byte of variable.
     922/     2C7 : FE                  	MOV	TOS_L,A		;And store on AES.
     923/     2C8 : 09                  	INC	R1		;Bump pointer.
     924/     2C9 : E7                  	MOV	A,@R1		;Transfer high-order byte of variable.
     925/     2CA : FF                  	MOV	TOS_H,A
     926/     2CB : 21 51               	JMP	PUSH_TOS
     927/     2CD :                     ;
     928/     2CD :                     ;===
     929/     2CD :                     ;
     930/     2CD : F9                  FETEXT:	MOV	R1,A		;Index to variable storage array.
     931/     2CE : 75 A0 20            DD002:  MOV     P2,#(EXTRAM >> 8)
     932/     2D1 : E3                          MOVX    A,@R1           ;Load low-order byte of variable.
     933/     2D2 : FE                  	MOV	TOS_L,A		;And store on AES.
     934/     2D3 : 09                  	INC	R1		;Bump pointers.
     935/     2D4 : E3                  	MOVX	A,@R1		;Transfer high-order byte of variable.
     936/     2D5 : FF                  	MOV	TOS_H,A
     937/     2D6 : 21 51               	JMP	PUSH_TOS
     938/     2D8 :                     ;
     939/     2D8 : 41 01               FETERR:	JMP	ADR_ER
     940/     2DA :                     ;
     941/     2DA :                     ;===
     942/     2DA :                     ;
     943/     2DA : EE                  FETDBY:	MOV	A,TOS_L
     944/     2DB : F9                  	MOV	R1,A
     945/     2DC : 51 11               	CALL	FETDIR
     946/     2DE : 80 19               	SJMP	FETBDN		;Byte fetch done.
     947/     2E0 :                     ;
     948/     2E0 :                     ;===
     949/     2E0 :                     ;
     950/     2E0 : 51 1D               FETRBI:	CALL	SPLIT_DBA
     951/     2E2 : 51 11               	CALL	FETDIR
     952/     2E4 : 55 F0               	ANL	A,B
     953/     2E6 : 24 FF               	ADD	A,#0FFH
     954/     2E8 : E4                  	CLR	A
     955/     2E9 : 33                  	RLC	A
     956/     2EA : 80 0D               	SJMP	FETBDN
     957/     2EC :                     ;
     958/     2EC :                     ;===
     959/     2EC :                     ;
     960/     2EC : 8F A0               FETXBY:	MOV	P2,TOS_H
     961/     2EE : EE                  	MOV	A,TOS_L
     962/     2EF : F9                  	MOV	R1,A
     963/     2F0 : E3                  	MOVX	A,@R1
     964/     2F1 : 80 06               	SJMP	FETBDN
     965/     2F3 :                     ;
     966/     2F3 :                     ;===
     967/     2F3 :                     ;
     968/     2F3 : 8F 83               FETCBY:	MOV	DPH,TOS_H
     969/     2F5 : 8E 82               	MOV	DPL,TOS_L
     970/     2F7 : E4                  	CLR	A
     971/     2F8 : 93                  	MOVC	A,@A+DPTR
     972/     2F9 : 7F 00               FETBDN:	MOV	TOS_H,#00H	;FETCH sequence for Bytes Done.
     973/     2FB : FE                  	MOV	TOS_L,A		;FETCH sequence for words done.
     974/     2FC : 21 51               	JMP	PUSH_TOS
     975/     2FE :                     ;
     976/     2FE :                     ;=======
     977/     2FE :                     ;$EJECT
     978/     2FE :                     ;
     979/     2FE :                     ;CREATE
     980/     2FE :                     ;	Test the contents of Acc.
     981/     2FE :                     ;	If CHAR holds the ASCII code for a legitimate decimal digit,
     982/     2FE :                     ;	create a two-byte entry in <TOS_H><TOS_L> holding low-order ACC nibble
     983/     2FE :                     ;	and return with CY set.
     984/     2FE :                     ;	Otherwise, return with CY cleared.
     985/     2FE :                     ;
     986/     2FE : 24 D0               CREATE:	ADD	A,#-'0'		;Correct for ASCII digit offset.
     987/     300 : B4 0A 00            	CJNE	A,#10,$+3	;Compare to maximum legal digit.
     988/     303 : 50 05               	JNC	CREA_1		;Abort if first char is not decimal digit.
     989/     305 : FE                  	MOV	TOS_L,A		;Save initial digit read.
     990/     306 : 7F 00               	MOV	TOS_H,#0	;Clear high-order bits.
     991/     308 : C2 4D               	CLR	H_FLG
     992/     30A : 22                  CREA_1:	RET
     993/     30B :                     ;
     994/     30B :                     ;===============
     995/     30B :                     ;
     996/     30B :                     ;APPEND
     997/     30B :                     ;	Test ASCII code in Acc.
     998/     30B :                     ;	If it is a legal digit in the current radix,
     999/     30B :                     ;	modify <TOS_H><TOS_L> to include this digit and return with CY set.
    1000/     30B :                     ;	Otherwise leave AES and CHAR unchanged and return with CY cleared.
    1001/     30B :                     ;	Operating mode determined by HEXMOD flag (1=Hex).
    1002/     30B :                     ;
    1003/     30B : 20 4D 3E            APPEND:	JB	H_FLG,APND_2	;Nothing allowed after trailing 'H' received.
    1004/     30E : 24 D0               	ADD	A,#-'0'		;Correct for ASCII offset.
    1005/     310 : B4 0A 00            	CJNE	A,#10,$+3	;Verify whether legal digit.
    1006/     313 : 40 13               	JC	APND_1		;Insert decimal digit as is.
    1007/     315 : 30 44 34            	JNB	HEXMOD,APND_2	;If in decimal mode, character isn't legal.
    1008/     318 : 24 EF               	ADD	A,#'0'-'A'	;Acc now equals 0 if 'A' received.
    1009/     31A : B4 06 00            	CJNE	A,#6,$+3
    1010/     31D : 40 07               	JC	APND_4		;Process Hex digit.
    1011/     31F :                     ;
    1012/     31F :                     ;	Char was not hexidecimal digit, but if it was the first 'H', that's OK.
    1013/     31F :                     ;
    1014/     31F : B4 07 2A            	CJNE	A,#'H'-'A',APND_2	;Compare original input with 'H'.
    1015/     322 : D2 4D               	SETB	H_FLG		;Mark that 'H' was detected but don't process.
    1016/     324 : D3                  	SETB	C
    1017/     325 : 22                  	RET
    1018/     326 :                     ;
    1019/     326 : 24 0A               APND_4:	ADD	A,#10		;Value of lowest hex digit.
    1020/     328 : CE                  APND_1:	XCH	A,TOS_L		;Save nibble to be appended.
    1021/     329 : 75 F0 0A            	MOV	B,#10		;(Assuming radix=decimal.)
    1022/     32C : 30 44 03            	JNB	HEXMOD,XRAD_1	;Skip ahead if assumption correct.
    1023/     32F : 75 F0 10            	MOV	B,#16		;If mode is actually hex.
    1024/     332 : C0 F0               XRAD_1:	PUSH	B		;Save for re-use.
    1025/     334 : A4                  	MUL	AB		;Multiply by radix.
    1026/     335 : 2E                  	ADD	A,TOS_L		;Append new digit.
    1027/     336 : FE                  	MOV	TOS_L,A		;Save low-order shifted value.
    1028/     337 : E4                  	CLR	A
    1029/     338 : 35 F0               	ADDC	A,B		;Incremented high-order product if carry.
    1030/     33A : CF                  	XCH	A,TOS_H
    1031/     33B : D0 F0               	POP	B
    1032/     33D : A4                  	MUL	AB
    1033/     33E : 2F                  	ADD	A,TOS_H
    1034/     33F : FF                  	MOV	TOS_H,A
    1035/     340 : 72 E7               	ORL	C,ACC.7		;Detect if most significant bit set.
    1036/     342 : E5 F0               	MOV	A,B
    1037/     344 : 34 FF               	ADDC	A,#0FFH		;Simulate "ORL	C,NZ" instruction.
    1038/     346 : B0 44               	ANL	C,/HEXMOD	;Overflow only relevent in decimal mode.
    1039/     348 : 40 04               	JC	APN_ER		;Error if bit 7 overflow occurred.
    1040/     34A : D3                  	SETB	C		;CHAR processed as legal character.
    1041/     34B : 22                  	RET
    1042/     34C :                     ;
    1043/     34C : C3                  APND_2:	CLR	C
    1044/     34D : 22                  	RET
    1045/     34E :                     ;
    1046/     34E :                     ;
    1047/     34E : 31 1A               APN_ER:	CALL	EXP_ER		;Indicate illegal entry.
    1048/     350 : 02                  	DB	2
    1049/     351 :                     ;
    1050/     351 :                     ;$EJECT
    1051/     351 :                     ;
    1052/     351 :                     OV_TST:
    1053/     351 :                     ;	If OV is set and operation is BCD mode then call EXP_ER routine.
    1054/     351 :                     ;
    1055/     351 : A2 D2               	MOV	C,OV
    1056/     353 : B0 44               	ANL	C,/HEXMOD
    1057/     355 : 40 01               	JC	EXP_OV
    1058/     357 : 22                  	RET
    1059/     358 :                     ;
    1060/     358 : 31 1A               EXP_OV:	CALL	EXP_ER
    1061/     35A : 06                  	DB	6
    1062/     35B :                     ;
    1063/     35B :                     ;=======
    1064/     35B :                     ;
    1065/     35B : E7                  ADD_16:	MOV	A,@R1		;Add low-order bytes.
    1066/     35C : 2E                  	ADD	A,TOS_L
    1067/     35D : F7                  	MOV	@R1,A		;Save sum.
    1068/     35E : 09                  	INC	R1
    1069/     35F : E7                  	MOV	A,@R1		;Add high-order bytes.
    1070/     360 : 3F                  	ADDC	A,TOS_H
    1071/     361 : F7                  	MOV	@R1,A		;Save sum.
    1072/     362 : 22                  	RET
    1073/     363 :                     ;
    1074/     363 :                     ;=======
    1075/     363 :                     ;
    1076/     363 :                     ;
    1077/     363 :                     IADD:
    1078/     363 :                     ;	Pop VAR from AES (two bytes).
    1079/     363 :                     ;	TOS <= TOS + VAR
    1080/     363 :                     ;
    1081/     363 : 31 39               	CALL	POP_TOS
    1082/     365 : 71 5B               	CALL	ADD_16
    1083/     367 : 80 E8               	JMP	OV_TST
    1084/     369 :                     ;
    1085/     369 :                     ;===============
    1086/     369 :                     ;
    1087/     369 :                     ;ISUB
    1088/     369 :                     ;	Pop VAR from AES (two bytes).
    1089/     369 :                     ;	TOS <= TOS - VAR
    1090/     369 :                     ;
    1091/     369 :                     ;
    1092/     369 : 31 39               ISUB:	ACALL	POP_TOS
    1093/     36B : C3                  	CLR	C		;Set up for subtraction with borrow.
    1094/     36C : E7                  	MOV	A,@R1		;Subtract low-order bytes.
    1095/     36D : 9E                  	SUBB	A,TOS_L
    1096/     36E : F7                  	MOV	@R1,A		;Save difference.
    1097/     36F : 09                  	INC	R1		;Bump pointers.
    1098/     370 : E7                  	MOV	A,@R1		;Subtract high-order bytes.
    1099/     371 : 9F                  	SUBB	A,TOS_H
    1100/     372 : F7                  	MOV	@R1,A		;Save difference.
    1101/     373 : 80 DC               	JMP	OV_TST
    1102/     375 :                     ;
    1103/     375 :                     ;=======
    1104/     375 :                     ;
    1105/     375 :                     ;
    1106/     375 :                     IAND:
    1107/     375 :                     ;	Pop VAR from AES (two bytes).
    1108/     375 :                     ;	TOS <= TOS AND VAR
    1109/     375 :                     ;
    1110/     375 : 31 39               	CALL	POP_TOS
    1111/     377 : E7                  	MOV	A,@R1		;AND low-order bytes.
    1112/     378 : 5E                  	ANL	A,TOS_L
    1113/     379 : F7                  	MOV	@R1,A		;Save result.
    1114/     37A : 09                  	INC	R1
    1115/     37B : E7                  	MOV	A,@R1		;AND high-order bytes.
    1116/     37C : 5F                  	ANL	A,TOS_H
    1117/     37D : F7                  	MOV	@R1,A		;Save result.
    1118/     37E : 22                  	RET
    1119/     37F :                     ;
    1120/     37F :                     ;=======
    1121/     37F :                     ;
    1122/     37F :                     ;
    1123/     37F :                     IOR:
    1124/     37F :                     ;	Pop VAR from AES (two bytes).
    1125/     37F :                     ;	TOS <= TOS OR VAR
    1126/     37F :                     ;
    1127/     37F : 31 39               	CALL	POP_TOS
    1128/     381 : E7                  	MOV	A,@R1		;OR low-order bytes.
    1129/     382 : 4E                  	ORL	A,TOS_L
    1130/     383 : F7                  	MOV	@R1,A		;Save result.
    1131/     384 : 09                  	INC	R1
    1132/     385 : E7                  	MOV	A,@R1		;OR high-order bytes.
    1133/     386 : 4F                  	ORL	A,TOS_H
    1134/     387 : F7                  	MOV	@R1,A		;Save result.
    1135/     388 : 22                  	RET
    1136/     389 :                     ;
    1137/     389 :                     ;=======
    1138/     389 :                     ;
    1139/     389 :                     ;
    1140/     389 :                     IXOR:
    1141/     389 :                     ;	Pop VAR from AES (two bytes).
    1142/     389 :                     ;	TOS <= TOS XOR VAR
    1143/     389 :                     ;
    1144/     389 : 31 39               	CALL	POP_TOS
    1145/     38B : E7                  	MOV	A,@R1		;XOR low-order bytes.
    1146/     38C : 6E                  	XRL	A,TOS_L
    1147/     38D : F7                  	MOV	@R1,A		;Save result.
    1148/     38E : 09                  	INC	R1
    1149/     38F : E7                  	MOV	A,@R1		;XOR high-order bytes.
    1150/     390 : 6F                  	XRL	A,TOS_H
    1151/     391 : F7                  	MOV	@R1,A		;Save result.
    1152/     392 : 22                  	RET
    1153/     393 :                     ;
    1154/     393 :                     ;===============
    1155/     393 :                     ;
    1156/     393 :                     ;
    1157/     393 :                     NEG:
    1158/     393 :                     ;	TOS <= -TOS
    1159/     393 :                     ;
    1160/     393 : C3                  	CLR	C
    1161/     394 : B2 4A               	CPL	SGN_FLG
    1162/     396 : A9 2A               NEG_0:	MOV	R1,AESP		;Compute variable address.
    1163/     398 : 19                  	DEC	R1		;Index for low-order byte of VAR_1.
    1164/     399 : E4                  	CLR	A		;Subtract VAR_1 from 0000H.
    1165/     39A : 97                  	SUBB	A,@R1
    1166/     39B : F7                  	MOV	@R1,A		;Save difference.
    1167/     39C : 09                  	INC	R1		;Bump pointer.
    1168/     39D : E4                  	CLR	A
    1169/     39E : 97                  	SUBB	A,@R1		;Subtract high-order byte.
    1170/     39F : F7                  	MOV	@R1,A		;Save difference.
    1171/     3A0 : 80 AF               	JMP	OV_TST
    1172/     3A2 :                     ;
    1173/     3A2 :                     ;=======
    1174/     3A2 :                     ;
    1175/     3A2 :                     ;
    1176/     3A2 :                     ICPL:
    1177/     3A2 :                     ;	TOS <= /TOS  (ones complement)
    1178/     3A2 : D3                  	SETB	C
    1179/     3A3 : 80 F1               	SJMP	NEG_0
    1180/     3A5 :                     ;
    1181/     3A5 :                     ;===============
    1182/     3A5 :                     ;
    1183/     3A5 :                     ;
    1184/     3A5 :                     IABS:
    1185/     3A5 :                     ;	If in decimal mode and TOS < 0 
    1186/     3A5 :                     ;	then complement SGN_FLG and negate TOS.
    1187/     3A5 :                     ;
    1188/     3A5 : A9 2A               	MOV	R1,AESP
    1189/     3A7 : E7                  	MOV	A,@R1
    1190/     3A8 : A2 E7               	MOV	C,ACC.7
    1191/     3AA : B0 44               	ANL	C,/HEXMOD
    1192/     3AC : 40 E5               	JC	NEG
    1193/     3AE : 22                  	RET
    1194/     3AF :                     ;
    1195/     3AF :                     ;=======
    1196/     3AF :                     ;
    1197/     3AF :                     NEG_IF_NEG:
    1198/     3AF :                     ;	If SGN_FLG is set then negate TOS and complement SGN_FLG,
    1199/     3AF :                     ;	else return with TOS unchanged.
    1200/     3AF : 20 4A E1            	JB	SGN_FLG,NEG
    1201/     3B2 : 22                  	RET
    1202/     3B3 :                     ;
    1203/     3B3 :                     ;=======
    1204/     3B3 :                     ;
    1205/     3B3 :                     ;
    1206/     3B3 :                     IINC:
    1207/     3B3 :                     ;	TOS <= TOS+1
    1208/     3B3 :                     ;
    1209/     3B3 : A9 2A               	MOV	R1,AESP		;Compute variable address.
    1210/     3B5 : 19                  	DEC	R1		;Index for low-order byte of VAR_1.
    1211/     3B6 : 07                  	INC	@R1
    1212/     3B7 : B7 00 02            	CJNE	@R1,#00,IINC_1
    1213/     3BA : 09                  	INC	R1		;Bump pointer.
    1214/     3BB : 07                  	INC	@R1
    1215/     3BC : 22                  IINC_1:	RET
    1216/     3BD :                     ;
    1217/     3BD :                     ;=======
    1218/     3BD :                     ;
    1219/     3BD :                     MUL_16:
    1220/     3BD :                     ;	Multiply unsigned 16-bit quantity in <TOS_H><TOS_L> by entry
    1221/     3BD :                     ;	on top of stack, and return with product on stack.
    1222/     3BD :                     ;	If product exceeds 16-bits, set OV flag.
    1223/     3BD :                     ;
    1224/     3BD : C2 D5               	CLR	F0		;Initialize overflow flag.
    1225/     3BF : A9 2A               	MOV	R1,AESP		;Point to MSB of NOS.
    1226/     3C1 : E7                  	MOV	A,@R1
    1227/     3C2 : 60 05               	JZ	IMUL_1		;High-order byte of either param. must be 0.
    1228/     3C4 : EF                  	MOV	A,TOS_H
    1229/     3C5 : 60 02               	JZ	IMUL_1
    1230/     3C7 : D2 D5               	SETB	F0		;Mark that both parameters exceed 255.
    1231/     3C9 : 19                  IMUL_1:	DEC	R1		;Index low-order NOS.
    1232/     3CA : E7                  	MOV	A,@R1
    1233/     3CB : 8F F0               	MOV	B,TOS_H
    1234/     3CD : A4                  	MUL	AB		;Low-order product.
    1235/     3CE : 30 D2 02            	JNB	OV,IMUL_2
    1236/     3D1 : D2 D5               	SETB	F0
    1237/     3D3 : 09                  IMUL_2:	INC	R1
    1238/     3D4 : C7                  	XCH	A,@R1		;Save low-order prod. and load high-order NOS.
    1239/     3D5 : 8E F0               	MOV	B,TOS_L
    1240/     3D7 : A4                  	MUL	AB
    1241/     3D8 : 30 D2 02            	JNB	OV,IMUL_3	;Mark if overflow.
    1242/     3DB : D2 D5               	SETB	F0
    1243/     3DD : 27                  IMUL_3:	ADD	A,@R1
    1244/     3DE : F7                  	MOV	@R1,A		;Save high-order sum.
    1245/     3DF : 72 D5               	ORL	C,F0
    1246/     3E1 : 92 D5               	MOV	F0,C
    1247/     3E3 : 19                  	DEC	R1		;Address low-order NOS.
    1248/     3E4 : E7                  	MOV	A,@R1
    1249/     3E5 : 8E F0               	MOV	B,TOS_L
    1250/     3E7 : A4                  	MUL	AB
    1251/     3E8 : F7                  	MOV	@R1,A
    1252/     3E9 : E5 F0               	MOV	A,B
    1253/     3EB : 09                  	INC	R1
    1254/     3EC : 27                  	ADD	A,@R1
    1255/     3ED : F7                  	MOV	@R1,A		;Save high-order product.
    1256/     3EE : 72 D5               	ORL	C,F0		;Check if carry or sign-bit set.
    1257/     3F0 : 72 E7               	ORL	C,ACC.7		;Check if sign-bit set.
    1258/     3F2 : 92 D2               	MOV	OV,C
    1259/     3F4 : 22                  	RET
    1260/     3F5 :                     ;
    1261/     3F5 :                     ;=======
    1262/     3F5 :                     ;
    1263/     3F5 :                     ;
    1264/     3F5 :                     IMUL:
    1265/     3F5 :                     ;	Pop VAR from AES (two bytes).
    1266/     3F5 :                     ;	TOS <= TOS * VAR
    1267/     3F5 :                     ;
    1268/     3F5 : C2 4A               	CLR	SGN_FLG		;Initialize sign monitor flag.
    1269/     3F7 : 71 A5               	CALL	IABS		;Take absolute value of TOS.
    1270/     3F9 : 31 39               	CALL	POP_TOS		;Pop top entry.
    1271/     3FB : 71 A5               	CALL	IABS		;Take absolute value of NOS.
    1272/     3FD : 71 BD               	CALL	MUL_16
    1273/     3FF : 71 51               	CALL	OV_TST		;Check if OV relevent.
    1274/     401 : 71 AF               	CALL	NEG_IF_NEG
    1275/     403 : 22                  	RET
    1276/     404 :                     ;
    1277/     404 :                     ;===============
    1278/     404 :                     ;
    1279/     404 :                     ;
    1280/     404 : D2 4C               IMOD:	SETB	MOD_FLG		;Indicate modulo entry point.
    1281/     406 : 80 02               	SJMP	IDIV_0
    1282/     408 :                     ;
    1283/     408 :                     ;=======
    1284/     408 :                     ;
    1285/     408 :                     ;
    1286/     408 :                     IDIV:
    1287/     408 :                     ;	Pop VAR from AES (two bytes).
    1288/     408 :                     ;	TOS <= TOS / VAR
    1289/     408 :                     ;	If divide-by-zero attempted report error.
    1290/     408 :                     ;
    1291/     408 : C2 4C               	CLR	MOD_FLG		;Indicate division entry point.
    1292/     40A : D2 4A               IDIV_0:	SETB	SGN_FLG		;Initialize sign monitor flag.
    1293/     40C : 71 A5               	CALL	IABS
    1294/     40E : 71 93               	CALL	NEG
    1295/     410 : 31 39               	CALL	POP_TOS
    1296/     412 :                     ;???
    1297/     412 :                     ; The next line of code added by lss 21-dec-1982
    1298/     412 :                     ;???
    1299/     412 : EE                  	mov	a,tos_l
    1300/     413 : 4F                  	ORL	A,TOS_H
    1301/     414 : 60 4D               	JZ	DIV_NG
    1302/     416 : A2 4A               	MOV	C,SGN_FLG
    1303/     418 : B0 4C               	ANL	C,/MOD_FLG	;Clear SGN_FLG if MOD funtion being done.
    1304/     41A : 92 4A               	MOV	SGN_FLG,C
    1305/     41C : 71 A5               	CALL	IABS
    1306/     41E : F5 09               	MOV	TMP1,A
    1307/     420 : 19                  	DEC	R1
    1308/     421 : E7                  	MOV	A,@R1
    1309/     422 : F5 08               	MOV	TMP0,A
    1310/     424 : E4                  	CLR	A
    1311/     425 : F5 0B               	MOV	TMP3,A
    1312/     427 : F5 0A               	MOV	TMP2,A
    1313/     429 : 7D 11               	MOV	LP_CNT,#17
    1314/     42B : C3                  	CLR	C
    1315/     42C : 80 17               	SJMP	DIV_RP
    1316/     42E :                     ;
    1317/     42E : E5 0A               DIV_LP:	MOV	A,TMP2
    1318/     430 : 33                  	RLC	A
    1319/     431 : F5 0A               	MOV	TMP2,A
    1320/     433 : C5 0B               	XCH	A,TMP3
    1321/     435 : 33                  	RLC	A
    1322/     436 : C5 0B               	XCH	A,TMP3
    1323/     438 : 2E                  	ADD	A,TOS_L
    1324/     439 : F5 0C               	MOV	TMP4,A
    1325/     43B : E5 0B               	MOV	A,TMP3
    1326/     43D : 3F                  	ADDC	A,TOS_H
    1327/     43E : 50 05               	JNC	DIV_RP
    1328/     440 : 85 0C 0A            	MOV	TMP2,TMP4
    1329/     443 : F5 0B               	MOV	TMP3,A
    1330/     445 : E5 08               DIV_RP:	MOV	A,TMP0
    1331/     447 : 33                  	RLC	A
    1332/     448 : F5 08               	MOV	TMP0,A
    1333/     44A : E5 09               	MOV	A,TMP1
    1334/     44C : 33                  	RLC	A
    1335/     44D : F5 09               	MOV	TMP1,A
    1336/     44F : DD DD               	DJNZ	LP_CNT,DIV_LP
    1337/     451 : 20 4C 07            	JB	MOD_FLG,DIV_1
    1338/     454 : A7 08               	MOV	@R1,TMP0
    1339/     456 : 09                  	INC	R1
    1340/     457 : A7 09               	MOV	@R1,TMP1
    1341/     459 : 80 05               	SJMP	DIV_2
    1342/     45B :                     ;
    1343/     45B : A7 0A               DIV_1:	MOV	@R1,TMP2
    1344/     45D : 09                  	INC	R1
    1345/     45E : A7 0B               	MOV	@R1,TMP3
    1346/     460 : 71 AF               DIV_2:	CALL	NEG_IF_NEG
    1347/     462 : 22                  	RET
    1348/     463 :                     ;
    1349/     463 : 61 58               DIV_NG:	AJMP	EXP_OV		;Report expression overflow.
    1350/     465 :                     ;
    1351/     465 :                     ;===============
    1352/     465 :                     ;
    1353/     465 :                     ;$EJECT
    1354/     465 :                     ;
    1355/     465 :                     ;
    1356/     465 :                     RND:
    1357/     465 :                     ;	Generate a new 16-bit random number from RND_KEY,
    1358/     465 :                     ;	and push onto the AES.
    1359/     465 : AE 0D               	MOV	TOS_L,SEED_L
    1360/     467 : AF 0E               	MOV	TOS_H,SEED_H
    1361/     469 : 31 51               	CALL	PUSH_TOS
    1362/     46B : 7E 55                       MOV     TOS_L,#(25173 & 0ffh)
    1363/     46D : 7F 62                       MOV     TOS_H,#(25173 >> 8)
    1364/     46F : 71 BD               	CALL	MUL_16
    1365/     471 : 7E 19                       MOV     TOS_L,#(13849 & 0ffh)
    1366/     473 : 7F 36                       MOV     TOS_H,#(13849 >> 8)
    1367/     475 : A9 2A               	MOV	R1,AESP
    1368/     477 : 19                  	DEC	R1
    1369/     478 : 71 5B               	CALL	ADD_16
    1370/     47A : 31 39               	CALL	POP_TOS
    1371/     47C :                     ;
    1372/     47C :                     ;???
    1373/     47C :                     ; The code from here to label no_problem added by lss 21 dec 1982
    1374/     47C :                     ; to cure a extraneous overflow if seed=8000h.
    1375/     47C :                     ;???
    1376/     47C :                     ;
    1377/     47C : BE 00 07            	cjne	tos_l,#0,no_problem
    1378/     47F : BF 80 04            	cjne	tos_h,#80h,no_problem
    1379/     482 :                     big_problem:				   ; tos=8000h will generate an overflow
    1380/     482 : 7E 2A               	mov	tos_l,#(12586 & 0ffh)      ; when control gets to iabs.
    1381/     484 : 7F 31               	mov	tos_h,#(12586 >> 8)        ; Load the precalculated seed.
    1382/     486 :                     no_problem:
    1383/     486 : 8E 0D               	MOV	SEED_L,TOS_L
    1384/     488 : 8F 0E               	MOV	SEED_H,TOS_H
    1385/     48A : 31 51               	CALL	PUSH_TOS
    1386/     48C : 22                  	RET
    1387/     48D :                     ;
    1388/     48D :                     ;===============
    1389/     48D :                     ;
    1390/     48D :                     ;
    1391/     48D :                     CMPR:
    1392/     48D :                     ;	When CMPR is called, AES contains:
    1393/     48D :                     ;	(TOS:)	VAR_2 (two bytes),
    1394/     48D :                     ;		C_CODE (one byte),
    1395/     48D :                     ;		VAR_1 (two bytes).
    1396/     48D :                     ;	Pop all 5 bytes from stack and test relation between VAR_1 and VAR_2.
    1397/     48D :                     ;	    If C_CODE=010 then test whether (VAR_1) =  (VAR_2)
    1398/     48D :                     ;	    If C_CODE=100 then test whether (VAR_1) <  (VAR_2)
    1399/     48D :                     ;	    If C_CODE=110 then test whether (VAR_1) <= (VAR_2)
    1400/     48D :                     ;	    If C_CODE=101 then test whether (VAR_1) <> (VAR_2)
    1401/     48D :                     ;	    If C_CODE=001 then test whether (VAR_1) >  (VAR_2)
    1402/     48D :                     ;	    If C_CODE=011 then test whether (VAR_1) >= (VAR_2)
    1403/     48D :                     ;	If true then return 0001H on AES;
    1404/     48D :                     ;	otherwise return 0000H.
    1405/     48D :                     ;
    1406/     48D : 31 39               	CALL	POP_TOS
    1407/     48F : 31 4B               	CALL	POP_ACC
    1408/     491 : F5 F0               	MOV	B,A
    1409/     493 : A9 2A               	MOV	R1,AESP
    1410/     495 : 19                  	DEC	R1
    1411/     496 : C3                  	CLR	C		;...in preparation for string subtract.
    1412/     497 : E7                  	MOV	A,@R1		;Compare low-order parameter bytes.
    1413/     498 : 9E                  	SUBB	A,TOS_L
    1414/     499 : 09                  	INC	R1		;Bump pointer.
    1415/     49A : C7                  	XCH	A,@R1		;Save difference.
    1416/     49B : 20 44 06            	JB	HEXMOD,CMPR_4
    1417/     49E : 64 80               	XRL	A,#80H		;Offset variable by 80H for unsigned compare.
    1418/     4A0 : CF                  	XCH	A,TOS_H
    1419/     4A1 : 64 80               	XRL	A,#80H
    1420/     4A3 : CF                  	XCH	A,TOS_H
    1421/     4A4 : 9F                  CMPR_4:	SUBB	A,TOS_H
    1422/     4A5 : 47                  	ORL	A,@R1		;Add any non-zero high-order bits to acc.
    1423/     4A6 : 70 04               	JNZ	CMPR_1		;Jump ahead VAR_1 <> VAR_2.
    1424/     4A8 :                     ;
    1425/     4A8 :                     ;	VAR_1 = VAR_2:
    1426/     4A8 :                     ;
    1427/     4A8 : A2 F1               	MOV	C,B.1		;Load VAR_1 = VAR_2 test flag.
    1428/     4AA : 80 08               	SJMP	PUSH_C
    1429/     4AC :                     ;
    1430/     4AC : 40 04               CMPR_1:	JC	CMPR_2		;Jump ahead if VAR_1 < VAR_2.
    1431/     4AE :                     ;
    1432/     4AE :                     ;	VAR_1 > VAR_2:
    1433/     4AE :                     ;
    1434/     4AE : A2 F0               	MOV	C,B.0		;Load VAR_1 > VAR_2 test flag.
    1435/     4B0 : 80 02               	SJMP	PUSH_C
    1436/     4B2 :                     ;
    1437/     4B2 :                     ;	VAR_1 < VAR_2:
    1438/     4B2 :                     ;
    1439/     4B2 : A2 F2               CMPR_2:	MOV	C,B.2		;Load VAR_1 < VAR_2 test flag.
    1440/     4B4 : E4                  PUSH_C:	CLR	A
    1441/     4B5 : F7                  	MOV	@R1,A
    1442/     4B6 : 33                  	RLC	A
    1443/     4B7 : 19                  	DEC	R1
    1444/     4B8 : F7                  	MOV	@R1,A
    1445/     4B9 : 22                  	RET
    1446/     4BA :                     ;
    1447/     4BA :                     ;$EJECT
    1448/     4BA :                     
    1449/     4BA :                     ;	BASIC SOURCE PROGRAM LINE ACCESSING ROUTINES:
    1450/     4BA :                     ;	===== ====== ======= ==== ======= ==========
    1451/     4BA :                     ;
    1452/     4BA :                     ;	The general methodology of the various parsing routines is as follows:
    1453/     4BA :                     ;	The POINTER (PNTR_L, PNTR_H) is used to indicate the next BASIC
    1454/     4BA :                     ;	source character or string to be parsed
    1455/     4BA :                     ;	by routines TST, TSTV, TSTN, TSTL, and TSTS.
    1456/     4BA :                     ;	GET_C reads the indicated character from the appropriate
    1457/     4BA :                     ;	program buffer space into acc. and returns.
    1458/     4BA :                     ;	READ_CHAR reads the character into CHAR as well as acc. and 
    1459/     4BA :                     ;	increments the 16-bit pointer.
    1460/     4BA :                     ;	When done, each routine calls D_BLANK to remove any trailing spaces,
    1461/     4BA :                     ;	and leaves READ_CHAR ready to fetch the next non-blank character.
    1462/     4BA :                     ;
    1463/     4BA :                     ;=======
    1464/     4BA :                     ;
    1465/     4BA :                     ;REWIND
    1466/     4BA :                     ;	Reset Cursor to start of current program buffer space.
    1467/     4BA :                     ;
    1468/     4BA : C2 49               REWIND:	CLR	CHAR_FLG
    1469/     4BC : 20 41 05            	JB	ROMMOD,REWROM
    1470/     4BF : 7A 20                       MOV     PNTR_H,#(EXTRAM >> 8)
    1471/     4C1 : 78 34                       MOV     PNTR_L,#(EXTRAM & 0ffh)
    1472/     4C3 : 22                  	RET
    1473/     4C4 :                     ;
    1474/     4C4 : 20 42 05            REWROM:	JB	EXTMOD,RWXROM
    1475/     4C7 : 7A 0C                       MOV     PNTR_H,#(INTROM >> 8)
    1476/     4C9 : 78 19                       MOV     PNTR_L,#(INTROM & 0ffh)
    1477/     4CB : 22                  	RET
    1478/     4CC :                     ;
    1479/     4CC : 7A 10               RWXROM: MOV     PNTR_H,#(EXTROM >> 8)
    1480/     4CE : 78 80                       MOV     PNTR_L,#(EXTROM & 0ffh)
    1481/     4D0 : 22                  	RET
    1482/     4D1 :                     ;
    1483/     4D1 :                     ;=======
    1484/     4D1 :                     ;
    1485/     4D1 :                     SAVE_PNTR:
    1486/     4D1 :                     ;	Save PNTR variables in cursor.
    1487/     4D1 :                     ;
    1488/     4D1 : 88 51               	MOV	CURS_L,PNTR_L
    1489/     4D3 : 8A 52               	MOV	CURS_H,PNTR_H
    1490/     4D5 : 8C 53               	MOV	C_SAVE,CHAR
    1491/     4D7 : 22                  	RET
    1492/     4D8 :                     ;
    1493/     4D8 :                     ;=======
    1494/     4D8 :                     ;
    1495/     4D8 :                     LOAD_PNTR:
    1496/     4D8 :                     ;	Reload pointer with value saved earlier by SAVE_PNTR.
    1497/     4D8 :                     ;
    1498/     4D8 : AA 52               	MOV	PNTR_H,CURS_H
    1499/     4DA : A8 51               	MOV	PNTR_L,CURS_L
    1500/     4DC : AC 53               	MOV	CHAR,C_SAVE
    1501/     4DE : 22                  	RET
    1502/     4DF :                     ;
    1503/     4DF :                     ;=======
    1504/     4DF :                     ;
    1505/     4DF :                     GET_C:
    1506/     4DF :                     ;	Read character from logical buffer space into A and return.
    1507/     4DF :                     ;
    1508/     4DF : 20 43 02            	JB	RUNMOD,GET_BUF
    1509/     4E2 : E6                  	MOV	A,@PNTR_L
    1510/     4E3 : 22                  	RET
    1511/     4E4 :                     ;
    1512/     4E4 :                     GET_BUF:
    1513/     4E4 :                     ;	Read character from active program buffer space into A and return.
    1514/     4E4 : 20 41 04            	JB	ROMMOD,GETROM
    1515/     4E7 : 8A A0               DD003:  MOV     P2,PNTR_H               ;Select variable storage page.
    1516/     4E9 : E2                          MOVX    A,@PNTR_L               ;Read from external address space.
    1517/     4EA : 22                  	RET
    1518/     4EB :                     ;
    1519/     4EB : E8                  GETROM:	MOV	A,PNTR_L
    1520/     4EC : C5 82               	XCH	A,DPL
    1521/     4EE : CA                  	XCH	A,PNTR_H
    1522/     4EF : C5 83               	XCH	A,DPH
    1523/     4F1 : F8                  	MOV	PNTR_L,A
    1524/     4F2 : E4                  	CLR	A
    1525/     4F3 : 93                  	MOVC	A,@A+DPTR
    1526/     4F4 : C8                  	XCH	A,PNTR_L		;Save char. and load old DPH.
    1527/     4F5 : C5 83               	XCH	A,DPH
    1528/     4F7 : CA                  	XCH	A,PNTR_H
    1529/     4F8 : C5 82               	XCH	A,DPL
    1530/     4FA : C8                  	XCH	A,PNTR_L		;Store DPL and reload byte read.
    1531/     4FB : 22                  	RET
    1532/     4FC :                     ;
    1533/     4FC :                     ;=======
    1534/     4FC :                     ;
    1535/     4FC :                     READ_CHAR:
    1536/     4FC :                     ;	READ_CHAR first tests the state of CHAR_FLG.
    1537/     4FC :                     ;	If it is still cleared, the character most recently read from the line
    1538/     4FC :                     ;	buffer or program buffer has been processed, so read the next
    1539/     4FC :                     ;	character, bump the buffer pointer, and return with the character
    1540/     4FC :                     ;	in both Acc. and CHAR and the CHAR_FLG cleared.
    1541/     4FC :                     ;	If CHAR_FLG has been set by the parsing routines,
    1542/     4FC :                     ;	then CHAR still holds a previously read character which has
    1543/     4FC :                     ;	not yet been processed.  Read this character into Acc. and return
    1544/     4FC :                     ;	with CHAR_FLG again cleared.
    1545/     4FC :                     ;
    1546/     4FC : 10 49 09            	JBC	CHAR_FLG,REREAD
    1547/     4FF : 91 DF               	CALL	GET_C
    1548/     501 : FC                  	MOV	CHAR,A
    1549/     502 : 08                  	INC	PNTR_L
    1550/     503 : B8 00 01            	CJNE	PNTR_L,#00,RDCHDN
    1551/     506 : 0A                  	INC	PNTR_H
    1552/     507 : 22                  RDCHDN:	RET
    1553/     508 :                     ;
    1554/     508 : EC                  REREAD:	MOV	A,CHAR
    1555/     509 : 22                  	RET
    1556/     50A :                     ;
    1557/     50A :                     ;=======
    1558/     50A :                     ;
    1559/     50A :                     PUT_BUF:
    1560/     50A :                     ;	Put the contents of the acc. into program buffer space
    1561/     50A :                     ;	currently active at the address held in <DEST_H><DEST_L>.
    1562/     50A :                     ;
    1563/     50A : 20 41 04            	JB	ROMMOD,PUTROM
    1564/     50D : 8B A0               DD004:  MOV     P2,DEST_H
    1565/     50F : F3                          MOVX    @DEST_L,A
    1566/     510 : 22                  	RET
    1567/     511 :                     ;
    1568/     511 : 21 1A               PUTROM:	JMP	EXP_ER
    1569/     513 :                     ;
    1570/     513 :                     ;=======
    1571/     513 :                     ;
    1572/     513 :                     WRITE_CHAR:
    1573/     513 :                     ;	Converse of READ_CHAR.
    1574/     513 :                     ;	Write contents of acc. into appropriate memory space (@DEST),
    1575/     513 :                     ;	increment DEST, and return.
    1576/     513 :                     ;
    1577/     513 : B1 0A               	CALL	PUT_BUF
    1578/     515 : 09                  	INC	DEST_L
    1579/     516 : B9 00 01            	CJNE	DEST_L,#00H,WRCH_1
    1580/     519 : 0B                  	INC	DEST_H
    1581/     51A : 22                  WRCH_1:	RET
    1582/     51B :                     ;
    1583/     51B :                     ;=======
    1584/     51B :                     ;
    1585/     51B :                     D_BLNK:
    1586/     51B :                     ;	Remove leading blanks from BASIC source line, update cursor,
    1587/     51B :                     ;	load first non-blank character into CHAR,
    1588/     51B :                     ;	and leave pointer loaded with its address.
    1589/     51B :                     ;	(This routine is jumped to by parsing routines when successful,
    1590/     51B :                     ;	so set C before returning to original routines.)
    1591/     51B :                     ;
    1592/     51B : 91 FC               	CALL	READ_CHAR
    1593/     51D : 64 20               	XRL	A,#' '		;Verify that it is non-blank.
    1594/     51F : 60 FA               	JZ	D_BLNK		;Loop until non-blank leading character.
    1595/     521 : D2 49               	SETB	CHAR_FLG
    1596/     523 : D3                  	SETB	C
    1597/     524 : 22                  	RET			;Return to scanning code.
    1598/     525 :                     ;
    1599/     525 :                     ;=======
    1600/     525 :                     ;
    1601/     525 :                     ;SKPLIN
    1602/     525 :                     ;	Skip Cursor over entire BASIC source line, leaving
    1603/     525 :                     ;	cursor pointing to character after terminating <CR>.
    1604/     525 :                     ;SKPTXT
    1605/     525 :                     ;	Skip remainder of line in progress, assuming line number 
    1606/     525 :                     ;	has already been passed over.
    1607/     525 :                     ;	(Note that either byte of binary line number could be
    1608/     525 :                     ;	mis-interpreted as a CR.)
    1609/     525 :                     ;
    1610/     525 :                     ;
    1611/     525 : 91 FC               SKPLIN:	CALL	READ_CHAR
    1612/     527 : 91 FC               	CALL	READ_CHAR
    1613/     529 : 91 FC               SKPTXT:	CALL	READ_CHAR
    1614/     52B : B4 0D FB            	CJNE	A,#CR,SKPTXT	;Verify that it is non-<CR>.
    1615/     52E : 22                  	RET			;Return to scanning code.
    1616/     52F :                     ;
    1617/     52F :                     ;=======
    1618/     52F :                     ;$EJECT
    1619/     52F :                     ;
    1620/     52F :                     ;	Token recognition and processing routines.
    1621/     52F :                     ;
    1622/     52F :                     ;
    1623/     52F :                     TST:
    1624/     52F :                     ;	If "TEMPLATE" matches the BASIC character string read by 
    1625/     52F :                     ;	READ_CHAR then move pointer over string and any trailing blanks
    1626/     52F :                     ;	and continue with the following IL instruction.
    1627/     52F :                     ;	Otherwise leave pointer unchanged and branch to IL instruction at LBL.
    1628/     52F :                     ;
    1629/     52F : D0 83               	POP	DPH		;Get in-line parameter base address from stack.
    1630/     531 : D0 82               	POP	DPL
    1631/     533 : 91 FC               	CALL	READ_CHAR
    1632/     535 : 91 D1               	CALL	SAVE_PNTR
    1633/     537 : E4                  TST_1:	CLR	A
    1634/     538 : 93                  	MOVC	A,@A+DPTR	;Read next character from template string.
    1635/     539 : A2 E7               	MOV	C,ACC.7		;Save terminator bit.
    1636/     53B : 54 7F               	ANL	A,#7FH		;Mask off terminator.
    1637/     53D : 6C                  	XRL	A,CHAR		;Compare with template.
    1638/     53E : 70 12               	JNZ	T_BAD		;Abort if first characters miscompare.
    1639/     540 : A3                  	INC	DPTR		;Pass over template character just checked.
    1640/     541 : 40 0B               	JC	T_GOOD		;Done if template character bit 7 set.
    1641/     543 : 91 FC               	CALL	READ_CHAR	;Fetch next character for test.
    1642/     545 : BC 2E EF            	CJNE	CHAR,#'.',TST_1	;Done if input string abbreviated at this point
    1643/     548 : E4                  TST_2:	CLR	A		;Fetch template characters until end of string
    1644/     549 : 93                  	MOVC	A,@A+DPTR
    1645/     54A : A3                  	INC	DPTR
    1646/     54B : 30 E7 FA            	JNB	ACC.7,TST_2	;Loop until last character detected.
    1647/     54E : B1 1B               T_GOOD:	CALL	D_BLNK
    1648/     550 : E4                  	CLR	A
    1649/     551 : 73                  	JMP	@A+DPTR		;Return to next IL instruction
    1650/     552 :                     ;
    1651/     552 :                     ;	Strings do not match.  Leave cursor at start of string.
    1652/     552 :                     ;
    1653/     552 : E4                  T_BAD:	CLR	A
    1654/     553 : 93                  	MOVC	A,@A+DPTR	;Search for final template character.
    1655/     554 : A3                  	INC	DPTR
    1656/     555 : 30 E7 FA            	JNB	ACC.7,T_BAD	;Loop until terminator found.
    1657/     558 : 91 D8               	CALL	LOAD_PNTR
    1658/     55A : D2 49               	SETB	CHAR_FLG
    1659/     55C : C3                  	CLR	C		;Mark string not found.
    1660/     55D : E4                  	CLR	A
    1661/     55E : 73                  	JMP	@A+DPTR		;Return to mismatch branch instruction.
    1662/     55F :                     ;
    1663/     55F :                     ;===============
    1664/     55F :                     ;
    1665/     55F :                     ;TSTV	(LBL)
    1666/     55F :                     ;
    1667/     55F :                     ;
    1668/     55F :                     TSTV:
    1669/     55F :                     ;	Test if first non-blank string is a legal variable symbol.
    1670/     55F :                     ;	If so, move cursor over string and any trailing blanks,
    1671/     55F :                     ;	compute variable index value,
    1672/     55F :                     ;	push onto arithmetic expression stack,
    1673/     55F :                     ;	and continue with following IL instruction.
    1674/     55F :                     ;	Otherwise branch to IL instruction at LBL with cursor unaffected.
    1675/     55F :                     ;
    1676/     55F : 91 FC               	CALL	READ_CHAR
    1677/     561 : 24 BF               	ADD	A,#-'A'		;Subtract offset for base variable.
    1678/     563 : FE                  	MOV	TOS_L,A		;Save index in case needed later.
    1679/     564 : 24 E6               	ADD	A,#-26
    1680/     566 : 50 04               	JNC	ALPHAB		;First character is alphabetic if C=0.
    1681/     568 : D2 49               	SETB	CHAR_FLG
    1682/     56A : C3                  	CLR	C
    1683/     56B : 22                  	RET
    1684/     56C :                     ;
    1685/     56C : 91 D1               ALPHAB:	CALL	SAVE_PNTR	;In case variable name not found.
    1686/     56E : 91 FC               	CALL	READ_CHAR	;Verify that next character is not alphabetic.
    1687/     570 : 24 BF               	ADD	A,#-'A'		;Alphabetic characters now <= 25.
    1688/     572 : 24 E6               	ADD	A,#-26		;Non-alphabetics cause overflow.
    1689/     574 : 50 03               	JNC	NOTVAR		;Alphabetic character means illegal var. name.
    1690/     576 : BC 2E 40            	CJNE	CHAR,#'.',TSTV_1	;Period indicates abbreviated keyword.
    1691/     579 : 91 D8               NOTVAR:	CALL	LOAD_PNTR
    1692/     57B : D2 49               	SETB	CHAR_FLG
    1693/     57D :                     ;*        %TST    (TSTRBI,DBYTE)  ;Test if direct byte token.
    1694/     57D : B1 2F                       call   tst
    1695/     57F : 44 42 59 54 C5              DB      "DBYT",('E' OR 80H)
    1696/     584 : 50 05                       jnc     tstrbi
    1697/     586 : (MACRO)                     LIT_    1
    1697/     586 : 31 78                       CALL    LIT
    1697/     588 : 01                          DB      1
    1698/     589 : 80 27               	SJMP	INDEX
    1699/     58B :                     ;
    1700/     58B :                     ;*TSTRBI: %TST    (TSTXBY,RBIT)
    1701/     58B : B1 2F               tstrbi: call   tst
    1702/     58D : 52 42 49 D4                 DB      "RBI",('T' OR 80H)
    1703/     591 : 50 05                       jnc     tstxby
    1704/     593 : (MACRO)                     LIT_    2
    1704/     593 : 31 78                       CALL    LIT
    1704/     595 : 02                          DB      2
    1705/     596 : 80 1A               	SJMP	INDEX
    1706/     598 :                     ;
    1707/     598 :                     ;*TSTXBY: %TST    (TSTCBY,XBYTE)  ;Test if expansion RAM byte token.
    1708/     598 : B1 2F               tstxby: call   tst
    1709/     59A : 58 42 59 54 C5              DB      "XBYT",('E' OR 80H)
    1710/     59F : 50 05                       jnc     tstcby
    1711/     5A1 : (MACRO)                     LIT_    3
    1711/     5A1 : 31 78                       CALL    LIT
    1711/     5A3 : 03                          DB      3
    1712/     5A4 : 80 0C               	SJMP	INDEX
    1713/     5A6 :                     ;
    1714/     5A6 :                     ;*TSTCBY: %TST    (NOTSYM,CBYTE)  ;Test if program memory byte token.
    1715/     5A6 : B1 2F               tstcby: call   tst
    1716/     5A8 : 43 42 59 54 C5              DB      "CBYT",('E' OR 80H)
    1717/     5AD : 50 08                       jnc     notsym
    1718/     5AF : (MACRO)                     LIT_    4
    1718/     5AF : 31 78                       CALL    LIT
    1718/     5B1 : 04                          DB      4
    1719/     5B2 : 12 0B 89            INDEX:	CALL	VAR
    1720/     5B5 : D3                  	SETB	C
    1721/     5B6 : 22                  	RET
    1722/     5B7 :                     ;
    1723/     5B7 : C3                  NOTSYM:	CLR	C		;Indicate that condition tested wasn't true.
    1724/     5B8 : 22                  	RET
    1725/     5B9 :                     ;
    1726/     5B9 :                     ;	BASIC Variable name is legitimate (A-Z).
    1727/     5B9 :                     ;
    1728/     5B9 : (MACRO)             TSTV_1:	LIT_	0
    1728/     5B9 : 31 78                       CALL    LIT
    1728/     5BB : 00                          DB      0
    1729/     5BC : 7F 00               	MOV	TOS_H,#0
    1730/     5BE : 31 51               	CALL	PUSH_TOS
    1731/     5C0 : D2 49               	SETB	CHAR_FLG
    1732/     5C2 : A1 1B               	JMP	D_BLNK		;Remove leading blanks from source line.
    1733/     5C4 :                     ;
    1734/     5C4 :                     ;===============
    1735/     5C4 :                     ;
    1736/     5C4 :                     ;TSTN	(LBL)
    1737/     5C4 :                     ;	Test if indicated string is an unsigned number.
    1738/     5C4 :                     ;	If so, move cursor over string and trailing blanks,
    1739/     5C4 :                     ;	compute number's binary value,
    1740/     5C4 :                     ;	push onto arithmetic expression stack, and continue with
    1741/     5C4 :                     ;	following IL instruction.
    1742/     5C4 :                     ;	Otherwise restore cursor and branch to IL instruction at LBL.
    1743/     5C4 :                     ;
    1744/     5C4 :                     ;
    1745/     5C4 : 91 FC               TSTN:	CALL	READ_CHAR
    1746/     5C6 : 51 FE               	CALL	CREATE		;Create entry on AES if legit. digit.
    1747/     5C8 : 40 03               	JC	TSTN_1		;Abort if CHAR is not decimal digit.
    1748/     5CA : D2 49               	SETB	CHAR_FLG
    1749/     5CC : 22                  	RET
    1750/     5CD :                     ;
    1751/     5CD : 91 FC               TSTN_1:	CALL	READ_CHAR	;Move over matched character.
    1752/     5CF : 71 0B               	CALL	APPEND		;Append new digit to entry on TOS.
    1753/     5D1 : 40 FA               	JC	TSTN_1		;Continue processing while legal characters.
    1754/     5D3 : 31 51               	CALL	PUSH_TOS
    1755/     5D5 : D2 49               	SETB	CHAR_FLG
    1756/     5D7 : A1 1B               	JMP	D_BLNK		;Remove leading blank characters.
    1757/     5D9 :                     ;
    1758/     5D9 :                     ;===============
    1759/     5D9 :                     ;
    1760/     5D9 :                     ;TSTL	(LBL)
    1761/     5D9 :                     ;	Test if first non-blank string is a BASIC source line number.
    1762/     5D9 :                     ;	If so, move cursor over string and following blanks,
    1763/     5D9 :                     ;	compute number's binary value,
    1764/     5D9 :                     ;	push onto arithmetic expression stack, 
    1765/     5D9 :                     ;	and continue with next IL instruction.
    1766/     5D9 :                     ;	If invalid source line number report syntax error.
    1767/     5D9 :                     ;	If line number not present restore cursor
    1768/     5D9 :                     ;	and branch to IL instruction at LBL.
    1769/     5D9 :                     ;
    1770/     5D9 :                     ;
    1771/     5D9 :                     ;===============
    1772/     5D9 :                     ;
    1773/     5D9 :                     ;TSTS	(LBL)
    1774/     5D9 :                     ;	Test if first character is a quote.
    1775/     5D9 :                     ;	If so, print characters from the BASIC source program to the console
    1776/     5D9 :                     ;	until a (closing) quote is encountered,
    1777/     5D9 :                     ;	pass over any trailing blanks,
    1778/     5D9 :                     ;	leave source cursor pointing to first non-blank character,
    1779/     5D9 :                     ;	and branch to IL instruction at location (LBL).
    1780/     5D9 :                     ;	(Report syntax error if <CR> encountered before quote.)
    1781/     5D9 :                     ;	If first character is not a quote, return to next
    1782/     5D9 :                     ;	sequential IL instruction with cursor unchanged.
    1783/     5D9 :                     ;
    1784/     5D9 :                     ;
    1785/     5D9 : 91 FC               TSTS:	CALL	READ_CHAR
    1786/     5DB : F5 08               	MOV	TMP0,A
    1787/     5DD : 64 22               	XRL	A,#'"'
    1788/     5DF : 60 08               	JZ	TSTS_1
    1789/     5E1 :                     ;	XRL	A,#'''' XOR '"'
    1790/     5E1 : 64 05               	XRL	A,#(27h ! 22h)
    1791/     5E3 : 60 04               	JZ	TSTS_1
    1792/     5E5 : C3                  	CLR	C
    1793/     5E6 : D2 49               	SETB	CHAR_FLG
    1794/     5E8 : 22                  	RET
    1795/     5E9 :                     ;
    1796/     5E9 : 91 FC               TSTS_1:	CALL	READ_CHAR	;Read next string character.
    1797/     5EB : B5 08 02            	CJNE	A,TMP0,TSTS_2
    1798/     5EE : A1 1B               	JMP	D_BLNK
    1799/     5F0 :                     ;
    1800/     5F0 : 11 B4               TSTS_2:	CALL	C_OUT		;Call output routine.
    1801/     5F2 : B4 0D F4            	CJNE	A,#CR,TSTS_1	;<CR> before closing quote is illegal.
    1802/     5F5 : 21 2E               	JMP	SYN_ER		;Transmit error message.
    1803/     5F7 :                     ;
    1804/     5F7 :                     ;===============
    1805/     5F7 :                     ;
    1806/     5F7 :                     ;DONE
    1807/     5F7 :                     ;	Delete leading blanks from the BASIC source line.
    1808/     5F7 :                     ;	Return with the cursor positioned over the first non-blank
    1809/     5F7 :                     ;	character, which must be a colon or <CR> in the source line.
    1810/     5F7 :                     ;	If any other characters are encountered report a syntax error.
    1811/     5F7 :                     ;
    1812/     5F7 :                     ;
    1813/     5F7 :                     ;
    1814/     5F7 : 91 FC               DONE:	CALL	READ_CHAR
    1815/     5F9 : BC 3A 03            	CJNE	CHAR,#':',DONE_1	;Colon indicates resume interpretation.
    1816/     5FC : 22                  	RET			;Return to IL.
    1817/     5FD :                     ;
    1818/     5FD : 91 FC               LNDONE:	CALL	READ_CHAR
    1819/     5FF : BC 0D 01            DONE_1:	CJNE	CHAR,#CR,DONE_2	;Any non-colon, non-CR characters are illegal.
    1820/     602 : 22                  	RET
    1821/     603 :                     ;
    1822/     603 : D2 49               DONE_2:	SETB	CHAR_FLG
    1823/     605 : 21 2E               	JMP	SYN_ER		;Process syntax error if so.
    1824/     607 :                     ;
    1825/     607 :                     ;=======
    1826/     607 :                     ;
    1827/     607 :                     ;IFDONE	(LBL)
    1828/     607 :                     ;	If the first non-blank character is a colon or <CR> in the source line
    1829/     607 :                     ;	then branch to the IL instruction specified by (LBL).
    1830/     607 :                     ;	If any other characters are encountered
    1831/     607 :                     ;	then continue with next IL instruction.
    1832/     607 :                     ;
    1833/     607 :                     ;
    1834/     607 : 91 FC               IFDONE:	CALL	READ_CHAR
    1835/     609 : BC 3A 01            	CJNE	CHAR,#':',IFDN_1	;Colon indicates resume interpretation.
    1836/     60C : 22                  	RET			;Return to IL.
    1837/     60D :                     ;
    1838/     60D : BC 0D 01            IFDN_1:	CJNE	CHAR,#CR,IFDN_2	;Any non-colon, non-CR characters are illegal.
    1839/     610 : 22                  	RET
    1840/     611 :                     ;
    1841/     611 : D2 49               IFDN_2:	SETB	CHAR_FLG
    1842/     613 : D3                  	SETB	C
    1843/     614 : 22                  	RET
    1844/     615 :                     ;
    1845/     615 :                     ;=======
    1846/     615 :                     
    1847/     615 :                     ;$EJECT
    1848/     615 :                     READ_LABEL:
    1849/     615 :                     ;	Read next two characters from program buffer into <LABL_H><LABL_L>.
    1850/     615 :                     ;	Return with carry set if bit 15 of LABL is set (indicating EOF).
    1851/     615 :                     ;
    1852/     615 : 91 FC               	CALL	READ_CHAR
    1853/     617 : F5 55               	MOV	LABL_H,A
    1854/     619 : 91 FC               	CALL	READ_CHAR
    1855/     61B : F5 54               	MOV	LABL_L,A
    1856/     61D : E5 55               	MOV	A,LABL_H
    1857/     61F : A2 E7               	MOV	C,ACC.7
    1858/     621 : 22                  	RET
    1859/     622 :                     ;
    1860/     622 :                     ;=======
    1861/     622 :                     ;
    1862/     622 :                     ;
    1863/     622 :                     L_INIT:
    1864/     622 :                     ;	Initialize for execution of new BASIC source line.
    1865/     622 :                     ;	If none present, or if not in sequential execution mode, 
    1866/     622 :                     ;	then return to line collection operation.
    1867/     622 :                     ;
    1868/     622 : 30 43 02            	JNB	RUNMOD,LINI_1	;Determine operating mode.
    1869/     625 : 80 EE               	JMP	READ_LABEL
    1870/     627 :                     ;
    1871/     627 : D3                  LINI_1:	SETB	C
    1872/     628 : 22                  	RET
    1873/     629 :                     ;
    1874/     629 :                     ;=======
    1875/     629 :                     ;
    1876/     629 :                     ;
    1877/     629 :                     ;
    1878/     629 :                     NL_NXT:
    1879/     629 :                     ;	Output a <CR><LF> and continue with NXT routine.
    1880/     629 :                     ;
    1881/     629 : 11 B2               	CALL	NLINE
    1882/     62B :                     ;
    1883/     62B :                     NXT:
    1884/     62B :                     ;	A colon or carriage return has been previously READ_CHARed.
    1885/     62B :                     ;	If CHAR holds a colon,
    1886/     62B :                     ;	continue interpretation of source line in current mode
    1887/     62B :                     ;	from IL program instruction "TOKEN".
    1888/     62B :                     ;	Otherwise CHAR is a <CR>, and line has been completed.
    1889/     62B :                     ;	Resume execution from IL instruction "STMT".
    1890/     62B :                     ;
    1891/     62B : BC 3A 05            	CJNE	CHAR,#':',NXT_1	;Skip ahead unless colon detected.
    1892/     62E : B1 1B               	CALL	D_BLNK
    1893/     630 : 02 08 A4            	JMP	TOKEN		;Continue with interpretation.
    1894/     633 :                     ;
    1895/     633 : 02 08 9F            NXT_1:	JMP	STMT
    1896/     636 :                     ;
    1897/     636 :                     ;=======
    1898/     636 :                     ;
    1899/     636 :                     ;$EJECT
    1900/     636 :                     ;
    1901/     636 :                     ;
    1902/     636 :                     GETLN:
    1903/     636 :                     ;	Input a line from console input device and put in line buffer
    1904/     636 :                     ;	in internal RAM.
    1905/     636 :                     ;
    1906/     636 : E5 2A               	MOV	A,AESP
    1907/     638 : 24 04               	ADD	A,#4
    1908/     63A : F5 08               	MOV	TMP0,A
    1909/     63C : A8 08               GETL_0:	MOV	R0,TMP0		;Point to beginning of line buffer.
    1910/     63E : 31 05               	CALL	STROUT
    1911/     640 : BE                          DB      ('>' OR 80H)
    1912/     641 : 11 97               GETL_1:	CALL	C_IN		;Get next character from console.
    1913/     643 : B4 12 12            	CJNE	A,#12H,GETL_5	;Re-type line on <CNTRL-R>.
    1914/     646 : 31 05               	CALL	STROUT
    1915/     648 : 8D                          DB      (CR OR 80H)     ;Newline.
    1916/     649 : 88 51               	MOV	CURS_L,R0	;Save old value of cursor.
    1917/     64B : A8 08               	MOV	R0,TMP0		;Start at beginning of line buffer.
    1918/     64D : E8                  GETL_6:	MOV	A,R0		;Check if re-write done.
    1919/     64E : 65 51               	XRL	A,CURS_L
    1920/     650 : 60 EF               	JZ	GETL_1		;Continue with line input.
    1921/     652 : E6                  	MOV	A,@R0		;Load character to re-write.
    1922/     653 : 11 B4               	CALL	C_OUT
    1923/     655 : 08                  	INC	R0
    1924/     656 : 80 F5               	SJMP	GETL_6		;Continue until done.
    1925/     658 :                     ;
    1926/     658 : B4 18 06            GETL_5:	CJNE	A,#18H,GETL_7	;Cancel whole line on <CNTRL-X>.
    1927/     65B : 31 05               	CALL	STROUT
    1928/     65D : 23 8D                       DB      '#',(CR OR 80H) ;Advance to next line.
    1929/     65F : 80 DB               	SJMP	GETL_0
    1930/     661 :                     ;
    1931/     661 : B4 7F 11            GETL_7:	CJNE	A,#7FH,GETL_3
    1932/     664 : E8                  	MOV	A,R0
    1933/     665 : B5 08 05            	CJNE	A,TMP0,GETL_4	;Delete previous character (if any).
    1934/     668 : 31 05               	CALL	STROUT
    1935/     66A : 87                          DB      (BEL OR 80H)    ;Echo <BEL>.
    1936/     66B : 80 D4               	SJMP	GETL_1		;Ignore rubouts at beginning of line
    1937/     66D :                     ;
    1938/     66D : 31 05               GETL_4:	CALL	STROUT
    1939/     66F : 08 20 88            	DB	08H,' ',88H	;BKSP,SPC,BKSP
    1940/     672 : 18                  	DEC	R0		;Wipeout last char.
    1941/     673 : 80 CC               	SJMP	GETL_1
    1942/     675 :                     ;
    1943/     675 : B8 4E 05            GETL_3:	CJNE	R0,#AES+AESLEN-1,GETL_2	;Test if buffer full.
    1944/     678 : 31 05               	CALL	STROUT		;Echo <BEL>.
    1945/     67A : 87                          DB      (BEL OR 80H)
    1946/     67B : 80 C4               	SJMP	GETL_1		;If so, override character received.
    1947/     67D :                     ;
    1948/     67D : F6                  GETL_2:	MOV	@R0,A		;Store into line buffer.
    1949/     67E : 11 B4               	CALL	C_OUT		;Echo character.
    1950/     680 : 08                  	INC	R0		;Bump pointer.
    1951/     681 : B4 0D BD            	CJNE	A,#CR,GETL_1	;Repeat for next character.
    1952/     684 : A8 08               	MOV	PNTR_L,TMP0	;Point cursor to beginning of line buffer.
    1953/     686 : C2 49               	CLR	CHAR_FLG
    1954/     688 : 22                  	RET
    1955/     689 :                     ;
    1956/     689 :                     ;===============
    1957/     689 :                     ;
    1958/     689 :                     ;
    1959/     689 :                     PRN:
    1960/     689 :                     ;	Pop top of arithmetic expression stack (AES), 
    1961/     689 :                     ;	convert to decimal number,
    1962/     689 :                     ;	and print to console output device, suppressing leading zeroes.
    1963/     689 :                     ;
    1964/     689 : C2 4A               	CLR	SGN_FLG
    1965/     68B : 71 A5               	CALL	IABS
    1966/     68D : 31 39               	CALL	POP_TOS
    1967/     68F : D2 48               PRNTOS:	SETB	ZERSUP		;Set zero suppression flag.
    1968/     691 : E4                  	CLR	A
    1969/     692 : F5 08               	MOV	TMP0,A
    1970/     694 : 7D 10               	MOV	LP_CNT,#16	;Conversion precision.
    1971/     696 : 20 44 1D            	JB	HEXMOD,PRNHEX
    1972/     699 : 30 4A 03            	JNB	SGN_FLG,PRN_1	;Skip ahead if positive number.
    1973/     69C : 31 05               	CALL	STROUT		;Output minus sign if negative.
    1974/     69E : AD                          DB      ('-' OR 80H)
    1975/     69F : CE                  PRN_1:	XCH	A,TOS_L
    1976/     6A0 : 33                  	RLC	A
    1977/     6A1 : CE                  	XCH	A,TOS_L
    1978/     6A2 : CF                  	XCH	A,TOS_H
    1979/     6A3 : 33                  	RLC	A
    1980/     6A4 : CF                  	XCH	A,TOS_H
    1981/     6A5 : C5 08               	XCH	A,TMP0
    1982/     6A7 : 35 E0               	ADDC	A,ACC
    1983/     6A9 : D4                  	DA	A
    1984/     6AA : C5 08               	XCH	A,TMP0
    1985/     6AC : 35 E0               	ADDC	A,ACC
    1986/     6AE : D4                  	DA	A
    1987/     6AF : DD EE               	DJNZ	LP_CNT,PRN_1
    1988/     6B1 : FF                  	MOV	TOS_H,A
    1989/     6B2 : EE                  	MOV	A,TOS_L
    1990/     6B3 : 33                  	RLC	A
    1991/     6B4 : AE 08               	MOV	TOS_L,TMP0
    1992/     6B6 : 11 E6               PRNHEX:	CALL	NIBOUT
    1993/     6B8 : EF                  	MOV	A,TOS_H
    1994/     6B9 : C4                  	SWAP	A
    1995/     6BA : 11 E6               	CALL	NIBOUT		;Print second digit.
    1996/     6BC : EF                  	MOV	A,TOS_H
    1997/     6BD : 11 E6               	CALL	NIBOUT		;Print third digit.
    1998/     6BF : 30 44 02            	JNB	HEXMOD,PRNH_1
    1999/     6C2 : C2 48               	CLR	ZERSUP		;Print out last two chars. (at least) in hex.
    2000/     6C4 : EE                  PRNH_1:	MOV	A,TOS_L		;Read into Acc.
    2001/     6C5 : C4                  	SWAP	A		;Interchange nibbles.
    2002/     6C6 : 11 E6               	CALL	NIBOUT		;Print fourth digit.
    2003/     6C8 : C2 48               	CLR	ZERSUP
    2004/     6CA : EE                  	MOV	A,TOS_L		;Reload byte.
    2005/     6CB : 11 E6               	CALL	NIBOUT		;Print last digit.
    2006/     6CD : 30 44 03            	JNB	HEXMOD,PRNRET
    2007/     6D0 : 31 05               	CALL	STROUT		;Print trailing "H".
    2008/     6D2 : C8                          DB      ('H' OR 80H)
    2009/     6D3 : 22                  PRNRET:	RET
    2010/     6D4 :                     ;
    2011/     6D4 :                     ;===============
    2012/     6D4 :                     ;
    2013/     6D4 :                     LSTLIN:
    2014/     6D4 :                     ;	Check Label of Program line pointed to by Cursor.
    2015/     6D4 :                     ;	If legal, print line number, source line, and <CR><LF> to console,
    2016/     6D4 :                     ;	adjust Cursor to start of next line, 
    2017/     6D4 :                     ;	and return with carry set.
    2018/     6D4 :                     ;	Else return with carry cleared.
    2019/     6D4 :                     ;
    2020/     6D4 : D1 15               	CALL	READ_LABEL
    2021/     6D6 : 40 12               	JC	LSTL_1
    2022/     6D8 : AF 55               	MOV	TOS_H,LABL_H
    2023/     6DA : AE 54               	MOV	TOS_L,LABL_L
    2024/     6DC : C2 4A               	CLR	SGN_FLG
    2025/     6DE : D1 8F               	CALL	PRNTOS
    2026/     6E0 : 31 05               	CALL	STROUT		;Insert space before user's source line.
    2027/     6E2 : A0                          DB      (' ' OR 80H)
    2028/     6E3 : 91 FC               LSTL_2:	CALL	READ_CHAR
    2029/     6E5 : 11 B4               	CALL	C_OUT
    2030/     6E7 : B4 0D F9            	CJNE	A,#CR,LSTL_2
    2031/     6EA : 22                  LSTL_1:	RET
    2032/     6EB :                     ;
    2033/     6EB :                     ;===============
    2034/     6EB :                     ;
    2035/     6EB :                     ;LST
    2036/     6EB :                     ;	List the contents of the program memory area.
    2037/     6EB :                     ;
    2038/     6EB :                     ;
    2039/     6EB : D2 43               LST:	SETB	RUNMOD
    2040/     6ED : 91 BA               	CALL	REWIND		;Point to first char of external buffer.
    2041/     6EF : 11 D1               LST_1:	CALL	CNTRL
    2042/     6F1 : 40 04               	JC	LSTRET
    2043/     6F3 : D1 D4               	CALL	LSTLIN		;Print out current line if present.
    2044/     6F5 : 50 F8               	JNC	LST_1		;Repeat if successful.
    2045/     6F7 : C2 43               LSTRET:	CLR	RUNMOD
    2046/     6F9 : 22                  	RET
    2047/     6FA :                     ;
    2048/     6FA :                     ;===============
    2049/     6FA :                     ;
    2050/     6FA :                     ;
    2051/     6FA :                     INNUM:
    2052/     6FA :                     ;	Read a numeric character string from the console input device.
    2053/     6FA :                     ;	Convert to binary value and push onto arithmetic expression stack.
    2054/     6FA :                     ;	Report error if illegal characters read.
    2055/     6FA :                     ;
    2056/     6FA : C2 4A               	CLR	SGN_FLG		;Assume number will be positive.
    2057/     6FC : 31 05               	CALL	STROUT
    2058/     6FE : 3A A0                       DB      ':',(' ' OR 80H);Print input prompt.
    2059/     700 : 11 97               INUM_0:	CALL	C_IN
    2060/     702 : 11 B4               	CALL	C_OUT		;Echo input
    2061/     704 : B4 20 02            	CJNE	A,#' ',INUM_3
    2062/     707 : 80 F7               	SJMP	INUM_0
    2063/     709 :                     ;
    2064/     709 : B4 2B 02            INUM_3:	CJNE	A,#'+',INUM_4
    2065/     70C : 80 F2               	SJMP	INUM_0
    2066/     70E :                     ;
    2067/     70E : B4 2D 04            INUM_4:	CJNE	A,#'-',INUM_5
    2068/     711 : B2 4A               	CPL	SGN_FLG
    2069/     713 : 80 EB               	SJMP	INUM_0
    2070/     715 :                     ;
    2071/     715 : 51 FE               INUM_5:	CALL	CREATE		;Create value on stack if legal decimal digit.
    2072/     717 : 50 07               	JNC	INUM_2		;Abort if first character received not legal.
    2073/     719 : 11 97               INUM_1:	CALL	C_IN		;Get additional characters.
    2074/     71B : 11 B4               	CALL	C_OUT		;Echo input.
    2075/     71D : B4 7F 06            	CJNE	A,#7FH,INUM_6	;Start over if delete char detected.
    2076/     720 : 31 05               INUM_2:	CALL	STROUT
    2077/     722 : 23 8D                       DB      '#',(CR OR 80H)
    2078/     724 : 80 D4               	SJMP	INNUM
    2079/     726 :                     ;
    2080/     726 : 71 0B               INUM_6:	CALL	APPEND		;Incorporate into stack entry.
    2081/     728 : 40 EF               	JC	INUM_1		;Loop while legal characters arrive.
    2082/     72A : 31 51               	CALL	PUSH_TOS
    2083/     72C : 61 AF               	JMP	NEG_IF_NEG
    2084/     72E :                     ;
    2085/     72E :                     ;===============
    2086/     72E :                     ;$EJECT
    2087/     72E :                     RAM_INIT:
    2088/     72E : E4                  	CLR	A		;Many bytes to be cleared...
    2089/     72F : F5 28               	MOV	MODE,A		;Interactive mode, decimal radix.
    2090/     731 : F5 29               	MOV	FLAGS,A		;Interroutine flags.
    2091/     733 : 75 A0 20            DD010:  MOV     P2,#(EXTRAM >> 8);Select first External RAM page.
    2092/     736 : F8                          MOV     R0,A
    2093/     737 : 74 5A               	MOV	A,#5AH		;Random bit pattern.
    2094/     739 : F2                  	MOVX	@R0,A
    2095/     73A : E2                  	MOVX	A,@R0
    2096/     73B : 64 5A               	XRL	A,#5AH
    2097/     73D : 60 0A               	JZ	EXTINI
    2098/     73F : E4                  	CLR	A
    2099/     740 : 78 10               	MOV	R0,#US_VAR	;Clear variable array.
    2100/     742 : F6                  INIT_1:	MOV	@R0,A
    2101/     743 : 08                  	INC	R0
    2102/     744 : B8 28 FB            	CJNE	R0,#US_VAR+2*NO_VAR,INIT_1	;Loop until all vars cleared.
    2103/     747 : 80 09               	SJMP	INIT_3
    2104/     749 :                     ;
    2105/     749 : D2 40               EXTINI:	SETB	EXTVAR
    2106/     74B : E4                  	CLR	A
    2107/     74C : F8                  	MOV	R0,A		;Clear variable array.
    2108/     74D : F2                  INIT_2:	MOVX	@R0,A
    2109/     74E : 08                  	INC	R0
    2110/     74F : B8 34 FB            	CJNE	R0,#2*26,INIT_2	;Loop until all vars cleared.
    2111/     752 : 22                  INIT_3:	RET
    2112/     753 :                     ;
    2113/     753 :                     ;========
    2114/     753 :                     ;
    2115/     753 :                     ;INIT
    2116/     753 :                     ;	Perform global initialization:
    2117/     753 :                     ;	Clear program memory, empty all I/O buffers, reset all stack
    2118/     753 :                     ;	pointers, etc.
    2119/     753 :                     ;
    2120/     753 :                     ;
    2121/     753 : F1 2E               INIT:	CALL	RAM_INIT
    2122/     755 : 78 34                       MOV     R0,#(EXTRAM & 0ffh)
    2123/     757 : 74 FF               	MOV	A,#0FFH
    2124/     759 : F2                  	MOVX	@R0,A
    2125/     75A : 22                  	RET
    2126/     75B :                     ;
    2127/     75B :                     ;===============
    2128/     75B :                     ;
    2129/     75B :                     ;$EJECT
    2130/     75B :                     ;
    2131/     75B :                     ;	BASIC PROGRAM LINE SEQUENCE CONTROL MACROS:
    2132/     75B :                     ;	===== ======= ==== ======== ======= ======
    2133/     75B :                     ;
    2134/     75B :                     ;XINIT
    2135/     75B :                     ;	Perform initialization needed before starting sequential execution.
    2136/     75B :                     ;	Empty stacks, set BASIC line number to 1, etc.
    2137/     75B :                     ;
    2138/     75B :                     ;
    2139/     75B : 75 2A 2A            XINIT:	MOV	AESP,#AES-1	;Initialize AE Stack.
    2140/     75E : 91 BA               	CALL	REWIND
    2141/     760 : D2 43               	SETB	RUNMOD
    2142/     762 : 22                  	RET			;Begin execution.
    2143/     763 :                     ;
    2144/     763 :                     ;===============
    2145/     763 :                     ;
    2146/     763 :                     FNDLBL:
    2147/     763 :                     ;	Search program buffer for line with label passed on AES (Pop AES).
    2148/     763 :                     ;	If found, return with CURSOR pointing to start of line (before label)
    2149/     763 :                     ;	and carry cleared.
    2150/     763 :                     ;	If not found return with carry set and pointer at start of first
    2151/     763 :                     ;	line with a greater label value (possible EOF).
    2152/     763 :                     ;
    2153/     763 : D2 43               	SETB	RUNMOD		;Kludge to make GET_C fetch from prog. buffer.
    2154/     765 : 91 BA               	CALL	REWIND
    2155/     767 : 31 39               	CALL	POP_TOS
    2156/     769 : 91 D1               FND_1:	CALL	SAVE_PNTR	;Store position of beginning of line.
    2157/     76B : D1 15               	CALL	READ_LABEL
    2158/     76D : 40 12               	JC	FNDDON
    2159/     76F : EE                  	MOV	A,TOS_L
    2160/     770 : 95 54               	SUBB	A,LABL_L
    2161/     772 : F5 54               	MOV	LABL_L,A	;Save non-zero bits.
    2162/     774 : EF                  	MOV	A,TOS_H
    2163/     775 : 95 55               	SUBB	A,LABL_H
    2164/     777 : 45 54               	ORL	A,LABL_L	;Test for non-zero bits.
    2165/     779 : 60 06               	JZ	FNDDON
    2166/     77B : 40 04               	JC	FNDDON		;Carry=1 if a greater label value found.
    2167/     77D : B1 29               	CALL	SKPTXT		;Skip over remaining text portion of line.
    2168/     77F : 80 E8               	SJMP	FND_1
    2169/     781 :                     ;
    2170/     781 : 81 D8               FNDDON:	JMP	LOAD_PNTR
    2171/     783 :                     ;
    2172/     783 :                     ;=======
    2173/     783 :                     ;
    2174/     783 :                     KILL_L:
    2175/     783 :                     ;	Kill (delete) line from code buffer indicated by pointer.
    2176/     783 :                     ;	When called, CURSOR and POINTER hold the address of first LABEL byte of
    2177/     783 :                     ;	line to be deleted.
    2178/     783 :                     ;
    2179/     783 : A9 51               	MOV	DEST_L,CURS_L
    2180/     785 : AB 52               	MOV	DEST_H,CURS_H
    2181/     787 : B1 25               	CALL	SKPLIN		;Pass pointer over full text line.
    2182/     789 :                     ;
    2183/     789 :                     ;	Pointer now indicates first label byte of following line.
    2184/     789 :                     ;	Cursor and DEST still indicate first label byte of obsolete line.
    2185/     789 :                     ;
    2186/     789 : 91 FC               KILL_2:	CALL	READ_CHAR	;Copy down first label byte.
    2187/     78B : B1 13               	CALL	WRITE_CHAR	;Transfer first byte of label number.
    2188/     78D : 20 E7 0D            	JB	ACC.7,KILL_9	;Quit when End of Code sentinel reached.
    2189/     790 : 91 FC               	CALL	READ_CHAR	;Copy down second label byte.
    2190/     792 : B1 13               	CALL	WRITE_CHAR	;Store second byte of label number.
    2191/     794 : 91 FC               KILL_3:	CALL	READ_CHAR	;Transfer text character.
    2192/     796 : B1 13               	CALL	WRITE_CHAR
    2193/     798 : B4 0D F9            	CJNE	A,#CR,KILL_3	;Loop until full line moved.
    2194/     79B : 80 EC               	SJMP	KILL_2		;Continue until all code moved forward.
    2195/     79D :                     ;
    2196/     79D : 22                  KILL_9:	RET			;Full line now deleted.
    2197/     79E :                     ;
    2198/     79E :                     ;=======
    2199/     79E :                     ;
    2200/     79E :                     OPEN_L:
    2201/     79E :                     ;	Open space for new line in code buffer starting at Cursor.
    2202/     79E :                     ;
    2203/     79E : 91 D8               	CALL	LOAD_PNTR	;Load address of point for insertion.
    2204/     7A0 : C2 49               	CLR	CHAR_FLG
    2205/     7A2 : 91 FC               OPEN_3:	CALL	READ_CHAR	;Test first label byte of following line.
    2206/     7A4 : 20 E7 09            	JB	ACC.7,OPEN_4
    2207/     7A7 : 91 FC               	CALL	READ_CHAR	;Pass over next LABEL byte.
    2208/     7A9 : 91 FC               OPEN_5:	CALL	READ_CHAR
    2209/     7AB : B4 0D FB            	CJNE	A,#CR,OPEN_5
    2210/     7AE : 80 F2               	SJMP	OPEN_3
    2211/     7B0 :                     ;
    2212/     7B0 :                     ;	Pointer now indicates end-of-buffer sentinel.
    2213/     7B0 :                     ;
    2214/     7B0 : E5 0F               OPEN_4:	MOV	A,STRLEN	;Number of bytes needed for BASIC text.
    2215/     7B2 : 24 03               	ADD	A,#3		;Space needed for for label and <CR>.
    2216/     7B4 : 28                  	ADD	A,R0		;Low-order byte of old pointer.
    2217/     7B5 : F9                  	MOV	DEST_L,A
    2218/     7B6 : E4                  	CLR	A
    2219/     7B7 : 3A                  	ADDC	A,PNTR_H
    2220/     7B8 : FB                  	MOV	DEST_H,A
    2221/     7B9 : B4 30 02                    CJNE    A,#(RAMLIM >> 8),OPEN_1
    2222/     7BC : 21 23               	JMP	AES_ER
    2223/     7BE :                     ;
    2224/     7BE :                     ;	Transfer characters from source back to destination
    2225/     7BE :                     ;	until pointer at original CURSOR value.
    2226/     7BE :                     ;
    2227/     7BE : 91 E4               OPEN_1:	CALL	GET_BUF		;Move back next character.
    2228/     7C0 : B1 0A               	CALL	PUT_BUF
    2229/     7C2 : E8                  	MOV	A,PNTR_L
    2230/     7C3 : B5 51 05            	CJNE	A,CURS_L,OPEN_2
    2231/     7C6 : EA                  	MOV	A,PNTR_H
    2232/     7C7 : B5 52 01            	CJNE	A,CURS_H,OPEN_2
    2233/     7CA :                     ;
    2234/     7CA :                     ;	All bytes have been moved back.
    2235/     7CA :                     ;
    2236/     7CA : 22                  	RET
    2237/     7CB :                     ;
    2238/     7CB :                     OPEN_2:
    2239/     7CB :                     ;	Decrement src. and dest. pointers and repeat.
    2240/     7CB :                     ;
    2241/     7CB : 18                  	DEC	PNTR_L
    2242/     7CC : B8 FF 01            	CJNE	PNTR_L,#0FFH,OPEN_6
    2243/     7CF : 1A                  	DEC	PNTR_H
    2244/     7D0 : 19                  OPEN_6:	DEC	DEST_L
    2245/     7D1 : B9 FF EA            	CJNE	DEST_L,#0FFH,OPEN_1
    2246/     7D4 : 1B                  	DEC	DEST_H
    2247/     7D5 : 80 E7               	SJMP	OPEN_1		;Repeat for next character.
    2248/     7D7 :                     ;
    2249/     7D7 :                     ;=======
    2250/     7D7 :                     ;
    2251/     7D7 :                     INSR_L:
    2252/     7D7 :                     ;	Insert program line label (still held in <TOS_H><TOS_L> from earlier
    2253/     7D7 :                     ;	call to FNDLBL)
    2254/     7D7 :                     ;	and character string in line buffer (pointed at by L_CURS)
    2255/     7D7 :                     ;	into program buffer gap created by OPEN_L routine
    2256/     7D7 :                     ;	(still pointed at by CURSOR).
    2257/     7D7 :                     ;
    2258/     7D7 : A9 51               	MOV	DEST_L,CURS_L
    2259/     7D9 : AB 52               	MOV	DEST_H,CURS_H
    2260/     7DB : EF                  	MOV	A,TOS_H
    2261/     7DC : B1 13               	CALL	WRITE_CHAR
    2262/     7DE : EE                  	MOV	A,TOS_L
    2263/     7DF : B1 13               	CALL	WRITE_CHAR
    2264/     7E1 : A8 4F               	MOV	PNTR_L,L_CURS
    2265/     7E3 : E6                  INSL_1:	MOV	A,@PNTR_L
    2266/     7E4 : B1 13               	CALL	WRITE_CHAR
    2267/     7E6 : 08                  	INC	PNTR_L
    2268/     7E7 : B4 0D F9            	CJNE	A,#CR,INSL_1
    2269/     7EA : 22                  	RET
    2270/     7EB :                     ;
    2271/     7EB :                     ;=======
    2272/     7EB :                     ;
    2273/     7EB :                     ;
    2274/     7EB :                     INSRT:
    2275/     7EB :                     ;	Pop line number from top of arithmetic expression stack.
    2276/     7EB :                     ;	Search BASIC source program for corresponding line number.
    2277/     7EB :                     ;	If found, delete old line.
    2278/     7EB :                     ;	Otherwise position cursor before next sequential line number.
    2279/     7EB :                     ;	If line buffer is not empty then insert line number, contents of
    2280/     7EB :                     ;	line buffer, and line terminator.
    2281/     7EB :                     ;
    2282/     7EB : 18                  	DEC	PNTR_L		;Since previous D_BLNK passed over first char.
    2283/     7EC : 88 4F               	MOV	L_CURS,PNTR_L
    2284/     7EE : F1 63               	CALL	FNDLBL
    2285/     7F0 : 40 02               	JC	INSR_1
    2286/     7F2 : F1 83               	CALL	KILL_L		;Delete line iff label found in buffer.
    2287/     7F4 : A9 4F               INSR_1:	MOV	R1,L_CURS
    2288/     7F6 : 19                  	DEC	R1
    2289/     7F7 : 09                  INSR_2:	INC	R1
    2290/     7F8 : E7                  	MOV	A,@R1
    2291/     7F9 : B4 0D FB            	CJNE	A,#CR,INSR_2
    2292/     7FC : E9                  	MOV	A,R1
    2293/     7FD : C3                  	CLR	C
    2294/     7FE : 95 4F               	SUBB	A,L_CURS
    2295/     800 : F5 0F               	MOV	STRLEN,A
    2296/     802 : 60 06               	JZ	INSR_4
    2297/     804 : 12 07 9E            	CALL	OPEN_L
    2298/     807 : 12 07 D7            	CALL	INSR_L
    2299/     80A : C2 43               INSR_4:	CLR	RUNMOD
    2300/     80C : 22                  	RET
    2301/     80D :                     ;
    2302/     80D :                     ;===============
    2303/     80D :                     ;
    2304/     80D :                     ;
    2305/     80D : 12 01 39            COND:	CALL	POP_TOS
    2306/     810 : EE                  	MOV	A,TOS_L
    2307/     811 : 13                  	RRC	A
    2308/     812 : 22                  	RET
    2309/     813 :                     ;
    2310/     813 :                     ;=======
    2311/     813 :                     ;
    2312/     813 :                     ;XFER
    2313/     813 :                     ;	Pop the value from the top of the arithmetic expression stack (AES).
    2314/     813 :                     ;	Position cursor at beginning of the BASIC source program line
    2315/     813 :                     ;	with that label and begin source interpretation.
    2316/     813 :                     ;	(Report error if corresponding source line not found.)
    2317/     813 :                     ;
    2318/     813 :                     ;
    2319/     813 : 12 07 63            XFER:	CALL	FNDLBL
    2320/     816 : 40 02               	JC	XFERNG
    2321/     818 : 01 9F               	JMP	STMT		;Begin execution of source line.
    2322/     81A :                     ;
    2323/     81A : 02 01 1A            XFERNG:	JMP	EXP_ER
    2324/     81D :                     ;
    2325/     81D :                     ;===============
    2326/     81D :                     ;
    2327/     81D :                     ;
    2328/     81D :                     SAV:
    2329/     81D :                     ;	Push BASIC line number of current source line onto AES.
    2330/     81D :                     ;
    2331/     81D : AF 55               	MOV	TOS_H,LABL_H
    2332/     81F : AE 54               	MOV	TOS_L,LABL_L
    2333/     821 : 02 01 51            	JMP	PUSH_TOS
    2334/     824 :                     ;
    2335/     824 :                     ;===============
    2336/     824 :                     ;
    2337/     824 :                     ;
    2338/     824 :                     RSTR:
    2339/     824 :                     ;	If AES is empty report a nesting error.
    2340/     824 :                     ;	Otherwise, pop AES into current BASIC souce program line number.
    2341/     824 :                     ;
    2342/     824 : 12 07 63            	CALL	FNDLBL
    2343/     827 : 12 05 25            	CALL	SKPLIN		;Pass over statement initiating transfer.
    2344/     82A : 80 73               	JMP	STMT
    2345/     82C :                     ;
    2346/     82C :                     ;===============
    2347/     82C :                     ;
    2348/     82C :                     ;
    2349/     82C :                     LOOP:
    2350/     82C :                     ;	LOOP is called with the AES holding:
    2351/     82C :                     ;	(TOS:)	2 byte VALUE of variable after being incremented,
    2352/     82C :                     ;		2 byte INDEX of variable being incremented,
    2353/     82C :                     ;		1 byte TYPE of variable code,
    2354/     82C :                     ;		2 byte LABEL of line initiating FOR loop,
    2355/     82C :                     ;		2 byte LIMIT specified by FOR statement,
    2356/     82C :                     ;		2 byte INDEX of variable used by FOR loop,
    2357/     82C :                     ;		1 byte TYPE of variable code.
    2358/     82C :                     ;	If indices disagree, then generate syntax error.
    2359/     82C :                     ;	Otherwise, store incremented value in variable popping both from AES.
    2360/     82C :                     ;	If the incremented value <= LIMIT then return with carry set.
    2361/     82C :                     ;	If incr. val. > LIMIT looping is done, so return with carry not set.
    2362/     82C :                     ;
    2363/     82C :                     ;	Compare all three bytes of variable index.
    2364/     82C : E8                  	MOV	A,R0
    2365/     82D : C0 E0               	PUSH	ACC
    2366/     82F : E5 2A               	MOV	A,AESP
    2367/     831 : 24 FE               	ADD	A,#-2
    2368/     833 : F9                  	MOV	R1,A
    2369/     834 : 24 F9               	ADD	A,#-7
    2370/     836 : F8                  	MOV	R0,A
    2371/     837 : 7D 03               	MOV	LP_CNT,#3	;Set to test three bytes.
    2372/     839 : E7                  LOOP_0:	MOV	A,@R1
    2373/     83A : 66                  	XRL	A,@R0
    2374/     83B : 70 20               	JNZ	LOOP_1
    2375/     83D : 18                  	DEC	R0
    2376/     83E : 19                  	DEC	R1
    2377/     83F : DD F8               	DJNZ	LP_CNT,LOOP_0
    2378/     841 :                     ;
    2379/     841 :                     ;	All three bytes of variable code match.
    2380/     841 : D0 E0               	POP	ACC
    2381/     843 : F8                  	MOV	R0,A
    2382/     844 : 12 02 3D            	CALL	STORE
    2383/     847 : E5 2A               	MOV	A,AESP
    2384/     849 : 24 FD               	ADD	A,#-3
    2385/     84B : F9                  	MOV	R1,A
    2386/     84C : C3                  	CLR	C
    2387/     84D : E7                  	MOV	A,@R1
    2388/     84E : 95 08               	SUBB	A,TMP0
    2389/     850 : 09                  	INC	R1
    2390/     851 : E7                  	MOV	A,@R1
    2391/     852 : 20 44 05            	JB	HEXMOD,LOOP_2	;Branch forward if unsigned compare correct.
    2392/     855 : 64 80               	XRL	A,#80H		;Adjust sign bits so signed compare valid.
    2393/     857 : 63 09 80            	XRL	TMP1,#80H
    2394/     85A : 95 09               LOOP_2:	SUBB	A,TMP1
    2395/     85C : 22                  	RET
    2396/     85D :                     ;
    2397/     85D :                     ;	Indices don't match.
    2398/     85D :                     ;
    2399/     85D : D0 E0               LOOP_1:	POP	ACC
    2400/     85F : F8                  	MOV	R0,A
    2401/     860 : 02 01 2E            	JMP	SYN_ER
    2402/     863 :                     ;
    2403/     863 :                     ;=======
    2404/     863 :                     ;
    2405/     863 :                     ;FIN
    2406/     863 :                     ;	Return to line collection routine.
    2407/     863 :                     ;
    2408/     863 :                     ;
    2409/     863 : C2 43               FIN:	CLR	RUNMOD
    2410/     865 : 80 1F               	JMP	CONT		;Return to line collection mode.
    2411/     867 :                     ;
    2412/     867 :                     ;===============
    2413/     867 :                     ;
    2414/     867 :                     ;$EJECT
    2415/     867 :                     ;
    2416/     867 :                     ;	IL SEQUENCE CONTROL INSTRUCTIONS:
    2417/     867 :                     ;	== ======== ======= ============
    2418/     867 :                     ;
    2419/     867 :                     ;IJMP	(LBL)
    2420/     867 :                     ;	Jump to the (potentially distant) IL instruction at location LBL.
    2421/     867 :                     ;Note:	In this implementation IL addresses are equivalent to machine
    2422/     867 :                     ;	language addresses, so IJMP performs a generic JMP.
    2423/     867 :                     ;
    2424/     867 :                     ;
    2425/     867 :                     ;===============
    2426/     867 :                     ;
    2427/     867 :                     ;HOP	(LBL)
    2428/     867 :                     ;	Perform a branch to the IL instruction at (nearby) location LBL.
    2429/     867 :                     ;Note:	In this implementation IL addresses are equivalent to machine
    2430/     867 :                     ;	language addresses, so HOP performs a simple relative SJMP.
    2431/     867 :                     ;
    2432/     867 :                     ;
    2433/     867 :                     ;===============
    2434/     867 :                     ;
    2435/     867 :                     ;ICALL	(LBL)
    2436/     867 :                     ;	Call the IL subroutine starting at instruction LBL.
    2437/     867 :                     ;	Save the location of the next IL instruction on the control stack.
    2438/     867 :                     ;Note:	In this implementation, IL addresses are identical with 
    2439/     867 :                     ;	machine language addresses, and are saved on the MCS-51 hardware stack.
    2440/     867 :                     ;
    2441/     867 :                     ;
    2442/     867 :                     ;===============
    2443/     867 :                     ;
    2444/     867 :                     ;IRET
    2445/     867 :                     ;	Return from IL subroutine to location on top of control stack.
    2446/     867 :                     ;Note:	In this implementation, IL addresses are identical with machine 
    2447/     867 :                     ;	language addresses, which are saved on the hardware stack.
    2448/     867 :                     ;
    2449/     867 :                     ;
    2450/     867 :                     ;===============
    2451/     867 :                     ;
    2452/     867 :                     ;MLCALL
    2453/     867 :                     ;	Call the ML subroutine starting at the address on top of AES.
    2454/     867 :                     ;
    2455/     867 :                     ;
    2456/     867 : A9 2A               MLCALL:	MOV	R1,AESP
    2457/     869 : 87 F0               	MOV	B,@R1
    2458/     86B : 19                  	DEC	R1
    2459/     86C : E7                  	MOV	A,@R1
    2460/     86D : 19                  	DEC	R1
    2461/     86E : 89 2A               	MOV	AESP,R1
    2462/     870 : C0 E0               	PUSH	ACC
    2463/     872 : C0 F0               	PUSH	B
    2464/     874 : 43 D0 18            	ORL	PSW,#00011000B	;Select RB3.
    2465/     877 : 22                  	RET			;Branch to user routine.
    2466/     878 :                     ;
    2467/     878 :                     ;=======
    2468/     878 :                     ;$EJECT
    2469/     878 :                     ;$RESTORE
    2470/     878 :                     ;
    2471/     878 :                     ;	STATEMENT EXECUTOR WRITTEN IN IL (INTERPRETIVE LANGUAGE)
    2472/     878 :                     ;	OPERATIONS IMPLEMENTED BY ASM51 MPL MACRO PROCESSING LANGUAGE
    2473/     878 :                     ;			(8/11/80)
    2474/     878 :                     ;
    2475/     878 : 02 01 2E            CMD_NG:	JMP	SYN_ER
    2476/     87B :                     ;
    2477/     87B : 12 07 53            START:  CALL    INIT
    2478/     87E : C2 43               ERRENT:	CLR	RUNMOD
    2479/     880 : 75 81 55            	MOV	SP,#SP_BASE	;Re-initialize hardware stack.
    2480/     883 : 75 2A 2A            	MOV	AESP,#AES-1	;Initialize AES pointer.
    2481/     886 : 12 01 05            CONT:	CALL	STROUT
    2482/     889 : 4F 4B 8D                    DB      "OK",(CR OR 80H)
    2483/     88C : 12 06 36            CONT_1: CALL    GETLN          ;Receive interactive command line.
    2484/     88F : 12 05 1B            	CALL	D_BLNK
    2485/     892 : (MACRO)                     TSTL_   TOKEN
    2485/     892 : 12 05 C4                    CALL    TSTN
    2485/     895 : 50 0D                       JNC     TOKEN
    2486/     897 : 12 07 EB                    CALL    INSRT
    2487/     89A : (MACRO)                     HOP_    CONT_1
    2487/     89A : 80 F0                       SJMP    CONT_1
    2488/     89C :                     ;
    2489/     89C :                     ;=======
    2490/     89C :                     ;
    2491/     89C : 12 07 5B            XEC:    CALL    XINIT          ;Initialize for sequential execution.
    2492/     89F : (MACRO)             STMT:   LINIT_          ;Initialize for line execution.
    2492/     89F : 12 06 22                    CALL   L_INIT
    2492/     8A2 : 40 DA                       JC      ERRENT
    2493/     8A4 : 12 00 D1            TOKEN:	CALL	CNTRL
    2494/     8A7 : 12 05 1B            	CALL	D_BLNK
    2495/     8AA : (MACRO)                     TSTV_   S0            ;Parse implied LET command.
    2495/     8AA : 12 05 5F                    CALL    TSTV
    2495/     8AD : 50 08                       JNC     S0
    2496/     8AF :                     ;*        %TST    (SE4,=)
    2497/     8AF : 12 05 2F                    call   tst
    2498/     8B2 : BD                          db      ('=' OR 80H)
    2499/     8B3 : 50 2E                       jnc     se4
    2500/     8B5 : (MACRO)                     HOP_    SE3
    2500/     8B5 : 80 13                       SJMP    SE3
    2501/     8B7 :                     ;
    2502/     8B7 :                     ;*S0:     %TST    (S1,LET)                ;Parse explicit LET command.
    2503/     8B7 : 12 05 2F            s0:     call   tst
    2504/     8BA : 4C 45 D4                    DB      "LE",('T' OR 80H)
    2505/     8BD : 50 30                       jnc     s1
    2506/     8BF : (MACRO)                     TSTV_   CMD_NG
    2506/     8BF : 12 05 5F                    CALL    TSTV
    2506/     8C2 : 50 B4                       JNC     CMD_NG
    2507/     8C4 :                     ;*        %TST    (CMD_NG,=)
    2508/     8C4 : 12 05 2F                    call   tst
    2509/     8C7 : BD                          db      ('=' OR 80H)
    2510/     8C8 : 50 AE                       jnc     cmd_ng
    2511/     8CA : (MACRO)             SE3:    ICALL_  EXPR
    2511/     8CA : 51 ED                       CALL    EXPR
    2512/     8CC :                     ;*        %TST    (SE3A,%1,)
    2513/     8CC : 12 05 2F                    call   tst
    2514/     8CF : AC                          db      (',' OR 80H)            ;to match tb51.lst
    2515/     8D0 : 50 08                       jnc     se3a
    2516/     8D2 : 12 02 39                    CALL    SEQ_STORE
    2517/     8D5 : 12 03 B3            	CALL	IINC
    2518/     8D8 : (MACRO)                     HOP_    SE3
    2518/     8D8 : 80 F0                       SJMP    SE3
    2519/     8DA :                     ;
    2520/     8DA : 12 05 F7            SE3A:   CALL    DONE
    2521/     8DD : 12 02 3D            	CALL	STORE
    2522/     8E0 : 02 06 2B                    JMP     NXT
    2523/     8E3 :                     ;
    2524/     8E3 : 12 05 F7            SE4:    CALL    DONE           ;Process implied PRINT command.
    2525/     8E6 : 12 02 A1            	CALL	FETCH
    2526/     8E9 : 12 06 89                    CALL    PRN
    2527/     8EC : 02 06 29                    JMP     NL_NXT
    2528/     8EF :                     ;
    2529/     8EF :                     ;=======
    2530/     8EF :                     ;
    2531/     8EF :                     ;*S1:     %TST    (S2,GOTO)               ;Parse GOTO command.
    2532/     8EF : 12 05 2F            s1:     call   tst
    2533/     8F2 : 47 4F 54 CF                 DB      "GOT",('O' OR 80H)
    2534/     8F6 : 50 07                       jnc     s2
    2535/     8F8 : (MACRO)                     ICALL_  EXPR
    2535/     8F8 : 51 ED                       CALL    EXPR
    2536/     8FA : 12 05 FD                    CALL    LNDONE
    2537/     8FD : 01 13                       JMP     XFER
    2538/     8FF :                     ;
    2539/     8FF :                     ;=======
    2540/     8FF :                     ;
    2541/     8FF :                     ;*S2:     %TST    (S3,GOSUB)              ;Parse GOSUB command.
    2542/     8FF : 12 05 2F            s2:     call   tst
    2543/     902 : 47 4F 53 55 C2              DB      "GOSU",('B' OR 80H)
    2544/     907 : 50 09                       jnc     s3
    2545/     909 : 11 1D                       CALL    SAV
    2546/     90B : (MACRO)                     ICALL_  EXPR
    2546/     90B : 51 ED                       CALL    EXPR
    2547/     90D : 12 05 FD                    CALL    LNDONE
    2548/     910 : 01 13                       JMP     XFER
    2549/     912 :                     ;
    2550/     912 :                     ;=======
    2551/     912 :                     ;
    2552/     912 :                     ;*S3:     %TST    (S8,PRINT)              ;Parse PRINT command.
    2553/     912 : 12 05 2F            s3:     call   tst
    2554/     915 : 50 52 49 4E D4              DB      "PRIN",('T' OR 80H)
    2555/     91A : 50 43                       jnc     s8
    2556/     91C : (MACRO)                     IFDONE_ S6B
    2556/     91C : 12 06 07                    CALL    IFDONE
    2556/     91F : 50 38                       JNC     S6B
    2557/     921 :                     ;*S3A:    %TST    (S3B,;)
    2558/     921 : 12 05 2F            s3a:    call   tst
    2559/     924 : BB                          db      (';' OR 80H)
    2560/     925 : 50 02                       jnc     s3b
    2561/     927 : (MACRO)                     HOP_    S3A
    2561/     927 : 80 F8                       SJMP    S3A
    2562/     929 :                     ;
    2563/     929 :                     ;*S3B:    %TST    (S3C,%1,)
    2564/     929 : 12 05 2F            s3b:    call   tst
    2565/     92C : AC                          db      (',' OR 80H)            ;to match TB51.LST
    2566/     92D : 50 05                       jnc     s3c
    2567/     92F : 12 00 DF                    CALL    SPC
    2568/     932 : (MACRO)                     HOP_    S3A
    2568/     932 : 80 ED                       SJMP    S3A
    2569/     934 :                     ;
    2570/     934 : (MACRO)             S3C:    IFDONE_ S6A
    2570/     934 : 12 06 07                    CALL    IFDONE
    2570/     937 : 50 23                       JNC     S6A
    2571/     939 : (MACRO)                     TSTS_   S5
    2571/     939 : 12 05 D9                    CALL    TSTS
    2571/     93C : 40 05                       JC      S5
    2572/     93E : (MACRO)                     ICALL_  EXPR
    2572/     93E : 51 ED                       CALL    EXPR
    2573/     940 : 12 06 89                    CALL    PRN
    2574/     943 :                     ;*S5:     %TST    (S5A,%1,)
    2575/     943 : 12 05 2F            s5:     call   tst
    2576/     946 : AC                          db      (',' OR 80H)            ;to match TB51.LST
    2577/     947 : 50 05                       jnc     s5a
    2578/     949 : 12 00 DF                    CALL    SPC
    2579/     94C : (MACRO)                     HOP_    S3A
    2579/     94C : 80 D3                       SJMP    S3A
    2580/     94E :                     ;
    2581/     94E :                     ;*S5A:    %TST    (S6,;)
    2582/     94E : 12 05 2F            s5a:    call   tst
    2583/     951 : BB                          db      (';' OR 80H)
    2584/     952 : 50 02                       jnc     s6
    2585/     954 : (MACRO)                     HOP_    S3A
    2585/     954 : 80 CB                       SJMP    S3A
    2586/     956 :                     ;
    2587/     956 : 12 05 F7            S6:     CALL    DONE
    2588/     959 : 02 06 29            S6B:    JMP     NL_NXT
    2589/     95C :                     ;
    2590/     95C : 02 06 2B            S6A:    JMP     NXT
    2591/     95F :                     ;
    2592/     95F :                     ;=======
    2593/     95F :                     ;
    2594/     95F :                     ;*S8:     %TST    (S9,IF)         ;Parse IF command.
    2595/     95F : 12 05 2F            s8:     call   tst
    2596/     962 : 49 C6                       db      'I',('F' OR 80H)
    2597/     964 : 50 16                       jnc     s9
    2598/     966 : (MACRO)                     ICALL_  EXPR
    2598/     966 : 51 ED                       CALL    EXPR
    2599/     968 :                     ;*        %TST    (S8A,THEN)
    2600/     968 : 12 05 2F                    call   tst
    2601/     96B : 54 48 45 CE                 DB      "THE",('N' OR 80H)
    2602/     96F : 50 00                       jnc     s8a
    2603/     971 : (MACRO)             S8A:    COND_   S8B
    2603/     971 : 11 0D                       CALL   COND
    2603/     973 : 50 02                       JNC    S8B
    2604/     975 : (MACRO)                     IJMP_   TOKEN         ;Continue parsing command.
    2604/     975 : 01 A4                       JMP     TOKEN
    2605/     977 :                     ;
    2606/     977 : 12 05 29            S8B:    CALL    SKPTXT
    2607/     97A : (MACRO)                     IJMP_   STMT
    2607/     97A : 01 9F                       JMP     STMT
    2608/     97C :                     ;
    2609/     97C :                     ;=======
    2610/     97C :                     ;
    2611/     97C :                     ;*S9:     %TST    (S12,INPUT)             ;Parse INPUT command.
    2612/     97C : 12 05 2F            s9:     call   tst
    2613/     97F : 49 4E 50 55 D4              DB      "INPU",('T' OR 80H)
    2614/     984 : 50 2B                       jnc     s12
    2615/     986 : (MACRO)             S10:    TSTS_   S10B
    2615/     986 : 12 05 D9                    CALL    TSTS
    2615/     989 : 40 0B                       JC      S10B
    2616/     98B : (MACRO)                     TSTV_   S10D
    2616/     98B : 12 05 5F                    CALL    TSTV
    2616/     98E : 50 19                       JNC     S10D
    2617/     990 : 12 06 FA                    CALL    INNUM
    2618/     993 : 12 02 3D            	CALL	STORE
    2619/     996 :                     ;*S10B:   %TST    (S10C,;)
    2620/     996 : 12 05 2F            s10b:   call   tst
    2621/     999 : BB                          db      (';' OR 80H)
    2622/     99A : 50 02                       jnc     s10c
    2623/     99C : (MACRO)                     HOP_    S10
    2623/     99C : 80 E8                       SJMP    S10
    2624/     99E :                     ;
    2625/     99E :                     ;*S10C:   %TST    (S11,%1,)
    2626/     99E : 12 05 2F            s10c:   call   tst
    2627/     9A1 : AC                          db      (',' OR 80H)            ;to match TB51.LST
    2628/     9A2 : 50 07                       jnc     s11
    2629/     9A4 : 12 00 DF                    CALL    SPC
    2630/     9A7 : (MACRO)                     HOP_    S10
    2630/     9A7 : 80 DD                       SJMP    S10
    2631/     9A9 :                     ;
    2632/     9A9 : (MACRO)             S10D:   IJMP_   SYN_NG
    2632/     9A9 : 61 CC                       JMP     SYN_NG
    2633/     9AB :                     ;
    2634/     9AB : 12 05 F7            S11:    CALL    DONE
    2635/     9AE : 02 06 29                    JMP     NL_NXT
    2636/     9B1 :                     ;
    2637/     9B1 :                     ;=======
    2638/     9B1 :                     ;
    2639/     9B1 :                     ;*S12:    %TST    (S13,RETURN)            ;Parse RETURN command.
    2640/     9B1 : 12 05 2F            s12:    call   tst
    2641/     9B4 : 52 45 54 55 52 CE           DB      "RETUR",('N' OR 80H)
    2642/     9BA : 50 05                       jnc     s13
    2643/     9BC : 12 05 FD                    CALL    LNDONE
    2644/     9BF : 01 24                       JMP     RSTR
    2645/     9C1 :                     ;
    2646/     9C1 :                     ;=======
    2647/     9C1 :                     ;
    2648/     9C1 :                     ;*S13:    %TST    (S13A,CALL)             ;Machine language CALL.
    2649/     9C1 : 12 05 2F            s13:    call   tst
    2650/     9C4 : 43 41 4C CC                 DB      "CAL",('L' OR 80H)
    2651/     9C8 : 50 0D                       jnc     s13a
    2652/     9CA : (MACRO)                     ICALL_  EXPR
    2652/     9CA : 51 ED                       CALL    EXPR
    2653/     9CC : 12 05 FD                    CALL    LNDONE
    2654/     9CF : (MACRO)                     MLCALL_
    2654/     9CF : 11 67                       CALL    MLCALL
    2654/     9D1 : 53 D0 E7                    ANL     PSW,#11100111B
    2655/     9D4 : 02 06 2B                    JMP     NXT
    2656/     9D7 :                     ;
    2657/     9D7 :                     ;=======
    2658/     9D7 :                     ;
    2659/     9D7 :                     ;*S13A:   %TST    (S13B,FOR)
    2660/     9D7 : 12 05 2F            s13a:   call   tst
    2661/     9DA : 46 4F D2                    DB      "FO",('R' OR 80H)
    2662/     9DD : 50 21                       jnc     s13b
    2663/     9DF : (MACRO)                     TSTV_   FOR_ER
    2663/     9DF : 12 05 5F                    CALL    TSTV
    2663/     9E2 : 50 4B                       JNC     FOR_ER
    2664/     9E4 :                     ;*        %TST    (FOR_ER,=)
    2665/     9E4 : 12 05 2F                    call   tst
    2666/     9E7 : BD                          db      ('=' OR 80H)
    2667/     9E8 : 50 45                       jnc     for_er
    2668/     9EA : (MACRO)                     ICALL_  EXPR
    2668/     9EA : 51 ED                       CALL    EXPR
    2669/     9EC : 12 02 39            	CALL	SEQ_STORE
    2670/     9EF :                     ;*        %TST    (FOR_ER,TO)
    2671/     9EF : 12 05 2F                    call   tst
    2672/     9F2 : 54 CF                       db      'T',('O' OR 80H)
    2673/     9F4 : 50 39                       jnc     for_er
    2674/     9F6 : (MACRO)                     ICALL_  EXPR
    2674/     9F6 : 51 ED                       CALL    EXPR
    2675/     9F8 : 12 05 FD                    CALL    LNDONE
    2676/     9FB : 11 1D                       CALL    SAV
    2677/     9FD : 02 06 2B                    JMP     NXT
    2678/     A00 :                     ;
    2679/     A00 :                     ;=======
    2680/     A00 :                     ;
    2681/     A00 :                     ;*S13B:   %TST    (S13C,NEXT)
    2682/     A00 : 12 05 2F            s13b:   call   tst
    2683/     A03 : 4E 45 58 D4                 DB      "NEX",('T' OR 80H)
    2684/     A07 : 50 28                       jnc     s13c
    2685/     A09 : (MACRO)                     TSTV_   FOR_ER
    2685/     A09 : 12 05 5F                    CALL    TSTV
    2685/     A0C : 50 21                       JNC     FOR_ER
    2686/     A0E : 12 05 F7                    CALL    DONE
    2687/     A11 : 12 02 9D            	CALL	SEQ_FETCH
    2688/     A14 : 12 03 B3            	CALL	IINC
    2689/     A17 : (MACRO)                     NEXT_LOOP_      FORDON
    2689/     A17 : 11 2C                       CALL   LOOP
    2689/     A19 : 40 05                       JC     FORDON
    2690/     A1B : 12 01 64            	CALL	DUPL
    2691/     A1E : 01 24                       JMP     RSTR
    2692/     A20 :                     ;
    2693/     A20 : 12 01 39            FORDON:	CALL	POP_TOS
    2694/     A23 : 12 01 39            	CALL	POP_TOS
    2695/     A26 : 12 01 39            	CALL	POP_TOS
    2696/     A29 : 12 01 4B            	CALL	POP_ACC
    2697/     A2C : 02 06 2B                    JMP     NXT
    2698/     A2F :                     ;
    2699/     A2F :                     ;=======
    2700/     A2F :                     ;
    2701/     A2F : (MACRO)             FOR_ER: IJMP_   CMD_NG
    2701/     A2F : 01 78                       JMP     CMD_NG
    2702/     A31 :                     ;
    2703/     A31 :                     ;=======
    2704/     A31 :                     ;
    2705/     A31 :                     ;*S13C:   %TST    (S14,END)               ;Parse END command.
    2706/     A31 : 12 05 2F            s13c:   call   tst
    2707/     A34 : 45 4E C4                    DB      "EN",('D' OR 80H)
    2708/     A37 : 50 05                       jnc     s14
    2709/     A39 : 12 05 FD                    CALL    LNDONE
    2710/     A3C : 01 63                       JMP     FIN
    2711/     A3E :                     ;
    2712/     A3E :                     ;=======
    2713/     A3E :                     ;
    2714/     A3E :                     ;*S14:    %TST    (S15,LIST)              ;Parse LIST command.
    2715/     A3E : 12 05 2F            s14:    call   tst
    2716/     A41 : 4C 49 53 D4                 DB      "LIS",('T' OR 80H)
    2717/     A45 : 50 14                       jnc     s15
    2718/     A47 : (MACRO)                     IFDONE_ S14B
    2718/     A47 : 12 06 07                    CALL    IFDONE
    2718/     A4A : 50 0A                       JNC     S14B
    2719/     A4C : (MACRO)                     ICALL_  EXPR
    2719/     A4C : 51 ED                       CALL    EXPR
    2720/     A4E : 12 07 63            	CALL	FNDLBL
    2721/     A51 : 12 06 EF            	CALL	LST_1
    2722/     A54 : (MACRO)                     IJMP_   CONT
    2722/     A54 : 01 86                       JMP     CONT
    2723/     A56 :                     ;
    2724/     A56 : 12 06 EB            S14B:   CALL    LST
    2725/     A59 : (MACRO)                     IJMP_   CONT
    2725/     A59 : 01 86                       JMP     CONT
    2726/     A5B :                     ;
    2727/     A5B :                     ;=======
    2728/     A5B :                     ;
    2729/     A5B :                     ;*S15:    %TST    (S16,RUN)               ;Parse LIST command.
    2730/     A5B : 12 05 2F            s15:    call   tst
    2731/     A5E : 52 55 CE                    DB      "RU",('N' OR 80H)
    2732/     A61 : 50 05                       jnc     s16
    2733/     A63 : 12 05 FD                    CALL    LNDONE
    2734/     A66 : (MACRO)                     IJMP_   XEC
    2734/     A66 : 01 9C                       JMP     XEC
    2735/     A68 :                     ;
    2736/     A68 :                     ;=======
    2737/     A68 :                     ;
    2738/     A68 :                     ;*S16:    %TST    (S16A,NEW)
    2739/     A68 : 12 05 2F            s16:    call   tst
    2740/     A6B : 4E 45 D7                    DB      "NE",('W' OR 80H)
    2741/     A6E : 50 05                       jnc     s16a
    2742/     A70 : 12 05 F7                    CALL    DONE
    2743/     A73 : (MACRO)                     IJMP_   START
    2743/     A73 : 01 7B                       JMP     START
    2744/     A75 :                     ;
    2745/     A75 :                     ;=======
    2746/     A75 :                     ;*S16A:   %TST    (S17,RESET)
    2747/     A75 : 12 05 2F            s16a:   call   tst
    2748/     A78 : 52 45 53 45 D4              DB      "RESE",('T' OR 80H)
    2749/     A7D : 50 06                       jnc     s17
    2750/     A7F : 12 05 F7                    CALL    DONE
    2751/     A82 : 02 00 00            	JMP	0000H
    2752/     A85 :                     ;
    2753/     A85 :                     ;=======
    2754/     A85 :                     ;
    2755/     A85 :                     ;*S17:    %TST    (S17A,ROM)
    2756/     A85 : 12 05 2F            s17:    call   tst
    2757/     A88 : 52 4F CD                    DB      "RO",('M' OR 80H)
    2758/     A8B : 50 0A                       jnc     s17a
    2759/     A8D : 12 05 F7                    CALL    DONE
    2760/     A90 : D2 41               	SETB	ROMMOD
    2761/     A92 : C2 42               	CLR	EXTMOD
    2762/     A94 : 02 06 2B                    JMP     NXT
    2763/     A97 :                     ;
    2764/     A97 :                     ;*S17A:   %TST    (S17B,RAM)
    2765/     A97 : 12 05 2F            s17a:   call   tst
    2766/     A9A : 52 41 CD                    DB      "RA",('M' OR 80H)
    2767/     A9D : 50 08                       jnc     s17b
    2768/     A9F : 12 05 F7                    CALL    DONE
    2769/     AA2 : C2 41               	CLR	ROMMOD
    2770/     AA4 : 02 06 2B                    JMP     NXT
    2771/     AA7 :                     ;
    2772/     AA7 :                     ;*S17B:   %TST    (S17C,PROM)
    2773/     AA7 : 12 05 2F            s17b:   call   tst
    2774/     AAA : 50 52 4F CD                 DB      "PRO",('M' OR 80H)
    2775/     AAE : 50 0A                       jnc     s17c
    2776/     AB0 : 12 05 F7                    CALL    DONE
    2777/     AB3 : D2 41               	SETB	ROMMOD
    2778/     AB5 : D2 42               	SETB	EXTMOD
    2779/     AB7 : 02 06 2B                    JMP     NXT
    2780/     ABA :                     ;
    2781/     ABA :                     ;*S17C:   %TST    (S18,HEX)
    2782/     ABA : 12 05 2F            s17c:   call   tst
    2783/     ABD : 48 45 D8                    DB      "HE",('X' OR 80H)
    2784/     AC0 : 50 08                       jnc     s18
    2785/     AC2 : 12 05 F7                    CALL    DONE
    2786/     AC5 : D2 44               	SETB	HEXMOD
    2787/     AC7 : 02 06 2B                    JMP     NXT
    2788/     ACA :                     ;
    2789/     ACA :                     ;*S18:    %TST    (S19,DECIMAL)
    2790/     ACA : 12 05 2F            s18:    call   tst
    2791/     ACD : 44 45 43 49 4D 41           DB      "DECIMA",('L' OR 80H)
                    CC 
    2792/     AD4 : 50 08                       jnc     s19
    2793/     AD6 : 12 05 F7                    CALL    DONE
    2794/     AD9 : C2 44               	CLR	HEXMOD
    2795/     ADB : 02 06 2B                    JMP     NXT
    2796/     ADE :                     ;
    2797/     ADE :                     ;*S19:    %TST    (S20,REM)
    2798/     ADE : 12 05 2F            s19:    call   tst
    2799/     AE1 : 52 45 CD                    DB      "RE",('M' OR 80H)
    2800/     AE4 : 50 05                       jnc     s20
    2801/     AE6 : 12 05 29                    CALL    SKPTXT
    2802/     AE9 : (MACRO)                     IJMP_   STMT
    2802/     AE9 : 01 9F                       JMP     STMT
    2803/     AEB :                     ;
    2804/     AEB : (MACRO)             S20:    IJMP_   CMD_NG
    2804/     AEB : 01 78                       JMP     CMD_NG
    2805/     AED :                     ;
    2806/     AED :                     ;$EJECT
    2807/     AED :                     ;
    2808/     AED :                     ;	INTERPRETIVE LANGUAGE SUBROUTINES:
    2809/     AED :                     ;	============ ======== ===========
    2810/     AED :                     ;
    2811/     AED : (MACRO)             EXPR:   ICALL_  AR_EXP
    2811/     AED : 51 FA                       CALL    AR_EXP
    2812/     AEF : (MACRO)             E0:     ICALL_  RELOP
    2812/     AEF : 71 CE                       CALL    RELOP
    2813/     AF1 : 50 40               	JNC	E5
    2814/     AF3 : (MACRO)                     ICALL_  AR_EXP
    2814/     AF3 : 51 FA                       CALL    AR_EXP
    2815/     AF5 : 12 04 8D                    CALL    CMPR
    2816/     AF8 : (MACRO)                     HOP_    E0
    2816/     AF8 : 80 F5                       SJMP    E0
    2817/     AFA :                     ;
    2818/     AFA : (MACRO)             AR_EXP: ICALL_  TERM
    2818/     AFA : 71 34                       CALL    TERM
    2819/     AFC :                     ;*E1:     %TST    (E2,+)
    2820/     AFC : 12 05 2F            e1:     call   tst
    2821/     AFF : AB                          db      ('+' OR 80H)
    2822/     B00 : 50 07                       jnc     e2
    2823/     B02 : (MACRO)                     ICALL_  TERM
    2823/     B02 : 71 34                       CALL    TERM
    2824/     B04 : 12 03 63            	CALL	IADD
    2825/     B07 : (MACRO)                     HOP_    E1
    2825/     B07 : 80 F3                       SJMP    E1
    2826/     B09 :                     ;
    2827/     B09 :                     ;*E2:     %TST    (E3,-)
    2828/     B09 : 12 05 2F            e2:     call   tst
    2829/     B0C : AD                          db      ('-' OR 80H)
    2830/     B0D : 50 07                       jnc     e3
    2831/     B0F : (MACRO)                     ICALL_  TERM
    2831/     B0F : 71 34                       CALL    TERM
    2832/     B11 : 12 03 69            	CALL	ISUB
    2833/     B14 : (MACRO)                     HOP_    E1
    2833/     B14 : 80 E6                       SJMP    E1
    2834/     B16 :                     ;
    2835/     B16 :                     ;*E3:     %TST    (E4,OR)
    2836/     B16 : 12 05 2F            e3:     call   tst
    2837/     B19 : 4F D2                       db      'O',('R' OR 80H)
    2838/     B1B : 50 07                       jnc     e4
    2839/     B1D : (MACRO)                     ICALL_  TERM
    2839/     B1D : 71 34                       CALL    TERM
    2840/     B1F : 12 03 7F            	CALL	IOR
    2841/     B22 : (MACRO)                     HOP_    E1
    2841/     B22 : 80 D8                       SJMP    E1
    2842/     B24 :                     ;
    2843/     B24 :                     ;*E4:     %TST    (E5,XOR)
    2844/     B24 : 12 05 2F            e4:     call   tst
    2845/     B27 : 58 4F D2                    DB      "XO",('R' OR 80H)
    2846/     B2A : 50 07                       jnc     e5
    2847/     B2C : (MACRO)                     ICALL_  TERM
    2847/     B2C : 71 34                       CALL    TERM
    2848/     B2E : 12 03 89            	CALL	IXOR
    2849/     B31 : (MACRO)                     HOP_    E1
    2849/     B31 : 80 C9                       SJMP    E1
    2850/     B33 :                     ;
    2851/     B33 : 22                  E5:     RET
    2852/     B34 :                     ;
    2853/     B34 :                     ;=======
    2854/     B34 :                     ;
    2855/     B34 : (MACRO)             TERM:   ICALL_  FACT
    2855/     B34 : 71 6F                       CALL    FACT
    2856/     B36 :                     ;*TERM_0: %TST    (TERM_1,*)
    2857/     B36 : 12 05 2F            term_0: call   tst
    2858/     B39 : AA                          db      ('*' OR 80H)
    2859/     B3A : 50 07                       jnc     term_1
    2860/     B3C : (MACRO)                     ICALL_  FACT
    2860/     B3C : 71 6F                       CALL    FACT
    2861/     B3E : 12 03 F5            	CALL	IMUL
    2862/     B41 : (MACRO)                     HOP_    TERM_0
    2862/     B41 : 80 F3                       SJMP    TERM_0
    2863/     B43 :                     ;
    2864/     B43 :                     ;*TERM_1: %TST    (TERM_2,/)
    2865/     B43 : 12 05 2F            term_1: call   tst
    2866/     B46 : AF                          db      ('/' OR 80H)
    2867/     B47 : 50 07                       jnc     term_2
    2868/     B49 : (MACRO)                     ICALL_  FACT
    2868/     B49 : 71 6F                       CALL    FACT
    2869/     B4B : 12 04 08            	CALL	IDIV
    2870/     B4E : (MACRO)                     HOP_    TERM_0
    2870/     B4E : 80 E6                       SJMP    TERM_0
    2871/     B50 :                     ;
    2872/     B50 :                     ;*TERM_2: %TST    (TERM_3,AND)
    2873/     B50 : 12 05 2F            term_2: call   tst
    2874/     B53 : 41 4E C4                    DB      "AN",('D' OR 80H)
    2875/     B56 : 50 07                       jnc     term_3
    2876/     B58 : (MACRO)                     ICALL_  FACT
    2876/     B58 : 71 6F                       CALL    FACT
    2877/     B5A : 12 03 75            	CALL	IAND
    2878/     B5D : (MACRO)                     HOP_    TERM_0
    2878/     B5D : 80 D7                       SJMP    TERM_0
    2879/     B5F :                     ;
    2880/     B5F :                     ;*TERM_3: %TST    (TERM_4,MOD)
    2881/     B5F : 12 05 2F            term_3: call   tst
    2882/     B62 : 4D 4F C4                    DB      "MO",('D' OR 80H)
    2883/     B65 : 50 07                       jnc     term_4
    2884/     B67 : (MACRO)                     ICALL_  FACT
    2884/     B67 : 71 6F                       CALL    FACT
    2885/     B69 : 12 04 04            	CALL	IMOD
    2886/     B6C : (MACRO)                     HOP_    TERM_0
    2886/     B6C : 80 C8                       SJMP    TERM_0
    2887/     B6E :                     ;
    2888/     B6E : 22                  TERM_4: RET
    2889/     B6F :                     ;
    2890/     B6F :                     ;=======
    2891/     B6F :                     ;
    2892/     B6F :                     ;*FACT:   %TST    (FACT_1,-)
    2893/     B6F : 12 05 2F            fact:   call   tst
    2894/     B72 : AD                          db      ('-' OR 80H)
    2895/     B73 : 50 06                       jnc     fact_1
    2896/     B75 : (MACRO)                     ICALL_  VAR
    2896/     B75 : 71 89                       CALL    VAR
    2897/     B77 : 12 03 93            	CALL	NEG
    2898/     B7A : 22                          RET
    2899/     B7B :                     ;
    2900/     B7B :                     ;*FACT_1: %TST    (VAR,NOT)
    2901/     B7B : 12 05 2F            fact_1: call   tst
    2902/     B7E : 4E 4F D4                    DB      "NO",('T' OR 80H)
    2903/     B81 : 50 06                       jnc     var
    2904/     B83 : (MACRO)                     ICALL_  VAR
    2904/     B83 : 71 89                       CALL    VAR
    2905/     B85 : 12 03 A2            	CALL	ICPL
    2906/     B88 : 22                          RET
    2907/     B89 :                     ;
    2908/     B89 :                     ;
    2909/     B89 :                     ;=======
    2910/     B89 :                     ;
    2911/     B89 : (MACRO)             VAR:    TSTV_   VAR_0
    2911/     B89 : 12 05 5F                    CALL    TSTV
    2911/     B8C : 50 04                       JNC     VAR_0
    2912/     B8E : 12 02 A1            	CALL	FETCH
    2913/     B91 : 22                          RET
    2914/     B92 :                     ;
    2915/     B92 : (MACRO)             VAR_0:  TSTN_   VAR_1
    2915/     B92 : 12 05 C4                    CALL    TSTN
    2915/     B95 : 50 01                       JNC     VAR_1
    2916/     B97 : 22                          RET
    2917/     B98 :                     ;
    2918/     B98 :                     ;*VAR_1:  %TST    (VAR_1A,RND)
    2919/     B98 : 12 05 2F            var_1:  call   tst
    2920/     B9B : 52 4E C4                    DB      "RN",('D' OR 80H)
    2921/     B9E : 50 0F                       jnc     var_1a
    2922/     BA0 : 12 04 65                    CALL    RND
    2923/     BA3 : (MACRO)                     ICALL_  VAR_2
    2923/     BA3 : 71 BD                       CALL    VAR_2
    2924/     BA5 : 12 04 04            	CALL	IMOD
    2925/     BA8 : 12 03 A5            	CALL	IABS
    2926/     BAB : 12 03 B3            	CALL	IINC
    2927/     BAE : 22                          RET
    2928/     BAF :                     ;
    2929/     BAF :                     ;*VAR_1A: %TST    (VAR_2,ABS)
    2930/     BAF : 12 05 2F            var_1a: call   tst
    2931/     BB2 : 41 42 D3                    DB      "AB",('S' OR 80H)
    2932/     BB5 : 50 06                       jnc     var_2
    2933/     BB7 : (MACRO)                     ICALL_  VAR_2
    2933/     BB7 : 71 BD                       CALL    VAR_2
    2934/     BB9 : 12 03 A5            	CALL	IABS
    2935/     BBC : 22                          RET
    2936/     BBD :                     ;
    2937/     BBD :                     ;*VAR_2:  %TST    (SYN_NG,%1()
    2938/     BBD : 12 05 2F            var_2:  call   tst
    2939/     BC0 : A8                          db      '(' OR 80H              ;to match TB51.LST
    2940/     BC1 : 50 09                       jnc     syn_ng
    2941/     BC3 : (MACRO)                     ICALL_  EXPR
    2941/     BC3 : 51 ED                       CALL    EXPR
    2942/     BC5 :                     ;*        %TST    (SYN_NG,%1))
    2943/     BC5 : 12 05 2F                    call   tst
    2944/     BC8 : A9                          db      ')' OR 80H              ;to match TB51.LST
    2945/     BC9 : 50 01                       jnc     syn_ng
    2946/     BCB : 22                          RET
    2947/     BCC :                     ;
    2948/     BCC :                     ;=======
    2949/     BCC :                     ;
    2950/     BCC : (MACRO)             SYN_NG: IJMP_   CMD_NG
    2950/     BCC : 01 78                       JMP     CMD_NG
    2951/     BCE :                     ;
    2952/     BCE :                     ;$EJECT
    2953/     BCE :                     ;
    2954/     BCE :                     RELOP:
    2955/     BCE :                     ;	Search for relational operator in text string.
    2956/     BCE :                     ;	If found, push appropriate operator code on AES and return with
    2957/     BCE :                     ;	carry set.
    2958/     BCE :                     ;	Otherwise restore cursor and return with carry=0.
    2959/     BCE :                     ;
    2960/     BCE :                     ;*        %TST    (REL_1,=)
    2961/     BCE : 12 05 2F                    call   tst
    2962/     BD1 : BD                          db      ('=' OR 80H)
    2963/     BD2 : 50 05                       jnc     rel_1
    2964/     BD4 : (MACRO)                     LIT_    010B            ;Test for _=_
    2964/     BD4 : 12 01 78                    CALL    LIT
    2964/     BD7 : 02                          DB      010B
    2965/     BD8 : 22                          RET
    2966/     BD9 :                     ;
    2967/     BD9 :                     ;*REL_1:  %TST    (REL_2,<=)
    2968/     BD9 : 12 05 2F            rel_1:  call   tst
    2969/     BDC : 3C BD                       db      '<',('=' OR 80H)
    2970/     BDE : 50 05                       jnc     rel_2
    2971/     BE0 : (MACRO)                     LIT_    110B            ;Test for <=_
    2971/     BE0 : 12 01 78                    CALL    LIT
    2971/     BE3 : 06                          DB      110B
    2972/     BE4 : 22                          RET
    2973/     BE5 :                     ;
    2974/     BE5 :                     ;*REL_2:  %TST    (REL_3,<>)
    2975/     BE5 : 12 05 2F            rel_2:  call   tst
    2976/     BE8 : 3C BE                       db      '<',('>' OR 80H)
    2977/     BEA : 50 05                       jnc     rel_3
    2978/     BEC : (MACRO)                     LIT_    101B            ;Test for <_>
    2978/     BEC : 12 01 78                    CALL    LIT
    2978/     BEF : 05                          DB      101B
    2979/     BF0 : 22                          RET
    2980/     BF1 :                     ;
    2981/     BF1 :                     ;*REL_3:  %TST    (REL_4,<)
    2982/     BF1 : 12 05 2F            rel_3:  call   tst
    2983/     BF4 : BC                          db      ('<' OR 80H)
    2984/     BF5 : 50 05                       jnc     rel_4
    2985/     BF7 : (MACRO)                     LIT_    100B            ;Test for <__
    2985/     BF7 : 12 01 78                    CALL    LIT
    2985/     BFA : 04                          DB      100B
    2986/     BFB : 22                          RET
    2987/     BFC :                     ;
    2988/     BFC :                     ;*REL_4:  %TST    (REL_5,>=)
    2989/     BFC : 12 05 2F            rel_4:  call   tst
    2990/     BFF : 3E BD                       db      '>',('=' OR 80H)
    2991/     C01 : 50 05                       jnc     rel_5
    2992/     C03 : (MACRO)                     LIT_    011B            ;Test for _=>
    2992/     C03 : 12 01 78                    CALL    LIT
    2992/     C06 : 03                          DB      011B
    2993/     C07 : 22                          RET
    2994/     C08 :                     ;
    2995/     C08 :                     ;*REL_5:  %TST    (REL_6,>)
    2996/     C08 : 12 05 2F            rel_5:  call   tst
    2997/     C0B : BE                          db      ('>' OR 80H)
    2998/     C0C : 50 05                       jnc     rel_6
    2999/     C0E : (MACRO)                     LIT_    001B            ;Test for __>
    2999/     C0E : 12 01 78                    CALL    LIT
    2999/     C11 : 01                          DB      001B
    3000/     C12 : 22                          RET
    3001/     C13 :                     ;
    3002/     C13 : C3                  REL_6:	CLR	C
    3003/     C14 : 22                          RET
    3004/     C15 :                     ;
    3005/     C15 :                     ;=======
    3006/     C15 :                     ;
    3007/     C15 :                     ;$EJECT
    3008/     C15 :                     ;$LIST
    3009/     C15 :                     ;
    3010/     C15 : 0F                  	INC	R7		;Dummy ML program.
    3011/     C16 : 8F 90               	MOV	P1,R7
    3012/     C18 : 22                  	RET
    3013/     C19 :                     ;
    3014/     C19 :                     INTROM:				;Start of ROM program buffer.
    3015/     C19 :                     
    3016/     C19 :                     DW_	MACRO	DATA		;swaped DW macro
    3017/     C19 :                     	DB	(DATA >> 8)
    3018/     C19 :                     	DB	(DATA & 0ffh)
    3019/     C19 :                     	ENDM
    3020/     C19 :                     
    3021/     C19 :                     ;$INCLUDE(TBACEY.SRC)
    3022/     C19 : (MACRO)             	DW_	10
    3022/     C19 : 00                          DB      (10 >> 8)
    3022/     C1A : 0A                          DB      (10 & 0ffh)
    3023/     C1B : 46 4F 52 20 49 3D   	db	"FOR I=1 TO 9",CR
                    31 20 54 4F 20 39 
                    0D 
    3024/     C28 : (MACRO)             	DW_	20
    3024/     C28 : 00                          DB      (20 >> 8)
    3024/     C29 : 14                          DB      (20 & 0ffh)
    3025/     C2A : 46 4F 52 20 4A 3D   	db	"FOR J=1 TO 9",CR
                    31 20 54 4F 20 39 
                    0D 
    3026/     C37 : (MACRO)             	DW_	30
    3026/     C37 : 00                          DB      (30 >> 8)
    3026/     C38 : 1E                          DB      (30 & 0ffh)
    3027/     C39 : 50 52 49 4E 54 20   	db	"PRINT I*J,",CR
                    49 2A 4A 2C 0D 
    3028/     C44 : (MACRO)             	DW_	40
    3028/     C44 : 00                          DB      (40 >> 8)
    3028/     C45 : 28                          DB      (40 & 0ffh)
    3029/     C46 : 4E 45 58 54 20 4A   	db	"NEXT J",CR
                    0D 
    3030/     C4D : (MACRO)             	DW_	50
    3030/     C4D : 00                          DB      (50 >> 8)
    3030/     C4E : 32                          DB      (50 & 0ffh)
    3031/     C4F : 50 52 49 4E 54 0D   	db	"PRINT",CR
    3032/     C55 : (MACRO)             	DW_	60
    3032/     C55 : 00                          DB      (60 >> 8)
    3032/     C56 : 3C                          DB      (60 & 0ffh)
    3033/     C57 : 4E 45 58 54 20 49   	db	"NEXT I",CR
                    0D 
    3034/     C5E : 80                  	DB	80H		;Marks end of program.
    3035/     C5F :                     ;
    3036/     C5F :                     	END
 AS V1.42 Beta [Bld 32] - source file tb51as23.asm - page 2 - 1/12/2020 19:43:56
Tiny-Basic51 - Modified for Macro Assembler AS


  symbol table (* = unused):
  ------------------------

*AC :                            D6 B |  ACC :                           E0 D |
 ADD_16 :                       35B C |  ADR_ER :                       201 C |
 AES :                           2B D |  AESLEN :                        24 - |
 AESP :                          2A D |  AES_ER :                       123 C |
 ALPHAB :                       56C C |  APND_1 :                       328 C |
 APND_2 :                       34C C |  APND_4 :                       326 C |
 APN_ER :                       34E C |  APPEND :                       30B C |
*ARCHITECTURE : i386-unknown-freebsd - |
 AR_EXP :                       AFA C |  ASCTBL :                        F5 C |
 B :                             F0 D | *BANK0 :                          0 - |
*BANK1 :                          1 - | *BANK2 :                          2 - |
*BANK3 :                          3 - |  BAUDID :                        45 C |
 BEL :                            7 - | *BIGENDIAN :                      0 - |
*BIG_PROBLEM :                  482 C | *BRANCHEXT :                      0 - |
*CASESENSITIVE :                  0 - |  CMD_NG :                       878 C |
 CMPR :                         48D C |  CMPR_1 :                       4AC C |
 CMPR_2 :                       4B2 C |  CMPR_4 :                       4A4 C |
 CNTRET :                        DE C |  CNTRL :                         D1 C |
 CNTR_2 :                        D9 C |  COND :                         80D C |
*CONSTPI :        3.141592653589793 - |  CONT :                         886 C |
 CONT_1 :                       88C C |  COUT_1 :                        D0 C |
 COUT_2 :                        C8 C |  COUT_3 :                        CC C |
 CR :                             D - |  CREATE :                       2FE C |
 CREA_1 :                       30A C |  CURS_H :                        52 D |
 CURS_L :                        51 D | *CY :                            D7 B |
 C_IN :                          97 C |  C_IN_1 :                        B1 C |
 C_IN_2 :                        A5 C |  C_OUT :                         B4 C |
 C_SAVE :                        53 D | *DATE :                   1/12/2020 - |
*DD001 :                        26F C | *DD002 :                        2CE C |
*DD003 :                        4E7 C | *DD004 :                        50D C |
*DD005 :                         97 C | *DD006 :                         B4 C |
*DD007 :                         B7 C | *DD008 :                         BE C |
*DD009 :                         C1 C | *DD010 :                        733 C |
*DD012 :                          3 C | *DD014 :                          B C |
*DD016 :                         13 C | *DD018 :                         1B C |
*DD020 :                         23 C |  DIV_1 :                        45B C |
 DIV_2 :                        460 C |  DIV_LP :                       42E C |
 DIV_NG :                       463 C |  DIV_RP :                       445 C |
 DONE :                         5F7 C |  DONE_1 :                       5FF C |
 DONE_2 :                       603 C |  DPH :                           83 D |
 DPL :                           82 D |  DUPL :                         164 C |
 D_BLNK :                       51B C |  E0 :                           AEF C |
 E1 :                           AFC C |  E2 :                           B09 C |
 E3 :                           B16 C |  E4 :                           B24 C |
 E5 :                           B33 C | *EA :                            AF B |
 ERRENT :                       87E C |  ERROUT :                       117 C |
*ES :                            AC B | *ET0 :                           A9 B |
*ET1 :                           AB B | *EX0 :                           A8 B |
*EX1 :                           AA B |  EXPR :                         AED C |
 EXP_ER :                       11A C |  EXP_OV :                       358 C |
 EXTINI :                       749 C |  EXTMOD :                        42 B |
 EXTRAM :                      2034 - |  EXTROM :                      1080 - |
 EXTVAR :                        40 B |  F0 :                            D5 B |
 FACT :                         B6F C |  FACT_1 :                       B7B C |
*FALSE :                          0 - |  FETBDN :                       2F9 C |
 FETCBY :                       2F3 C |  FETCH :                        2A1 C |
 FETDBY :                       2DA C |  FETDIR :                       211 C |
 FETERR :                       2D8 C |  FETEXT :                       2CD C |
 FETJTB :                       2B5 C |  FETRBI :                       2E0 C |
 FETSFR :                       217 C |  FETVAR :                       2BA C |
 FETXBY :                       2EC C |  FET_0 :                        2A3 C |
 FET_1 :                        2B0 C |  FIN :                          863 C |
 FLAGS :                         29 D |  FNDDON :                       781 C |
 FNDLBL :                       763 C |  FND_1 :                        769 C |
 FORDON :                       A20 C |  FOR_ER :                       A2F C |
*FULLPMMU :                       1 - |  GETLN :                        636 C |
 GETL_0 :                       63C C |  GETL_1 :                       641 C |
 GETL_2 :                       67D C |  GETL_3 :                       675 C |
 GETL_4 :                       66D C |  GETL_5 :                       658 C |
 GETL_6 :                       64D C |  GETL_7 :                       661 C |
 GETROM :                       4EB C |  GET_BUF :                      4E4 C |
 GET_C :                        4DF C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - |  HEXMOD :                        44 B |
 H_FLG :                         4D B |  IABS :                         3A5 C |
 IADD :                         363 C |  IAND :                         375 C |
 ICPL :                         3A2 C |  IDIV :                         408 C |
 IDIV_0 :                       40A C |  IE :                            A8 D |
*IE0 :                           89 B | *IE1 :                           8B B |
*IEC :                           A8 D |  IFDN_1 :                       60D C |
 IFDN_2 :                       611 C |  IFDONE :                       607 C |
 IINC :                         3B3 C |  IINC_1 :                       3BC C |
 IMOD :                         404 C |  IMUL :                         3F5 C |
 IMUL_1 :                       3C9 C |  IMUL_2 :                       3D3 C |
 IMUL_3 :                       3DD C |  INDEX :                        5B2 C |
 INDTBL :                       1C4 C | *INEXTMODE :                      0 - |
 INIT :                         753 C |  INIT_1 :                       742 C |
 INIT_2 :                       74D C |  INIT_3 :                       752 C |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
 INNUM :                        6FA C |  INSL_1 :                       7E3 C |
*INSRCMODE :                      0 - |  INSRT :                        7EB C |
 INSR_1 :                       7F4 C |  INSR_2 :                       7F7 C |
 INSR_4 :                       80A C |  INSR_L :                       7D7 C |
*INSUPMODE :                      0 - | *INT0 :                          B2 B |
*INT1 :                          B3 B |  INTROM :                       C19 C |
 INUM_0 :                       700 C |  INUM_1 :                       719 C |
 INUM_2 :                       720 C |  INUM_3 :                       709 C |
 INUM_4 :                       70E C |  INUM_5 :                       715 C |
 INUM_6 :                       726 C |  IOR :                          37F C |
 IP :                            B8 D | *IPC :                           B8 D |
 ISUB :                         369 C | *IT0 :                           88 B |
*IT1 :                           8A B |  IXOR :                         389 C |
 KILL_2 :                       789 C |  KILL_3 :                       794 C |
 KILL_9 :                       79D C |  KILL_L :                       783 C |
 LABL_H :                        55 D |  LABL_L :                        54 D |
 LF :                             A - |  LINI_1 :                       627 C |
*LISTON :                         1 - |  LIT :                          178 C |
 LIT_1 :                        187 C |  LNDONE :                       5FD C |
 LOAD_PNTR :                    4D8 C |  LOOP :                         82C C |
 LOOP_0 :                       839 C |  LOOP_1 :                       85D C |
 LOOP_2 :                       85A C |  LST :                          6EB C |
 LSTLIN :                       6D4 C |  LSTL_1 :                       6EA C |
 LSTL_2 :                       6E3 C |  LSTRET :                       6F7 C |
 LST_1 :                        6EF C |  L_CURS :                        4F D |
 L_INIT :                       622 C | *MACEXP :                         1 - |
 MLCALL :                       867 C |  MODE :                          28 D |
 MOD_FLG :                       4C B |  MOMCPU :                      8051 - |
 MOMCPUNAME :                  8051 - |  MSKTBL :                       231 C |
 MSK_PC :                       22E C |  MUL_16 :                       3BD C |
 NEG :                          393 C |  NEG_0 :                        396 C |
 NEG_IF_NEG :                   3AF C | *NESTMAX :                      100 - |
 NIBOUT :                        E6 C |  NIBO_1 :                        F1 C |
 NIBO_2 :                        ED C |  NIBO_3 :                        F4 C |
 NLINE :                         B2 C |  NL_NXT :                       629 C |
 NOTSYM :                       5B7 C |  NOTVAR :                       579 C |
 NO_PROBLEM :                   486 C |  NO_SFR :                         E - |
 NO_VAR :                         C - |  NXT :                          62B C |
 NXT_1 :                        633 C |  OPEN_1 :                       7BE C |
 OPEN_2 :                       7CB C |  OPEN_3 :                       7A2 C |
 OPEN_4 :                       7B0 C |  OPEN_5 :                       7A9 C |
 OPEN_6 :                       7D0 C |  OPEN_L :                       79E C |
 OV :                            D2 B |  OV_TST :                       351 C |
*P :                             D0 B | *P0 :                            80 D |
 P1 :                            90 D |  P2 :                            A0 D |
 P3 :                            B0 D | *PACKING :                        0 - |
*PADDING :                        1 - | *PCON :                          87 D |
 POP_ACC :                      14B C |  POP_TOS :                      139 C |
 PRN :                          689 C |  PRNHEX :                       6B6 C |
 PRNH_1 :                       6C4 C |  PRNRET :                       6D3 C |
 PRNTOS :                       68F C |  PRN_1 :                        69F C |
*PS :                            BC B |  PSW :                           D0 D |
*PT0 :                           B9 B | *PT1 :                           BB B |
 PUSH_C :                       4B4 C |  PUSH_TOS :                     151 C |
 PUTROM :                       511 C |  PUT_BUF :                      50A C |
*PX0 :                           B8 B | *PX1 :                           BA B |
 R4_FLG :                        49 B |  RAMLIM :                      3000 - |
 RAM_INIT :                     72E C | *RB8 :                           9A B |
*RD :                            B7 B |  RDCHDN :                       507 C |
 READ_LABEL :                   615 C |  READ_R4 :                      4FC C |
*RELAXED :                        0 - |  RELOP :                        BCE C |
 REL_1 :                        BD9 C |  REL_2 :                        BE5 C |
 REL_3 :                        BF1 C |  REL_4 :                        BFC C |
 REL_5 :                        C08 C |  REL_6 :                        C13 C |
*REN :                           9C B |  REREAD :                       508 C |
 REWIND :                       4BA C |  REWROM :                       4C4 C |
 RI :                            98 B |  RND :                          465 C |
 ROMMOD :                        41 B | *RS0 :                           D3 B |
*RS1 :                           D4 B |  RSTR :                         824 C |
 RUNMOD :                        43 B |  RUNROM :                        90 C |
 RWXROM :                       4CC C |  RXD :                           B0 B |
 S0 :                           8B7 C |  S1 :                           8EF C |
 S10 :                          986 C |  S10B :                         996 C |
 S10C :                         99E C |  S10D :                         9A9 C |
 S11 :                          9AB C |  S12 :                          9B1 C |
 S13 :                          9C1 C |  S13A :                         9D7 C |
 S13B :                         A00 C |  S13C :                         A31 C |
 S14 :                          A3E C |  S14B :                         A56 C |
 S15 :                          A5B C |  S16 :                          A68 C |
 S16A :                         A75 C |  S17 :                          A85 C |
 S17A :                         A97 C |  S17B :                         AA7 C |
 S17C :                         ABA C |  S18 :                          ACA C |
 S19 :                          ADE C |  S2 :                           8FF C |
 S20 :                          AEB C |  S3 :                           912 C |
 S3A :                          921 C |  S3B :                          929 C |
 S3C :                          934 C |  S5 :                           943 C |
 S5A :                          94E C |  S6 :                           956 C |
 S6A :                          95C C |  S6B :                          959 C |
 S8 :                           95F C |  S8A :                          971 C |
 S8B :                          977 C |  S9 :                           97C C |
 SAV :                          81D C |  SAVE_PNTR :                    4D1 C |
 SBUF :                          99 D |  SCON :                          98 D |
 SE3 :                          8CA C |  SE3A :                         8DA C |
 SE4 :                          8E3 C |  SEED_H :                         E D |
 SEED_L :                         D D |  SEQ_FETCH :                    29D C |
 SEQ_FLG :                       4B B |  SEQ_STORE :                    239 C |
 SETRBI :                       290 C |  SFID_1 :                       1F3 C |
 SFID_2 :                       1FC C |  SFRTBL :                       18C C |
 SFR_ID :                       1EE C |  SGN_FLG :                       4A B |
 SKPLIN :                       525 C |  SKPTXT :                       529 C |
*SM0 :                           9F B | *SM1 :                           9E B |
*SM2 :                           9D B |  SP :                            81 D |
 SPC :                           DF C |  SPLIT_DBA :                    21D C |
 SPLSFR :                       227 C |  SP_BASE :                       55 - |
*SP_INI :                        32 C |  START :                        87B C |
*STDDEF51INC :                    1 - |  STK_ER :                       161 C |
 STMT :                         89F C |  STORE :                        23D C |
 STOR_0 :                       23F C |  STOR_1 :                       252 C |
 STRCBY :                       295 C |  STRDBY :                       27A C |
 STRDIR :                       203 C |  STREXT :                       26E C |
 STRJTB :                       257 C |  STRLEN :                         F D |
 STROUT :                       105 C |  STRO_1 :                       109 C |
 STRO_2 :                       113 C |  STRRBI :                       280 C |
 STRSFR :                       20B C |  STRTBL :                       19A C |
 STRVAR :                       25C C |  STRXBY :                       295 C |
 SYN_ER :                       12E C |  SYN_NG :                       BCC C |
 S_INIT :                        26 C | *T0 :                            B4 B |
*T1 :                            B5 B |  TABCNT :                        50 D |
 TABSIZ :                         8 - | *TB8 :                           9B B |
 TCON :                          88 D |  TERM :                         B34 C |
 TERM_0 :                       B36 C |  TERM_1 :                       B43 C |
 TERM_2 :                       B50 C |  TERM_3 :                       B5F C |
 TERM_4 :                       B6E C | *TF0 :                           8D B |
*TF1 :                           8F B | *TH0 :                           8C D |
 TH1 :                           8D D |  TI :                            99 B |
*TIME :                    19:43:56 - | *TL0 :                           8A D |
*TL1 :                           8B D |  TMOD :                          89 D |
 TMP0 :                           8 D |  TMP1 :                           9 D |
 TMP2 :                           A D |  TMP3 :                           B D |
 TMP4 :                           C D |  TOKEN :                        8A4 C |
*TR0 :                           8C B |  TR1 :                           8E B |
*TRUE :                           1 - |  TST :                          52F C |
 TSTCBY :                       5A6 C |  TSTN :                         5C4 C |
 TSTN_1 :                       5CD C |  TSTRBI :                       58B C |
 TSTS :                         5D9 C |  TSTS_1 :                       5E9 C |
 TSTS_2 :                       5F0 C |  TSTV :                         55F C |
 TSTV_1 :                       5B9 C |  TSTXBY :                       598 C |
 TST_1 :                        537 C |  TST_2 :                        548 C |
*TXD :                           B1 B |  T_BAD :                        552 C |
 T_GOOD :                       54E C |  US_VAR :                        10 D |
 VAR :                          B89 C |  VAR_0 :                        B92 C |
 VAR_1 :                        B98 C |  VAR_1A :                       BAF C |
 VAR_2 :                        BBD C |  VERS :                          23 - |
*VERSION :                     142F - | *WR :                            B6 B |
 WRCH_1 :                       51A C |  WRITE_R4 :                     513 C |
 XEC :                          89C C |  XFER :                         813 C |
 XFERNG :                       81A C |  XINIT :                        75B C |
 XRAD_1 :                       332 C |  ZERSUP :                        48 B |

    473 symbols
     91 unused symbols

 AS V1.42 Beta [Bld 32] - source file tb51as23.asm - page 3 - 1/12/2020 19:43:56
Tiny-Basic51 - Modified for Macro Assembler AS


  defined macros:
  ---------------

COND_                                 | DW_                                  
HOP_                                  | ICALL_                               
IFDONE_                               | IJMP_                                
LINIT_                                | LIT_                                 
MLCALL_                               | NEXT_LOOP_                           
TSTL_                                 | TSTN_                                
TSTS_                                 | TSTV_                                
USING                                 |

     15 macros

 AS V1.42 Beta [Bld 32] - source file tb51as23.asm - page 4 - 1/12/2020 19:43:56
Tiny-Basic51 - Modified for Macro Assembler AS


  DEFINEs:
  --------

TOS_H      = R7
TOS_L      = R6
LP_CNT     = R5
CHAR       = R4
DEST_H     = R3
PNTR_H     = R2
DEST_L     = R1
PNTR_L     = R0
AND        = &
OR         = |

 AS V1.42 Beta [Bld 32] - source file tb51as23.asm - page 5 - 1/12/2020 19:43:56
Tiny-Basic51 - Modified for Macro Assembler AS


  codepages:
  ----------

STANDARD (0 changed characters)


0.07 seconds assembly time

   3415 lines source file
   3539 lines incl. macro expansions
      3 passes
      0 errors
      0 warnings
